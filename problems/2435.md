# üß© Problem #2435 ‚Äì Paths in Matrix Whose Sum Is Divisible by K

**Difficulty:** Hard  
**Topics:** Dynamic Programming, Matrix, Modulo  
**Link:** https://leetcode.com/problems/paths-in-matrix-whose-sum-is-divisible-by-k/

---

## üìù Problem Summary

You are given:

- An `m x n` matrix `grid`
- An integer `k`

You start at `(0, 0)` and must reach `(m - 1, n - 1)` moving **only right or down**.

A path is valid if its **sum of values** is divisible by `k`.

Return the **number of such paths**, modulo `10^9 + 7`.

**Constraints:**

- `1 <= m, n <= 5 * 10^4`
- Total cells: `m * n <= 5 * 10^4`
- `0 <= grid[i][j] <= 100`
- `1 <= k <= 50`

---

## üí° Intuition

Each path accumulates a sum.  
We only care about:

```text
sum % k
```


At each cell `(i, j)`, different paths may arrive with different remainders.

Therefore we need DP with 3 components:

- row index  
- column index  
- remainder (0‚Ä¶k-1)

---

## üçÇ Approach 1 ‚Äî Backtracking (Conceptual Only, TLE)

This explores **all paths**, tracking sum modulo `k`.  
Works for intuition, impossible for constraints.

### Code (TypeScript - TLE)

```ts
function numberOfPaths(grid: number[][], k: number): number {
    const MOD = 1_000_000_007;
    const n = grid.length;
    const m = grid[0].length;

    let pathCount:number = 0;
    function DFS(i, j, rem){
        const newRem = (rem + grid[i][j]) % k;

        // base case
        if(i === n-1 && j === m-1){
            if(newRem === 0){
              pathCount += 1;
              pathCount %= MOD;
            }
        }

        // right
        if((j+1) < m) DFS(i, j+1, (rem+grid[i][j])%k);
        // down
        if((i+1) < n) DFS(i+1, j, (rem+grid[i][j])%k);
    }
    DFS(0, 0, 0);

    return pathCount;
};
```

---

## üå± Approach 2 ‚Äî Top-Down DP (Memoized DFS)

This is the easiest to understand DP version.

### State

```text
DFS(i, j, rem)
= number of paths from (i, j) ‚Üí end
  given current sum % k = rem BEFORE adding grid[i][j]
```

When entering `(i, j)`:
```text
newRem = (rem + grid[i][j]) % k
```

Then move:

- right ‚Üí `(i, j+1)`
- down ‚Üí `(i+1, j)`

Memo key: `(i, j, rem)`

Code (Top-Down DP)

```ts
function numberOfPaths(grid: number[][], k: number): number {
    const MOD = 1_000_000_007;
    const n = grid.length;
    const m = grid[0].length;

    // building 3D DP of size n*m*k
    // end cell store count of paths
    const DP = [];
    for(let i=0; i<n; i++){
        const row = [];
        for(let j=0; j<m; j++) row.push(new Array(k).fill(null));
        DP.push(row);
    }

    function DFS(i:number, j:number, rem:number): number{
        const newRem = (rem+grid[i][j])%k;
        // base case
        if(i === n-1 && j === m-1) return (newRem === 0) ? 1 : 0;
        // DP
        if(DP[i][j][rem] !== null) return DP[i][j][rem];


        let ways: number = 0;
        // right
        if((j+1) < m) {
            ways += DFS(i, j+1, newRem);
            ways %= MOD;
        }
        // down
        if((i+1) < n) { 
            ways += DFS(i+1, j, newRem);
            ways %= MOD;
        }

        DP[i][j][rem] = ways;
        return ways;
    }
    return DFS(0, 0, 0);
}
```

---

## üåø Approach 3 ‚Äî Bottom-Up DP (Tabulation)

This iterates from top-left to bottom-right.

### State

```text
dp[i][j][r] = number of paths reaching (i, j) with remainder r
```

Transition:

```text
from top: dp[i-1][j][r_prev]
from left: dp[i][j-1][r_prev]

r_new = (r_prev + grid[i][j]) % k
```

Final answer: `dp[m-1][n-1][0]`

### Code (Bottom-Up DP)

```ts
function numberOfPaths(grid: number[][], k: number): number {
    const MOD = 1_000_000_007;
    const m = grid.length;
    const n = grid[0].length;

    const dp: number[][][] = Array.from({ length: m }, () =>
        Array.from({ length: n }, () => new Array(k).fill(0))
    );

    const firstRem = grid[0][0] % k;
    dp[0][0][firstRem] = 1;

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            const val = grid[i][j] % k;

            if (i === 0 && j === 0) continue;

            for (let rPrev = 0; rPrev < k; rPrev++) {
                const fromTop = i > 0 ? dp[i - 1][j][rPrev] : 0;
                const fromLeft = j > 0 ? dp[i][j - 1][rPrev] : 0;
                const count = (fromTop + fromLeft) % MOD;

                if (count === 0) continue;

                const rNew = (rPrev + val) % k;
                dp[i][j][rNew] = (dp[i][j][rNew] + count) % MOD;
            }
        }
    }

    return dp[m - 1][n - 1][0];
}
```

---

## üå≤ Approach 4 ‚Äî Space-Optimized Bottom-Up DP (O(n * k) Space)

### Idea

We use the same state as in full bottom-up DP:

```text
dp[i][j][r] = number of paths reaching (i, j) with sum % k == r
```

### Transition:

- From top: `(i-1, j)`
- From left: `(i, j-1)`
- New remainder: r_new = (r_prev + grid[i][j]) % k

But we don‚Äôt need to keep all rows at once.

At row `i`, cell `(i, j)` depends on:

- row `i - 1` ‚Üí we store this in `prev[j][r]`
- row i, column j - 1 ‚Üí we build this in `cur[j-1][r]`

So we only need:

- prev: `number[n][k]` ‚Äì previous row
- cur: `number[n][k]` ‚Äì current row

After finishing each row, do `prev = cur` and reinitialise `cur`.

### Code (TypeScript, O(n * k) Space)

```ts
function numberOfPaths(grid: number[][], k: number): number {
    const MOD = 1_000_000_007;
    const m = grid.length;
    const n = grid[0].length;

    // Helper to create a row: n cells √ó k remainders
    const makeRow = () =>
        Array.from({ length: n }, () => new Array<number>(k).fill(0));

    let prev = makeRow();
    let cur = makeRow();

    for (let i = 0; i < m; i++) {
        // reset current row
        cur = makeRow();

        for (let j = 0; j < n; j++) {
            const val = grid[i][j] % k;

            // Base cell (0, 0): one path with remainder grid[0][0] % k
            if (i === 0 && j === 0) {
                const r0 = val; // sum = grid[0][0]
                cur[0][r0] = 1;
                continue;
            }

            for (let rPrev = 0; rPrev < k; rPrev++) {
                let count = 0;

                // from top row
                if (i > 0) {
                    count = (count + prev[j][rPrev]) % MOD;
                }

                // from left cell in same row
                if (j > 0) {
                    count = (count + cur[j - 1][rPrev]) % MOD;
                }

                if (count === 0) continue;

                const rNew = (rPrev + val) % k;
                cur[j][rNew] = (cur[j][rNew] + count) % MOD;
            }
        }

        // current row becomes previous for next iteration
        prev = cur;
    }

    // At the end, prev[n - 1][0] is ways to reach (m-1, n-1) with remainder 0
    return prev[n - 1][0];
}
```

---

## üìä Final Comparison Table

| Approach                             | Technique                    | Time Complexity     | Space Complexity      | Works Under Constraints? | Notes |
|--------------------------------------|------------------------------|----------------------|------------------------|---------------------------|-------|
| 1. Backtracking (Naive)              | DFS without memo             | Exponential          | O(1)                   | ‚ùå No                    | Only useful for intuition; recomputes same paths repeatedly |
| 2. Top-Down DP (Memoized DFS)        | DFS + memo (i, j, rem)       | O(m * n * k)         | O(m * n * k)           | ‚úÖ Yes                   | Easiest to understand; recursion depth could be high |
| 3. Bottom-Up DP (3D Table)           | Iterative DP                 | O(m * n * k)         | O(m * n * k)           | ‚úÖ Yes                   | Straightforward tabulation; heavy memory usage |
| 4. Space-Optimized Bottom-Up DP      | Row-by-row rolling array     | O(m * n * k)         | O(n * k)               | ‚úÖ Yes                   | Best memory efficiency; most production-ready |

---
