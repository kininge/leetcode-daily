# üß© Problem #2211 ‚Äì Count Collisions on a Road

**Difficulty:** Medium  
**Topics:** Stack, Simulation, Greedy, Two Pointers  
**Link:** https://leetcode.com/problems/count-collisions-on-a-road/

---

## üìù Problem Summary

You are given a string `directions` of length `n`, where:

- `directions[i] == 'L'` ‚Üí i-th car moves left
- `directions[i] == 'R'` ‚Üí i-th car moves right
- `directions[i] == 'S'` ‚Üí i-th car stays still

All cars move with the same speed on an infinite 1D road.  
Collisions:

- When a car moving left meets a car moving right ‚Üí **+2 collisions**, both become stationary.
- When a moving car hits a stationary car ‚Üí **+1 collision**, and becomes stationary.
- Once a car is in a collision, it becomes stationary and doesn‚Äôt move anymore.

Goal:  
Return the **total number of collisions** that will happen.

---

## üí° Intuition

Two key observations:

1. Cars that can **escape**:
   - Leading `'L'` cars at the far left can go off to `-‚àû` without hitting anyone.
   - Trailing `'R'` cars at the far right can go to `+‚àû` safely.
   These contribute **0 collisions**.

2. In the remaining middle segment:
   - Every `'L'` will eventually hit either `'S'` or `'R'`.
   - Every `'R'` will eventually hit either `'S'` or `'L'`.
   - So **every non-`'S'` car in the middle collides** at least once.

That gives a very clean O(n) solution:
- Trim the escapable `L` and `R` from ends.
- Count how many chars are not `'S'` inside ‚Üí that‚Äôs the number of collisions.

But we can also reason in a more ‚Äúsimulation-style‚Äù way using your **stack idea**, if we fix the missing chain-collision logic for multiple `'R'`s.

---

## üçÉ Approach 1 ‚Äì Trim Escapable Cars, Count Colliding Ones (Greedy)

### Idea

1. Move a pointer `left` from the start while `directions[left] == 'L'`.  
   These cars escape to the left.
2. Move a pointer `right` from the end while `directions[right] == 'R'`.  
   These cars escape to the right.
3. In the remaining substring `[left..right]`, **every car that is not `'S'` will collide**:
   - `'R'` must meet something to the right
   - `'L'` must meet something to the left

So collisions = count of `'L'` + `'R'` in `directions[left..right]`.

---

## üßæ Code ‚Äì Approach 1 (TypeScript)

```ts
function countCollisions(directions: string): number {
    let left = 0;
    let right = directions.length - 1;

    // Trim left 'L' cars that escape
    while (left <= right && directions[left] === 'L') {
        left++;
    }

    // Trim right 'R' cars that escape
    while (right >= left && directions[right] === 'R') {
        right--;
    }

    let collisions = 0;

    // In the middle segment, all non-'S' cars will collide
    for (let i = left; i <= right; i++) {
        if (directions[i] !== 'S') {
            collisions++;
        }
    }

    return collisions;
}
```

### Your core idea

You tried to use a **stack** of car states:

- Push `'R'` as ‚Äúcars moving right‚Äù
- When `'L'` or `'S'` comes, collide with last car from stack
- After collision, result becomes `'S'` and is pushed to the stack

This is a good direction, but the missing piece was:

> When an `'L'` car collides with a `'R'` at the front,  
> the newly formed `'S'` block may also get hit by **earlier `'R'`s behind**.

Example: `R R L`

- First `R` and `L` collide ‚Üí `+2`
- Remaining earlier `R` runs into the new `S` ‚Üí `+1`
- Total = 3, but your old logic only gave 2, because it never ‚Äúwalked back‚Äù through previous `R`s.

### Fix: handle chain collisions

We maintain a stack of `'R'` and `'S'` only:

1. When we see `'R'`:
   - Just push `'R'`.
2. When we see `'S'`:
   - While top of stack is `'R'`:
     - Each `R` will crash into this `S` ‚Üí `collisions++`.
     - Pop that `'R'`.
   - Push `'S'`.
3. When we see `'L'`:
   - If stack is empty:
     - Car goes off to the left, no collision.
   - Else:
     - If top is `'S'`:
       - `'L'` hits `S` ‚Üí `collisions++`, becomes `S`.
     - If top is `'R'`:
       - First `'R'` and `'L'` collide head-on ‚Üí `collisions += 2` and both become `S`.
       - Pop that `'R'`.
       - Now treat current car as `S` and:
         - While top is `'R'`:
           - Each `'R'` hits this `S` ‚Üí `collisions++`, pop `'R'`.
     - Finally push `'S'` as the result of these collisions.

This fixes the missing ‚Äúfurther check previous Rs‚Äù part of your idea.

---

## üßæ Code ‚Äì Approach 2 (Stack, TypeScript)

```ts
function countCollisions(directions: string): number {
    const stack: string[] = [];
    let collisions = 0;

    for (const car of directions) {
        if (car === 'R') {
            // Just moving right, might collide later
            stack.push('R');
        } else if (car === 'S') {
            // All R's before will eventually collide into this S
            while (stack.length > 0 && stack[stack.length - 1] === 'R') {
                collisions++;
                stack.pop();
            }
            stack.push('S');
        } else { // car === 'L'
            if (stack.length === 0) {
                // Car leaves to the left, no collision
                continue;
            }

            const top = stack[stack.length - 1];

            if (top === 'S') {
                // L hits stationary S
                collisions++;
            } else if (top === 'R') {
                // First R-L head-on collision
                collisions += 2;
                stack.pop(); // consume that R

                // Now car becomes S and may be hit by previous R's
                while (stack.length > 0 && stack[stack.length - 1] === 'R') {
                    collisions++;
                    stack.pop();
                }
            }

            // After handling all collisions, resulting car is S
            stack.push('S');
        }
    }

    return collisions;
}
```

---

## ‚è±Ô∏è Complexity

For **both approaches**:

- We scan the string once.
- Each car is pushed/popped at most once (in the stack version).

So:

- **Time:** `O(n)`
- **Space:**  
  - Approach 1: `O(1)`  
  - Approach 2: `O(n)` for the stack

In practice, Approach 1 is simpler and cleaner,  
while Approach 2 is a nice simulation that matches your original thinking, with correct chain-collision handling.

---
