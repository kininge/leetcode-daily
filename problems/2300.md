# üß© Problem #2300 ‚Äì Successful Pairs of Spells and Potions

**Difficulty:** Medium  
**Topics:** `Binary Search`, `Sorting`, `Two Pointers`  
**Link:** [LeetCode](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/)

---

## üìú Problem Summary
You are given two positive integer arrays `spells` (length `n`) and `potions` (length `m`).  
A spell `i` and potion `j` form a **successful pair** if:

```plaintext
spells[i] * potions[j] >= success
```


Return an integer array `pairs` of length `n` where `pairs[i]` is the number of potions that form a successful pair with `spells[i]`.

---

## üí° Approach 1 ‚Äì Brute Force (O(n*m))

### üß© Idea
For each spell, check every potion and count those that satisfy the product constraint.

### üßÆ Complexity
| Metric | Value |
|--------|-------|
| Time | **O(n * m)** |
| Space | **O(n)** (for output) |

### üíª Code
```Typescript []
function successfulPairsBrute(spells: number[], potions: number[], success: number): number[] {
  const n = spells.length;
  const m = potions.length;
  const ans: number[] = new Array(n).fill(0);

  for (let i = 0; i < n; i++) {
    let cnt = 0;
    for (let j = 0; j < m; j++) {
      if (1n * BigInt(spells[i]) * BigInt(potions[j]) >= BigInt(success)) {
        cnt++;
      }
    }
    ans[i] = cnt;
  }
  return ans;
}
```

### Note: 
I used `BigInt` in the product check to ensure absolute safety if you port this to languages/environments with smaller integer bounds. In JavaScript, `Number` handles up to ~9e15 exactly (2^53), and `success ‚â§ 1e10` so `Number` arithmetic is safe here ‚Äî but `BigInt` is a defensive choice.

---

## üí° Approach 2 ‚Äì Sort + Binary Search (O(n log m + m log m))


### üîë Key Insight

For a given `spell = s`, the condition `s * p >= success` is equivalent to:

```plaintext
p >= ceil(success / s)
```

So for each spell, we need to count how many potions are ‚â• `required = ceil(success / s)`.

If `potions` is sorted ascending, then the count = `m - first_index_with_potion >= required`.
We can find that index using binary search.

### üß© Steps

1. Sort `potions` ascending. (O(m log m))
2. For each `spell`:
  - Compute `required = Math.ceil(success / spell)` (use integer ceiling).
  - Binary search the first potion index where `potions[idx] >= required`.
  - If found, `pairs[i] = m - idx`, else `0`.

### üßÆ Complexity

| Metric | 	Value |
| -- | -- |
| Time	| O(m log m + n log m) |
| Space |	O(n) (output) |

### üíª Code (TypeScript) ‚Äî clean, safe, and efficient

```Typescript []
function successfulPairs(spells: number[], potions: number[], success: number): number[] {
    // We just want count of pairs those are successful, So we can sort is (order do not matter)
    potions.sort((a,b)=> a-b); // O(NlogN)

    // Search smallest succesful postion's index
    // O(logN)
    function searchSmallestSucessfulPotionIndex(successLimit: number): number{
        // edge cases
        if(potions[potions.length-1] < successLimit) return -1; // no potion sucessful
        if(potions[0] >= successLimit) return 0; // all potions are sucessful

        let leftIndex: number = 0;
        let rightIndex: number = potions.length-1;
        let sucessfulPotionIndex: number = -1;

        while(leftIndex <= rightIndex){
            const midIndex: number = (leftIndex+rightIndex)>>1; // used bit manipulation for division by 2
            const _potion: number = potions[midIndex];

            if(_potion >= successLimit){
                // we found 1 sucessful potion, to search smallest one we g further left
                sucessfulPotionIndex = midIndex;
                rightIndex = midIndex-1;
            }else{
                leftIndex = midIndex+1;
            }
        }

        return sucessfulPotionIndex;
    }

    const ans: number[] = new Array(spells.length).fill(0);

    // check each pair
    for(let index=0; index<spells.length; index++){ // O(N)
        const spellStrength: number = spells[index];

        // rather checking --> success < (a*b)
        // checking --> (success/a) < b => because success is very big number 10^10 (intiger limit overflow)
        const potionStrengthNeeded: number = success/spellStrength; // 
        const smallestSucessfulPotionIndex: number = searchSmallestSucessfulPotionIndex(potionStrengthNeeded); // O(logN)

        if(smallestSucessfulPotionIndex >= 0) ans[index] = (potions.length-smallestSucessfulPotionIndex);
    }

    return ans;
};
```

## ‚úÖ Notes on correctness & numeric safety

- I used `Math.ceil(success / s)` which is safe in JavaScript for the given constraints (`success ‚â§ 1e10, s ‚â§ 1e5`) because numbers are within safe integer range.
- If you want absolute integer-safety for arbitrary bigger inputs, compute required as:

```plaintext
const required = Math.floor((BigInt(success) + BigInt(s) - 1n) / BigInt(s));
```

and then use binary search/compare with `BigInt`-converted potions (but that complicates things; not necessary here).

## üîç Comparison of Both Approaches

| Feature	| Brute Force |	Sort + Binary Search |
| --- | --- | --- |
| Logic |	Check all pairs |	Precompute threshold per spell + binary search |
| Time Complexity |	O(n*m) |	O(m log m + n log m) |
| Space Complexity |	O(n) |	O(n) |
| Practical Use |	Simple, but TLE for large sizes |	Recommended for constraints up to 1e5 |

## üèÅ Final Notes / Tips

- Sorting potions once and binary-searching per spell is the standard optimal approach for this problem.
- Watch out for integer overflow in languages with limited integer ranges ‚Äî use long/int64/BigInt if unsure.
- Micro-optimization: if many spells repeat, you can memoize results for repeated s values to avoid redundant binary searches (trade memory for less log work).
- If you need absolute safe integer arithmetic for extremely large inputs, use BigInt for division and comparisons.
