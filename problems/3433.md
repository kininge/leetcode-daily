# üß© Problem #3433 ‚Äì Count Mentions Per User

**Difficulty:** Medium  
**Topics:** `Simulation`, `Design`      
**Link:** https://leetcode.com/problems/count-mentions-per-user/

---

## üìù Problem Summary

You are given an integer `numberOfUsers` and an array `events` of length `m` where each event is either:

- `["MESSAGE", timestamp, mentions_string]`  
  - `mentions_string` is one of:
    - `"ALL"` ‚Äî all users are mentioned (counts for offline too)
    - `"HERE"` ‚Äî all **online** users at that timestamp are mentioned
    - `"idX idY ..." ` ‚Äî explicit `id<number>` tokens (duplicates allowed; each counts)
- `["OFFLINE", timestamp, id]`  
  - The user `id` goes offline at `timestamp` and becomes online again at `timestamp + 60`.
  - Status changes at a timestamp are applied **before** processing any MESSAGE at the same timestamp.

All users are initially online.  
Return an array `mentions` of length `numberOfUsers` where `mentions[i]` is the total number of mentions user `i` receives across all MESSAGE events.

**Constraints**
- `1 ‚â§ numberOfUsers ‚â§ 100`
- `1 ‚â§ events.length ‚â§ 100`
- `1 ‚â§ timestamp ‚â§ 10^5`
- `0 ‚â§ id ‚â§ numberOfUsers - 1`
- Each `mentions_string` has 1..100 id tokens when it is explicit ids.

---

## üí° Intuition

We must simulate events in chronological order and correctly track who is online at each MESSAGE.

Key details:
- **Ordering:** For events with the same timestamp, **OFFLINE** changes are applied *before* any **MESSAGE** at that timestamp.
- **Offline window:** An OFFLINE at time `t` makes user offline for `(t, t+60)` ‚Äî they are back online at `t+60`. Equivalently, user `u` is offline at time `T` iff `offlineUntil[u] > T`.
- **Message types:**
  - `ALL` ‚Äî increments every user (offline or online).
  - `HERE` ‚Äî increments **only** users currently online at that time.
  - `idX idY ...` ‚Äî explicit ids; duplicates count multiple times and offline users may still be mentioned.
- **Constraints small:** `numberOfUsers ‚â§ 100`, `events ‚â§ 100` ‚Äî so O(numberOfUsers * events) loops are fine.

Two solid implementations:
1. **Your approach (heap + set)** ‚Äî tracks active offline expiries in a min-heap and a Set of currently-offline users; pops expiries as time advances.
   - Works, can be fast in practice but has more moving parts (heap + set).
2. **Single-array approach (offlineUntil)** ‚Äî maintain `offlineUntil[u]` timestamp for each user; check `offlineUntil[u] > currentTime` to know offline state.
   - Simpler, easier to reason about, minimal state; same asymptotic complexity.

Both require:
- Sorting events by `(time, OFFLINE before MESSAGE)`.
- Robust parsing of tokens (`split(/\s+/)`), and respecting duplicates.

---

## üçÉ Approach 1 ‚Äî Manage offline expiries with a min-heap + Set (User's solution)

### Idea
- Parse and sort events by time; for same timestamp process `OFFLINE` before `MESSAGE`.
- Keep a `Set` (`offlineUsers`) of currently-offline user ids.
- Keep a min-heap of expiry nodes `{ time: offlineUntil, id }` so you can pop users who become online as time advances.
- Before handling each event at time `t`, pop all heap nodes with `time <= t` and remove those ids from the `offlineUsers` set.
- For `OFFLINE t id`: push `{ time: t + 60, id }` to heap and add `id` to the set.
- For `MESSAGE t payload`:
  - `ALL` ‚Üí increment all users.
  - `HERE` ‚Üí increment only users not in `offlineUsers`.
  - explicit `idX` tokens ‚Üí parse and increment mentioned ids (duplicates counted).

### Code (TypeScript) ‚Äî original user implementation (condensed)
```ts
// (Uses user's MyHeap implementation posted earlier)
function countMentions(numberOfUsers: number, events: string[][]): number[] {
    // parse and sort events (OFFLINE before MESSAGE at same time)
    const input = events.map(([e, t, ids]) => ({ event: e, time: Number(t), ids }));
    input.sort((a, b) => a.time - b.time || (a.event === "OFFLINE" ? -1 : 1));

    const mentions = new Array(numberOfUsers).fill(0);
    const offlineUsers = new Set<number>();
    const offlineHeap = new MyHeap((c, p) => c.time < p.time);

    const parseIdTokens = (ids: string) =>
        ids.trim().split(/\s+/).map(tok => Number(tok.slice(2)));

    for (const { event, time, ids } of input) {
        // pop expiries and bring users online
        while (!offlineHeap.isEmpty() && offlineHeap.peek().time <= time) {
            const node = offlineHeap.pop();
            offlineUsers.delete(node.id);
        }

        if (event === "OFFLINE") {
            const id = Number(ids);
            offlineHeap.append({ time: time + 60, id });
            offlineUsers.add(id);
        } else { // MESSAGE
            if (ids === "ALL") {
                for (let i = 0; i < numberOfUsers; i++) mentions[i] += 1;
            } else if (ids === "HERE") {
                for (let i = 0; i < numberOfUsers; i++) {
                    if (!offlineUsers.has(i)) mentions[i] += 1;
                }
            } else {
                const list = parseIdTokens(ids);
                for (const id of list) mentions[id] += 1; // duplicates counted
            }
        }
    }

    return mentions;
}

class MyHeap{
    _heap = []; // heap is complete-binery-tree - We can represent this as array

    // This function 'True' if argument1 more prior than argument2 node
    _check = null; // comparator function => f(childNode, parentNode) -> boolean

    // get comparator function as setter initially
    constructor(comparatorFunction){
        if(typeof(comparatorFunction) === "function"){
            this._check = comparatorFunction;
        }
    }

    _swap(index1, index2){
        const temp = this._heap[index1];
        this._heap[index1] = this._heap[index2];
        this._heap[index2] = temp;
    }

    // upward heapification - low end added node push up to check it's right position
    _upwardHeapification(_childNodeIndex){
        let childIndex = _childNodeIndex;

        while(childIndex > 0){ 
            const parentIndex = Math.floor((childIndex-1)/2);

            const shouldChildNodeGoUp = this._check(this._heap[childIndex], this._heap[parentIndex]);
           if(shouldChildNodeGoUp) { 
                this._swap(childIndex, parentIndex);
                childIndex = parentIndex;
            } else break;

        }
    }

    // downward heapification - upper end node pushing down to check it's right position
    _downwardHeapification(_parentNodeIndex){
        let parentIndex = _parentNodeIndex;
        // heap is representation of binery tree --> each parent will have 0, 1, 2 nodes as a child/children
        // childIndex1 = parentIndex*2+1;
        // childIndex2 = parentIndex*2+2;

        // there at least 1 child node should have to compare
        while((parentIndex*2+1) < this._heap.length){ 
            const childIndex1 = parentIndex*2+1;
            const childIndex2 = parentIndex*2+2;

            // now we need to check among 2 children - from which child parent should compare?
            // We will compare parent to most prior child among 2 children
            let mostPriorChildIndex = childIndex1;
            const child2Exist = (childIndex2 < this._heap.length);
            if(child2Exist && this._check(this._heap[childIndex2], this._heap[childIndex1])){
                mostPriorChildIndex = childIndex2;
            }

            const shouldChildNodeGoUp = this._check(this._heap[mostPriorChildIndex], this._heap[parentIndex]);
           if(shouldChildNodeGoUp) {
                this._swap(mostPriorChildIndex, parentIndex);
                parentIndex = mostPriorChildIndex;
            } else break;

        }
    }

    // add new node to heap
    append(node){
        this._heap.push(node);                  // new node added at leaf
        let childIndex = this._heap.length-1;   // new added node's current position
        this._upwardHeapification(childIndex);  // this will push this child node upward in heap to it's right position in O(LogN)
    }

    // remove root node from heap
    pop(){
        if(this._heap.length === 0) return null;
        if(this._heap.length === 1) { 
            const root = this._heap[0];
            this._heap = [];
            return root;
        }

        this._swap(0, this._heap.length-1); // replace root node with leaf node
        const rootNode = this._heap.pop(); // root node (which right now at leaf) pop and store
        this._downwardHeapification(0); // that leaf node (which right now at root) push downward in heap to it's right position in O(LogN)

        return rootNode;
    }

    peek(){
        return this._heap[0];
    }

    // 
    isEmpty(){
        return this._heap.length === 0;
    }
}
```

### Pros

- Works correctly under the problem rules as written.
- Heap ensures you only process expiries when needed (you don't scan all users every event).
- `offlineUsers` Set gives `O(1)` check for `HERE`.

### Cons / Caveats

- Complexity of implementation: custom heap + set duplicates state and increases the surface for subtle bugs.
- Redundant state: both heap and set represent offline users ‚Äî synchronising them is required (your code does), but duplication increases maintenance risk.
- Unnecessary for constraints: with `numberOfUsers ‚â§ 100` and `events ‚â§ 100`, a single `offlineUntil[]` array is simpler and clearer.
- Parsing fragility: ensure token split uses `split(/\s+/)` and `trim()` to avoid empty tokens.
- Potential duplicate expiry entries (if spec changed): your heap would hold multiple expiry nodes for the same id if re-offlined before earlier expiry; the set deletion logic assumes no duplicates or handles them implicitly ‚Äî careful if constraints change.

### Complexity

- **Time:** dominated by event processing. Each heap operation is `O(log E)`, and you pop at most one expiry per OFFLINE event; overall roughly `O(E log E + U * E_for_HERE/ALL)` where U ‚â§ 100.
- **Space:** `O(U + number_of_offline_nodes)` for Set + heap; asymptotically `O(U)`.

---

## üå± Approach 2 ‚Äî Track offline windows with a single array `offlineUntil`

### Idea
Keep one authoritative state per user:

- `offlineUntil[u]` = timestamp when user `u` becomes **online again**.
- A user `u` is **offline at time `T`** iff `offlineUntil[u] > T`.
- When an `OFFLINE` event at time `t` for `id` happens, set `offlineUntil[id] = t + 60`.
- Before processing a `MESSAGE` at time `t`, use `offlineUntil` to decide who is online.

This removes the heap and the Set ‚Äî only a single `O(numberOfUsers)` array is needed. Given constraints (`numberOfUsers ‚â§ 100`, `events ‚â§ 100`) this is extremely simple and fast.

### Code (TypeScript)

```ts
function countMentions(numberOfUsers: number, events: string[][]): number[] {
    // Parse & normalize events and sort: OFFLINE before MESSAGE at same timestamp
    const parsed: { type: "OFFLINE" | "MESSAGE"; time: number; payload: string }[] = [];
    for (const e of events) {
        parsed.push({ type: e[0] as any, time: Number(e[1]), payload: e[2] });
    }
    parsed.sort((a, b) => a.time - b.time || (a.type === "OFFLINE" ? -1 : 1));

    const mentions = new Array<number>(numberOfUsers).fill(0);
    // offlineUntil[u] = time when u becomes online again. User is offline at T iff offlineUntil[u] > T
    const offlineUntil = new Array<number>(numberOfUsers).fill(0);

    const parseIds = (s: string): number[] =>
        s.trim().split(/\s+/).filter(Boolean).map(tok => Number(tok.slice(2)));

    for (const ev of parsed) {
        const t = ev.time;
        if (ev.type === "OFFLINE") {
            const id = Number(ev.payload);
            offlineUntil[id] = t + 60; // offline for times (t, t+60), back online at t+60
            continue;
        }

        // MESSAGE handling
        const p = ev.payload;
        if (p === "ALL") {
            for (let u = 0; u < numberOfUsers; u++) mentions[u] += 1;
        } else if (p === "HERE") {
            for (let u = 0; u < numberOfUsers; u++) {
                if (offlineUntil[u] <= t) { // online if offlineUntil[u] <= t
                    mentions[u] += 1;
                }
            }
        } else {
            // explicit id tokens (duplicates counted)
            const ids = parseIds(p);
            for (const id of ids) mentions[id] += 1;
        }
    }

    return mentions;
}
```

### Pros

- Simplicity: single source of truth (`offlineUntil`) ‚Äî easy to reason about.
- Memory: `O(numberOfUsers)` ‚Äî tiny for given constraints.
- Performance: `O(events * numberOfUsers)` worst case (only `HERE/ALL` loop over users) ‚Äî acceptable for constraints.
- Correctness: clean handling of `offlineUntil[u] === t` (user becomes online before messages at `t`).

### Cons

- Slightly more brute-force when `HERE/ALL` are frequent, since you scan all users each time ‚Äî but `numberOfUsers ‚â§ 100`, so negligible.

### Complexity

- **Time:** `O(E * U)` in worst-case when every message iterates over users (`E = events.length`, `U = numberOfUsers`). With `E, U ‚â§ 100`, trivial.
- **Space:** `O(U)`.

---

## üìä Comparison of Both Approaches

| Aspect | Approach 1: Heap + Set (Your Solution) | Approach 2: `offlineUntil[]` Array (Simplified) |
|--------|----------------------------------------|-------------------------------------------------|
| **State Tracking** | Uses **two structures**: a min-heap for expiry times + a Set of offline users | Uses **one array** `offlineUntil[u]` for all online/offline logic |
| **Offline ‚Üí Online Logic** | Pop from heap while `expiry <= currentTime`, remove from Set | Check `offlineUntil[u] > currentTime` directly; no heap needed |
| **Online Check** | `!offlineUsers.has(u)` | `offlineUntil[u] <= t` |
| **Message: ALL** | Increment all users (`O(U)`) | Increment all users (`O(U)`) |
| **Message: HERE** | Iterate users; check Set (`O(U)`) | Iterate users; check array (`O(U)`) |
| **Message: explicit ids** | Parses and increments; duplicates allowed (`O(K)`) | Same; simpler token parser (`O(K)`) |
| **Sorting Rule Handling** | Custom sort: OFFLINE before MESSAGE at same timestamp | Same rule, cleaner code |
| **Time Complexity** | O(E¬∑logE + E¬∑U) ‚Äî heap ops + `HERE`/`ALL` loops | O(E¬∑U + E¬∑K) ‚Äî no heap; U ‚â§ 100 |
| **Space Complexity** | O(U) for Set + O(#offline events) for heap | O(U) ‚Äî single array; minimal |
| **Implementation Complexity** | Higher ‚Äî heap maintenance + Set sync | Very low ‚Äî single source of truth |
| **Risk of Bugs** | Moderate ‚Äî dual state, heap removal order, duplicates | Low ‚Äî straightforward timestamp comparison |
| **Practical Speed** | Can be fast when few expiries; JS engine-dependent | Also very fast; tends to be more stable and predictable |
| **Best Use Case** | If managing many overlapping offline windows (not needed here) | Ideal for this problem‚Äôs constraints (`U ‚â§ 100`, `E ‚â§ 100`) |

---

## üìå Final Takeaways

- Your heap-based design **works** and can run fast in practice, especially with a few experiments.
- The `offlineUntil[]` approach is:
  - simpler,
  - easier to verify,
  - uses minimal memory,
  - and is perfectly suited for the problem‚Äôs small constraints.
- Both are valid; the second one is preferred for clean design, unless future constraints drastically change.

---

