# 🧩 Problem #3397 – Maximum Number of Distinct Elements After Operations

**Difficulty:** Medium  
**Topics:** `Greedy`, `Sorting`, `Array`, `Intervals`  
**Link:** [Leetcode](https://leetcode.com/problems/maximum-number-of-distinct-elements-after-operations/)

---

## 🧠 Intuition

Each element `nums[i]` can be adjusted to any integer in the range `[nums[i] - k, nums[i] + k]`.  
We want to **maximise the number of distinct elements** after performing at most one operation per element.

👉 Think of each element as an *interval* `[L, R] = [nums[i]-k, nums[i]+k]`.  
If two intervals overlap, we must pick distinct numbers from each — like assigning unique points within overlapping intervals.

To ensure the maximum number of distinct elements, we should always assign:
> the smallest possible number that is still greater than the last assigned number  
> and lies within the current element’s interval.

This greedy strategy guarantees we leave as much “space” as possible for upcoming elements.

---

## 🧩 Approach

1. **Sort the array** — so intervals are processed in ascending order.  
2. Initialize `lastAssigned = -∞`.  
3. For each number:
   - Compute its range → `left = x - k`, `right = x + k`.  
   - Choose the smallest valid integer `candidate = max(lastAssigned + 1, left)`.  
   - If `candidate <= right`, assign it and increment the count.  
4. Return the count.

---

## 💻 Code (TypeScript)

```ts
function maxDistinctElements(nums: number[], k: number): number {
  nums.sort((a, b) => a - b);
  let lastAssigned = -Infinity;
  let count = 0;

  for (const x of nums) {
    const left = x - k;
    const right = x + k;

    const candidate = Math.max(lastAssigned + 1, left);

    if (candidate <= right) {
      count++;
      lastAssigned = candidate;
    }
  }

  return count;
}
```

---

## ⏱️ Complexity Analysis

**Time:** `O(n log n)` — sorting dominates.
**Space:** `O(1)` — in-place greedy.

---

## 🧩 Example Walkthrough

### Example 1:

```text
nums = [1, 1, 2]
k = 1
```

After sorting: `[1, 1, 2]`
Intervals → `[0,2], [0,2], [1,3]`

| Interval |	Candidate |	Pick |	Count |
| -------- | ---------- | ---- | ------ |
| [0,2] |	max(-∞+1,0)=0 |	✅ 0 |	1 |
| [0,2] |	max(0+1,0)=1 |	✅ 1 |	2 |
| [1,3] |	max(1+1,1)=2 |	✅ 2 |	3 |

**✅ Answer = 3**

---

## 💡 Takeaway

The trick is realising this problem is a maximum non-overlapping integer assignment —
A greedy + sorting combo perfectly fits since each interval is independent but ordered.

Once you think in terms of ranges, the problem almost solves itself.
If you didn’t — welcome to the greedy enlightenment club. 😎

---
