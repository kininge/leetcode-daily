# ğŸ§© Problem #3397 â€“ Maximum Number of Distinct Elements After Operations

**Difficulty:** Medium  
**Topics:** `Greedy`, `Sorting`, `Array`, `Intervals`  
**Link:** [Leetcode](https://leetcode.com/problems/maximum-number-of-distinct-elements-after-operations/)

---

## ğŸ§  Intuition

Each element `nums[i]` can be adjusted to any integer in the range `[nums[i] - k, nums[i] + k]`.  
We want to **maximise the number of distinct elements** after performing at most one operation per element.

ğŸ‘‰ Think of each element as an *interval* `[L, R] = [nums[i]-k, nums[i]+k]`.  
If two intervals overlap, we must pick distinct numbers from each â€” like assigning unique points within overlapping intervals.

To ensure the maximum number of distinct elements, we should always assign:
> the smallest possible number that is still greater than the last assigned number  
> and lies within the current elementâ€™s interval.

This greedy strategy guarantees we leave as much â€œspaceâ€ as possible for upcoming elements.

---

## ğŸ§© Approach

1. **Sort the array** â€” so intervals are processed in ascending order.  
2. Initialize `lastAssigned = -âˆ`.  
3. For each number:
   - Compute its range â†’ `left = x - k`, `right = x + k`.  
   - Choose the smallest valid integer `candidate = max(lastAssigned + 1, left)`.  
   - If `candidate <= right`, assign it and increment the count.  
4. Return the count.

---

## ğŸ’» Code (TypeScript)

```ts
function maxDistinctElements(nums: number[], k: number): number {
  nums.sort((a, b) => a - b);
  let lastAssigned = -Infinity;
  let count = 0;

  for (const x of nums) {
    const left = x - k;
    const right = x + k;

    const candidate = Math.max(lastAssigned + 1, left);

    if (candidate <= right) {
      count++;
      lastAssigned = candidate;
    }
  }

  return count;
}
```

---

## â±ï¸ Complexity Analysis

**Time:** `O(n log n)` â€” sorting dominates.
**Space:** `O(1)` â€” in-place greedy.

---

## ğŸ§© Example Walkthrough

### Example 1:

```text
nums = [1, 1, 2]
k = 1
```

After sorting: `[1, 1, 2]`
Intervals â†’ `[0,2], [0,2], [1,3]`

| Interval |	Candidate |	Pick |	Count |
| -------- | ---------- | ---- | ------ |
| [0,2] |	max(-âˆ+1,0)=0 |	âœ… 0 |	1 |
| [0,2] |	max(0+1,0)=1 |	âœ… 1 |	2 |
| [1,3] |	max(1+1,1)=2 |	âœ… 2 |	3 |

**âœ… Answer = 3**

---

## ğŸ’¡ Takeaway

The trick is realising this problem is a maximum non-overlapping integer assignment â€”
A greedy + sorting combo perfectly fits since each interval is independent but ordered.

Once you think in terms of ranges, the problem almost solves itself.
If you didnâ€™t â€” welcome to the greedy enlightenment club. ğŸ˜

---
