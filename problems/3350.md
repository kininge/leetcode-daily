# üß© Problem #3350 ‚Äì Adjacent Increasing Subarrays Detection II

**Difficulty:** Medium  
**Topics:**  `Array`, `Binary Search`, `Greedy`, `Two Pointers`  
**Link:** [Leetcode](https://leetcode.com/problems/adjacent-increasing-subarrays-detection-ii)

---

## üéØ Problem Summary

Given an integer array `nums` of length `n`, find the **maximum possible value of `k`** such that there exist two **adjacent subarrays** of length `k` each, and **both** subarrays are strictly increasing.

That is, there exist indices `a` and `b` such that:

- `b = a + k`
- Both subarrays `nums[a..a+k-1]` and `nums[b..b+k-1]` are strictly increasing.

Return the **maximum `k`** that satisfies these conditions.

**Constraints:**
- `2 <= nums.length <= 2 * 10^5`
- `-10^9 <= nums[i] <= 10^9`

---

### üß© Example  

**Input:**  
```text
nums = [1,2,3,4,1,2,3,4]
```

**Output:**
```text
3
```

**Explanation:**   
Two adjacent increasing subarrays of length 3 exist:
`[1,2,3]` and `[4,1,2]` (indices 0‚Äì2 and 3‚Äì5).

---

## üß† Approach 1 ‚Äî Binary Search + Precomputed Increasing Lengths

### üí° Idea

1. Precompute `increasingSubArrayStore[i] = length` of the strictly increasing subarray ending at index `i`.
2. The maximum possible subarray length for any `k` is limited by the longest increasing run.
3. Use binary search to find the largest `k` such that:
  - There exists some `i` where `increasingSubArrayStore[i] >= k` and `increasingSubArrayStore[i+k] >= k`.

4. Each binary search step checks validity in `O(n)`, giving `O(n log n)` total time.

### ‚öôÔ∏è Complexity

**Time:** `O(n log n)`
**Space:** `O(n)`

```Typescript []
function maxIncreasingSubarrays(nums: number[]): number {
    const n: number = nums.length;
    let ans: number = 1; // at least 1 will be answer

    const increasingSubArrayStore: number[] = new Array(n).fill(1);
    let largestFrequencySubArray: number = 1;

    // O(n) - build increasing subarray length
    for(let i=1; i<n; i++) { 
        if(nums[i] > nums[i-1]) {
            increasingSubArrayStore[i] = increasingSubArrayStore[i-1]+1;;
            largestFrequencySubArray = Math.max(largestFrequencySubArray, increasingSubArrayStore[i]);
        }
    }

    // edge case
    if(largestFrequencySubArray === n) return n>>1;
    // edge case
    if(largestFrequencySubArray === 1) return 1;

    // O(n) - check possible adjacent subarray of size k
    function checkAdjesantSubarraysOfSizeK(k: number): boolean{
        let isPossible: boolean = false;

        for(let i=(k-1); i<(n-k); i++){
            const subarray1: boolean = increasingSubArrayStore[i]>=k;
            const subarray2: boolean = increasingSubArrayStore[i+k]>=k;
            if(subarray1 && subarray2){
                isPossible = true;
                break;
            }
        }

        return isPossible;
    }

    // O(nlogn) - binary search and find the largest possible k 
    let lowest: number = 1;
    let highest: number = largestFrequencySubArray;
    while(lowest <= highest){
        const mid: number = (lowest+highest) >> 1;

        if(checkAdjesantSubarraysOfSizeK(mid)){
            ans = mid; // mark as answer
            lowest = mid+1; // try for higher k
        } else{
            highest = mid-1;
        }
    }


    return ans;
};
```

---

## ‚ö° Approach 2 ‚Äî Greedy O(n) (with Precomputation)

### üí° Idea

1. Build store[i] = length of increasing subarray ending at i
2. While updating, for each run length L:
  - If `L >= 2*k`, then you can split that single run into two adjacent subarrays of length `L/2` ‚Üí `half`.
  - If there exists another run of the same length `L` exactly `L` indices before, then two full adjacent runs exist ‚Üí `full`.
3. The answer is `max(ans, max(half, full))`.

This method uses local run information instead of binary search.
It cleverly checks both scenarios in one pass.

### ‚öôÔ∏è Complexity

**Time:** `O(n)`
**Space:** `O(n)`

```Typescript []
function maxIncreasingSubarrays(nums: number[]): number {
    const n: number = nums.length;
    let ans: number = 1; // at least 1 will be answer
    if(n === 2) return ans;

    // increasing subarray length storage
    const store: number[] = new Array(n).fill(1);

    // O(n) - build increasing subarray length
    for(let i=1; i<n; i++) { 
        if(nums[i] > nums[i-1]) {
            const L : number = store[i-1]+1;
            store[i]  = L;

            // check L and L/2 for possible k
            if(L > 1){
                const half: number = L>>1; // floor division by 2
                let full = 0;
                const isPreviousIndexExist: boolean = (i-L)>=0;
                const isAdjesantArrayExist: boolean = store[i-L]>=L
                if(isPreviousIndexExist && isAdjesantArrayExist) full = L;

                const k: number = Math.max(half, full);
                ans = Math.max(ans, k);
            } 
        }
    }

    return ans;
};
```

---

## üöÄ Approach 3 ‚Äî Optimized Greedy (O(n), O(1) Space)

### üí° Idea

We don‚Äôt actually need to store all run lengths.
We just need:
  - `currentSubArrayLength`: length of the current increasing run.
  - `previousSubArrayLength`: length of the previous increasing run.
At each index:
  - If `nums[i] > nums[i-1]`, extend the current run.
  - Else, move current run ‚Üí previous, and reset current to 1.
  - The potential `k` comes from:
     - `Math.min(previous, current)` ‚Üí two separate runs side-by-side.
     - `Math.floor(current / 2)` ‚Üí two windows inside one long run.

Update ans as the max of these two at each step.

### ‚öôÔ∏è Complexity

**Time:** `O(n)`
**Space:** `O(1)`

```Typescript []
function maxIncreasingSubarrays(nums: number[]): number {
    const n:number = nums.length;
    if(n === 2) return 1;

    let ans:number = 1;
    let previousSubArrayLength:number = 1;
    let currentSubArrayLength:number = 1;

    for(let i=1; i<n; i++){
        if(nums[i] > nums[i-1]) currentSubArrayLength++;
        else{
            previousSubArrayLength = currentSubArrayLength;
            currentSubArrayLength = 1;
        }

        ans = Math.max(ans, Math.min(previousSubArrayLength, currentSubArrayLength)); // full length check
        ans = Math.max(ans, currentSubArrayLength>>1); // half length check
    }

    return ans;
};
```

---

## üî¨ Comparison Summary

| Approach |	Time |	Space |	Notes |
| --- |	--- |	--- |	--- |
| Binary Search |	O(n log n) |	O(n) |	Clear, brute-force check per k |
| Greedy (Store) |	O(n) |	O(n) |	Clever and intuitive |
| Greedy (Optimized) |	O(n) |	O(1) |	Simplest, fastest, cleanest |

---

## üß© Key Insights

1. Each increasing run holds information about how large a window we can form.
2. Two adjacent increasing subarrays can occur either:
  - Within one long run, or
  - Across a boundary between two runs.
3. The greedy solution captures both using just two counters.

---

## üèÅ Final Thoughts

- Approach 1 is conceptually simple and easy to prove.
- Approach 2 gives O(n) with explicit precomputation.
- Approach 3 is the cleanest and memory-optimal ‚Äî ideal for contests.
