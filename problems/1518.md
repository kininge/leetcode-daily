# üß© 1518. Water Bottles

**Difficulty**: Easy  
**Tags**: Simulation, Greedy, Math  
**Link**: [LeetCode](https://leetcode.com/problems/water-bottles/description/)  

---

## üìú Problem Summary
You have `numBottles` full water bottles.  
Whenever you drink a bottle, it becomes empty.  
You may exchange `numExchange` empty bottles for **one** full bottle.  

Return the maximum number of bottles you can drink in total.

Constraints:
- `1 <= numBottles <= 100`
- `2 <= numExchange <= 100`

---

## üí° Intuition
- Every time you drink a bottle, you create an empty one.  
- Collect empty bottles; once you reach `numExchange`, trade them for one new full bottle.  
- Repeat until no full bottles remain.  
- This is essentially simulating a "recycling loop."

---

## üß≠ Approach 1 ‚Äî Simulation
- Keep counters for:
  - `filledBottles`: bottles currently drinkable.  
  - `emptyBottles`: empties you‚Äôve collected.  
  - `totalDrinks`: how many you‚Äôve drunk.  
- While there‚Äôs at least one full bottle:
  1. Drink it ‚Üí increment `totalDrinks`, decrement `filledBottles`, increment `emptyBottles`.  
  2. If `emptyBottles === numExchange`, exchange them for one new full bottle and reset `emptyBottles`.  
- Loop ends when no full bottles are left to drink.  

### Example
Input: `numBottles = 9, numExchange = 3`

```plaintext
Drink 9 ‚Üí total=9, empties=9
Exchange 9 empties ‚Üí 3 full
Drink 3 ‚Üí total=12, empties=3
Exchange 3 empties ‚Üí 1 full
Drink 1 ‚Üí total=13, empties=1
No more exchanges ‚Üí stop
```

Answer = 13

### ‚úÖ Code

```typescript []
function numWaterBottles(numBottles: number, numExchange: number): number {
    let filledBottles: number = numBottles;
    let emptyBottles: number = 0;
    let totalDrinks: number = 0;

    while (filledBottles > 0) {
        // drink one bottle
        filledBottles--;
        totalDrinks++;
        emptyBottles++;

        // exchange empties if enough
        if (emptyBottles === numExchange) {
            filledBottles++;
            emptyBottles = 0;
        }
    }
    return totalDrinks;
}
```

### ‚è± Complexity

- **Time**: `O(totalDrinks)` ‚Äî but at most ~200 operations (since numBottles, numExchange ‚â§ 100), trivial.
- **Space**: `O(1)`. 

---

## üß≠ Approach 2 ‚Äî Math Formula (Greedy Counting)

- Instead of simulating:
  - You can always drink the initial numBottles.
  - Every numExchange empties gives 1 new drink.
  - This can be computed with:

  ```plaintext
  total = numBottles + Floor((numBottles-1)/(numExchange-1))
  ```

- This formula works because for every group of `numExchange-1` extra bottles (after the first), you get one more exchange.

### Example with formula
```plaintext
numBottles=9, numExchange=3:
9 + floor((9-1)/(3-1)) = 9 + floor(8/2) = 9 + 4 = 13 ‚úÖ
```

### ‚úÖ Code

```typescript []
function numWaterBottles(numBottles: number, numExchange: number): number {
    return numBottles + Math.floor((numBottles-1)/(numExchange-1));
}
```

### ‚è± Complexity

- **Time**: `O(1)`
- **Space**: `O(1)`. 

---

## üîë Key Takeaways

- Simulation is easiest and clearer for small constraints.
- With insight, you can reduce it to a direct formula.
- Always look for recycling/exchange problems ‚Üí they often hide a greedy or math shortcut.
