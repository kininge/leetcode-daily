# üß© Problem #2110 ‚Äì Number of Smooth Descent Periods of a Stock

**Difficulty:** Medium  
**Topics:** `Array`, `Math`    
**Link:** https://leetcode.com/problems/number-of-smooth-descent-periods-of-a-stock/

---

## üìù Problem Summary

You are given an integer array `prices`, where `prices[i]` represents the stock price on day `i`.

A **smooth descent period** is defined as a contiguous sequence of one or more days such that:

- For every consecutive pair of days in the period,  
  the price decreases by **exactly 1**:
  ```text
  prices[k] = prices[k-1] - 1
  ```
- The first day of a period is always valid by itself.

Your task is to return the **total number of smooth descent periods** in the entire price history.

### Constraints
- `1 ‚â§ prices.length ‚â§ 10^5`
- `1 ‚â§ prices[i] ‚â§ 10^5`

---

## üí° Intuition

A *smooth descent period* is a **contiguous run** where prices decrease by exactly `1` each day.

Example: 
```text
prices = [8, 7, 6, 5]
```

This forms a single valid run of length `4`.

Now here‚Äôs the key insight:

If a valid run has length `k`, then the number of smooth descent subperiods inside it is:
```text
1 + 2 + 3 + ... + k
```


Why?

- Length 1 subarrays: k
- Length 2 subarrays: k-1
- Length 3 subarrays: k-2
- ...
- Length k subarray: 1

Total:
```text
k + (k-1) + ... + 1 = k(k+1)/2
```


This value is called a **Triangular Number**.

---

## üõ† Approach

We iterate through the price array once while tracking the length of the current smooth descent run.

- Let `count` be the length of the current valid descent streak ending at index `i`.
- If the descent condition breaks, reset `count` to `1`.
- At each index, add `count` to the answer.

This works because `count` represents the number of smooth descent subarrays that **end at the current index**.

---

## üßæ Code (TypeScript)

```ts
function getDescentPeriods(prices: number[]): number {
    const n = prices.length;

    let smoothDescent = 0;
    let count = 0;

    for (let i = 0; i < n; i++) {
        // Start a new descent period if condition breaks
        if (i === 0 || prices[i - 1] !== prices[i] + 1) {
            count = 1;
        } else {
            count++;
        }

        // Each index contributes `count` new descent periods
        smoothDescent += count;
    }

    return smoothDescent;
}
```

### üìä Complexity Analysis

- **Time Complexity:** O(n)
  - Single pass through the array
- **Space Complexity:** O(1)
  - Only constant extra variables are used

---

## What code is doing (implicitly)

Instead of explicitly computing `k(k+1)/2` for each run, your code:

- Keeps a running `count` of the current descent length
- Adds that `count` to the answer at each step

This is equivalent to incrementally summing:
```text
1, 2, 3, ..., k
```


So your loop is *implicitly computing triangular numbers on the fly*.

---

## Mathematical classification

This pattern belongs to:

- **Triangular Numbers**
- Derived from an **Arithmetic Progression (AP)** with:
  - first term `a = 1`
  - common difference `d = 1`

Important distinction:
- **AP** ‚Üí the sequence itself: `1, 2, 3, 4, ...`
- **Triangular Numbers** ‚Üí the *sum* of the first `n` terms of that AP

So:
```text
Triangular(n) = 1 + 2 + ... + n = n(n+1)/2
```

---

## Final takeaway

- ‚ùå This is NOT a generic ‚Äúcombinatorics‚Äù problem
- ‚úÖ This is **run-length counting + triangular numbers**
- ‚úÖ Your solution is optimal: O(n) time, O(1) space
- ‚úÖ Interviewers love this pattern because it shows:
  - recognition of monotonic runs
  - implicit use of mathematical series without overcomplicating

In short:  
We‚Äôre applying **Triangular Number accumulation over valid monotonic segments** ‚Äî clean, elegant, and exactly what this problem wants.

---


