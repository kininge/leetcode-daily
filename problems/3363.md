# üß© Problem #3363 - Find the Maximum Number of Fruits Collected

**Difficulty:** Hard  
**Topics:**  `Matrix`, `Depth First Search`, `Dynamic Programming`  
**Link:** [Leetcode](https://leetcode.com/problems/find-the-maximum-number-of-fruits-collected/description/)

## üß† Intuition

Each of the 3 children moves in a very restricted path:

- üë∂ **Diagonal child** moves from (0, 0) to (n - 1, n - 1) ‚Äî only collects **diagonal fruits**.  
  ![Diagonal](https://assets.leetcode.com/users/images/3a0d2c2c-2deb-42f1-87a3-0a936b9c896e_1754566397.5500274.png)

- üë∂ **Upper triangle child** moves from (0, n - 1) to (n - 1, n - 1) ‚Äî constrained to i < j region.  
  ![Upper triangle](https://assets.leetcode.com/users/images/a38037d9-de3f-4624-8a3b-a42b0717b189_1754566462.1343813.png)

- üë∂ **Lower triangle child** moves from (n - 1, 0) to (n - 1, n - 1) ‚Äî constrained to i > j region.  
  ![Lower triangle](https://assets.leetcode.com/users/images/245b714a-af0e-43d4-89a6-97222d1b2e59_1754566481.512133.png)

Since the path length is always n-1, this boils down to a **bounded DFS with memoization**, very similar to grid-based DP problems like "Dungeon Game".

---

## üöÄ Approach

1. üçì Collect all diagonal fruits directly.
2. üí° For each of the other two kids:
   - Use **DFS + memoization** to explore all valid paths.
   - Enforce region constraints (i < j for upper, i > j for lower).
   - Only move if inside allowed triangle and within bounds.

> Use different direction vectors and triangle checks per child.

---

## ‚è±Ô∏è Complexity

- **Time:** O(N^2)  
  Each DFS explores up to N^2 states (two times).

- **Space:** O(N^2)  
  Two memoization tables of size N x N.

---

## üßæ Code (JavaScript)

```javascript []
var maxCollectedFruits = function(fruits) {
    const n = fruits.length;

    let totalFruitsCollection = 0;

    // Step 1: Collect diagonal fruits
    for (let i = 0; i < n; i++) totalFruitsCollection += fruits[i][i];

    function DFS(cell, targetCell, directions, isBelowDiagonal, steps, DP) {
        const [x, y] = cell;

        if (x === targetCell[0] && y === targetCell[1])
            return fruits[x][y];

        if (steps < 1) return -1e6;

        if (DP[x][y] !== null) return DP[x][y];

        let maxFruits = 0;

        for (const [dx, dy] of directions) {
            const i = x + dx;
            const j = y + dy;

            const isOutOfBound = i < 0 || i >= n || j < 0 || j >= n;
            const isOutOfRegion = (isBelowDiagonal && i <= j) || (!isBelowDiagonal && i >= j);

            if (!isOutOfBound && !isOutOfRegion) {
                const fruitsCollected = fruits[x][y] + DFS([i, j], targetCell, directions, isBelowDiagonal, steps - 1, DP);
                maxFruits = Math.max(maxFruits, fruitsCollected);
            }
        }

        DP[x][y] = maxFruits;
        return maxFruits;
    }

    // Step 2a: Upper triangle DFS
    const DP = Array.from({ length: n }, () => Array(n).fill(null));
    let directions = [[1, -1], [1, 0], [1, 1]];
    totalFruitsCollection += DFS([0, n - 1], [n - 2, n - 1], directions, false, n - 2, DP);

    // Step 2b: Lower triangle DFS
    directions = [[-1, 1], [0, 1], [1, 1]];
    totalFruitsCollection += DFS([n - 1, 0], [n - 1, n - 2], directions, true, n - 2, DP);

    return totalFruitsCollection;
};
```

---

## üßä Tip

This is a geometry-aware DFS ‚Äî always define strict region rules and terminate early with bounds. Perfect blend of graph traversal and grid logic.
