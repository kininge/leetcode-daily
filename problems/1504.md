
# ðŸ§© Problem #1504 â€“ Count Submatrices With All Ones

**Difficulty:** Medium  
**Topics:**  `Matrix`, `Dynamic Programming`, `Stack`, `Prefix Sum`  
**Link:** [Leetcode](https://leetcode.com/problems/count-submatrices-with-all-ones)

---

## ðŸŽ¯ Problem Summary  

Given an `m Ã— n` binary matrix `mat`, return the **number of submatrices that contain only ones**.

**Constraints**  

- `1 <= m, n <= 150`  
- `mat[i][j]` is either `0` or `1`.

---

## ðŸ§  Key Observation  

1. If you look at the matrix **column-wise**, each column can be viewed as a **histogram of consecutive 1s** stacked vertically.  
2. For every cell `(i, j)` that contains `1`, you can count **how many rectangles end at that cell** by extending leftwards while maintaining the **minimum height** among bars in that row.  
3. Sum all such rectangle counts to get the total number of all-ones submatrices.

---

## ðŸ§© Approach â€” Histogram + Minimum Height Trick  

### ðŸ’¡ Steps

1. **Vertical accumulation:**  
   For each column, build â€œheight barsâ€ showing consecutive `1`s up to that row.  
   If `mat[i][j] = 1`, then `mat[i][j] += mat[i-1][j]`; else reset to 0.

2. **Row-wise counting:**  
   For each row `i`, iterate across columns.  
   For each column `j` where `mat[i][j] > 0`:
   - Move left from `j` â†’ `0` while maintaining `minHeight = min(minHeight, mat[i][x])`.
   - Add `minHeight` to the total (each represents rectangles ending at `(i, j)`).

---

## âœ… Your Implementation  

```js
var numSubmat = function(mat) {
    // Step 1: build bar graph vertically
    for(let j=0; j<mat[0].length; j++){
        let count = 0;
        for(let i=0; i<mat.length; i++){
            if(mat[i][j] !== 0) count++;
            else count = 0;
            mat[i][j] = count;
        }
    }

    // Step 2: count rectangles row-wise
    let totalRectangles = 0;
    for(let i=0; i<mat.length; i++){
        for(let j=0; j<mat[0].length; j++){
            if(mat[i][j] > 0){
                let minHeight = 150;
                for(let x=j; x>=0; x--){
                    if(mat[i][x] > 0){
                        minHeight = Math.min(minHeight, mat[i][x]);
                        totalRectangles += minHeight;
                    } else break;
                }
            }
        }
    }

    return totalRectangles;
};
```

---

## âš™ï¸ Complexity Analysis

| Type | Complexity |
| --- | --- |
| Time | `O(m Ã— nÂ²)` â€“ each cell looks left up to n |
| Space | `O(1)` â€“ in-place reuse of mat |

## ðŸ§© Why It Works

- Each cell `(i, j)` acts as the bottom-right corner of all rectangles of ones ending there.
- While extending left, the minimum column height limits how tall a rectangle can extend â€” the count of - rectangles grows cumulatively with each left step.

## ðŸ Final Thoughts

- Beautiful combination of DP + histogram counting.
- This pattern reappears in problems like â€œLargest Rectangle in Histogramâ€ and â€œMaximal Rectangleâ€.
- For tighter constraints, this in-place solution is clean and easy to reason about.

> ðŸ’¬ "Sometimes brute intuition beats fancy data structures â€” just stack, count, and conquer!" ðŸ˜Ž