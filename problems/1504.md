
# 🧩 Problem #1504 – Count Submatrices With All Ones

**Difficulty:** Medium  
**Topics:**  `Matrix`, `Dynamic Programming`, `Stack`, `Prefix Sum`  
**Link:** [Leetcode](https://leetcode.com/problems/count-submatrices-with-all-ones)

---

## 🎯 Problem Summary  

Given an `m × n` binary matrix `mat`, return the **number of submatrices that contain only ones**.

**Constraints**  

- `1 <= m, n <= 150`  
- `mat[i][j]` is either `0` or `1`.

---

## 🧠 Key Observation  

1. If you look at the matrix **column-wise**, each column can be viewed as a **histogram of consecutive 1s** stacked vertically.  
2. For every cell `(i, j)` that contains `1`, you can count **how many rectangles end at that cell** by extending leftwards while maintaining the **minimum height** among bars in that row.  
3. Sum all such rectangle counts to get the total number of all-ones submatrices.

---

## 🧩 Approach — Histogram + Minimum Height Trick  

### 💡 Steps

1. **Vertical accumulation:**  
   For each column, build “height bars” showing consecutive `1`s up to that row.  
   If `mat[i][j] = 1`, then `mat[i][j] += mat[i-1][j]`; else reset to 0.

2. **Row-wise counting:**  
   For each row `i`, iterate across columns.  
   For each column `j` where `mat[i][j] > 0`:
   - Move left from `j` → `0` while maintaining `minHeight = min(minHeight, mat[i][x])`.
   - Add `minHeight` to the total (each represents rectangles ending at `(i, j)`).

---

## ✅ Your Implementation  

```js
var numSubmat = function(mat) {
    // Step 1: build bar graph vertically
    for(let j=0; j<mat[0].length; j++){
        let count = 0;
        for(let i=0; i<mat.length; i++){
            if(mat[i][j] !== 0) count++;
            else count = 0;
            mat[i][j] = count;
        }
    }

    // Step 2: count rectangles row-wise
    let totalRectangles = 0;
    for(let i=0; i<mat.length; i++){
        for(let j=0; j<mat[0].length; j++){
            if(mat[i][j] > 0){
                let minHeight = 150;
                for(let x=j; x>=0; x--){
                    if(mat[i][x] > 0){
                        minHeight = Math.min(minHeight, mat[i][x]);
                        totalRectangles += minHeight;
                    } else break;
                }
            }
        }
    }

    return totalRectangles;
};
```

---

## ⚙️ Complexity Analysis

| Type | Complexity |
| --- | --- |
| Time | `O(m × n²)` – each cell looks left up to n |
| Space | `O(1)` – in-place reuse of mat |

## 🧩 Why It Works

- Each cell `(i, j)` acts as the bottom-right corner of all rectangles of ones ending there.
- While extending left, the minimum column height limits how tall a rectangle can extend — the count of - rectangles grows cumulatively with each left step.

## 🏁 Final Thoughts

- Beautiful combination of DP + histogram counting.
- This pattern reappears in problems like “Largest Rectangle in Histogram” and “Maximal Rectangle”.
- For tighter constraints, this in-place solution is clean and easy to reason about.

> 💬 "Sometimes brute intuition beats fancy data structures — just stack, count, and conquer!" 😎