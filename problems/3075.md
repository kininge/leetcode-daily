# ðŸ§© Problem #3075 â€“ Maximize Happiness of Selected Children

**Difficulty:** Medium  
**Topics:** `Greedy`, `Sorting`    
**Link:** https://leetcode.com/problems/maximize-happiness-of-selected-children/

---

## ðŸ“ Problem Summary

You are given an array `happiness` of length `n`, where `happiness[i]` represents the initial happiness of the `i`-th child.

You must select exactly `k` children in `k` turns.

Rules:
- In each turn, you select **one child**.
- After selecting a child, the happiness of **all unselected children decreases by 1**.
- Happiness values **never go below 0**.

Your goal is to **maximize the total happiness sum** of the selected `k` children.

### Constraints
- 1 â‰¤ n â‰¤ 2 Ã— 10âµ
- 1 â‰¤ happiness[i] â‰¤ 10â¸
- 1 â‰¤ k â‰¤ n

---

## ðŸ’¡ Intuition

We want to select `k` children one by one to maximize total happiness.

Key observation:

- Each time we select a child, **all remaining unselected children lose 1 happiness**.
- If a child is selected in the `i`-th turn (0-indexed), its effective happiness becomes: `max(happiness[i] - i, 0)`

So the problem reduces to:

> Choose `k` children such that  
> `Î£ max(happiness[selected_i] - i, 0)` is maximized.

---

### Greedy Insight

- Always select the **currently happiest** child first.
- Sorting happiness in **descending order** ensures:
  - The child with the highest original happiness is picked earlier,
  - Minimizing the penalty (`-i`) applied to large values.

Thus:
1. Sort `happiness` in decreasing order.
2. Pick the first `k` elements.
3. For the `i`-th selected child, add `max(happiness[i] - i, 0)` to the answer.

This greedy strategy is optimal because:
- Delaying a high happiness child only reduces its contribution,
- Picking smaller happiness earlier never helps.

---

## ðŸ›  Approach

This is a **greedy + sorting** problem.

### Key observations

- Each time you select a child, the happiness of all **remaining unselected** children decreases by `1`.
- If you select children in some order, the child picked at turn `i` (0-indexed) effectively contributes: `max(happiness_value âˆ’ i, 0)`
- To **maximize total happiness**, you should:
- Select children with **higher initial happiness first**, so they are penalized less by future decrements.

### Strategy

1. Sort the `happiness` array in **descending order**.
2. Pick the first `k` children.
3. For the `i`-th picked child, add: `max(happiness[i] âˆ’ i, 0)`
4. Stop once `k` children are selected.

This greedy choice is optimal because delaying a higher happiness child only causes unnecessary loss.

### ðŸ§¾ Code (Greedy + Sorting)

```ts
function maximumHappinessSum(happiness: number[], k: number): number {
    // Sort happiness in descending order
    happiness.sort((a, b) => b - a);

    let total = 0;

    // Each time we pick a child, remaining children lose 1 happiness
    // So the i-th picked child effectively contributes:
    // max(happiness[i] - i, 0)
    for (let i = 0; i < k; i++) {
        total += Math.max(happiness[i] - i, 0);
    }

    return total;
}
```

### â±ï¸ Complexity Analysis

Let `n = happiness.length`.

#### Time Complexity

- Sorting the `happiness` array in descending order takes: `O(n log n)`
- Iterating over the first `k` elements to compute the answer takes: `O(k)`


So overall time complexity is: `O(n log n)`


This is optimal for this problem since sorting is required to always pick the best remaining child.

---

#### Space Complexity

- Sorting is done in-place.
- Only a few variables are used for accumulation.

So space complexity is: `O(1) (ignoring input storage)`

---

#### Why this solution is optimal

- Any solution must consider the relative order of happiness values â†’ sorting is unavoidable.
- The greedy choice of selecting the highest remaining happiness each turn is provably optimal.
- Avoids simulation of decrementing all remaining children explicitly, which would be too slow.

This solution comfortably handles the upper constraints (`n â‰¤ 2 * 10^5`).

---


