# üß© Problem #2872 ‚Äì Maximum Number of K Divisible Components

**Difficulty:** Hard  
**Topics:** Tree, Graph, Greedy, Breadth Frist Search  
**Link:** https://leetcode.com/problems/maximum-number-of-k-divisible-components/

---

## üìù Problem Summary

You are given:

- A tree of `n` nodes (0 to n-1)
- An array `values[i]` assigned to each node
- An integer `k`

A *valid split* is created by removing any set of edges so that **every resulting connected component** has:
```text
sum of its node values) % k == 0
```

You must return the **maximum number of such components** you can create.

### Constraints

- `1 <= n <= 3 * 10^4`
- Tree has `n - 1` edges
- Values are `0 <= values[i] <= 1e9`
- `1 <= k <= 1e9`
- Total sum of all nodes is guaranteed to be divisible by `k`

---

## üí° Intuition

This is not about cutting edges randomly.  
We need to form *as many* components as possible where:
```text
component_sum % k == 0
```

### üîç Insight

Work from the **leaves inward**.

Why?

Because if you look at any leaf node:

- If its value % k == 0  
  ‚Üí it can be its *own* component.  
  ‚Üí we "cut" it off (count +1).

- Else  
  ‚Üí it must join its parent component,  
    So we pass its value to its parent:  
    `values[parent] += values[leaf]`.

This reduces the problem from bottom ‚Üí up, like peeling an onion.

Eventually:

- Every time a subtree sum becomes divisible by `k`, we cut it.
- Whatever remains at the very end (root side) must also be divisible by `k`  
  (because the total sum is divisible by k).

### üå± Why onion-peeling works

Because the graph is a **tree**, removing leaves one-by-one:

- never revisits nodes  
- always exposes new leaves  
- ensures each subtree is handled exactly once  
- maintains the correctness of accumulated sums

This gives a clean **O(n)** solution.

---

## üçÉ Approach ‚Äî Leaf Peeling (Onion Sort)

### Main ideas

1. Build an adjacency list and track the degree (`dependancy[]`) of each node.
2. Initialize a queue with all **leaf nodes** (degree == 1).
3. Repeatedly remove leaves:
   - If leaf‚Äôs accumulated value % k == 0  
     ‚Üí this is an independent component ‚Üí count++
   - Else  
     ‚Üí add its value to its only unprocessed neighbour.
4. Reduce the neighbour‚Äôs degree; if it becomes a leaf, push it into the  queue.
5. Continue until all nodes are processed.

Since each edge and node is visited only once, the runtime is O(n).

### Key Detail

We always treat a node **when it becomes a leaf** in the shrinking tree, not in the original tree.

This ensures:

- Each component sum is final before checking `% k`.
- No double-counting.
- No backtracking needed.

---

## üé® Visual Diagram ‚Äî Why Leaf Peeling Works

Consider a simple tree:

```text
    (A)
   /   \
  (B)  (C)
      /  \
    (D)  (E)
```


Suppose values:

A=3, B=4, C=2, D=1, E=3,  and k = 3.

### Step-by-step peeling

1. Leaves = {B, D, E}
2. Check B:
   - 4 % 3 = 1 ‚Üí pass value to A ‚Üí A becomes 4
3. Check D:
   - 1 % 3 = 1 ‚Üí pass to C ‚Üí C becomes 3
4. Check E:
   - 3 % 3 = 0 ‚Üí componentCount++
5. Now C becomes a leaf (deg=1)
   - C=3 ‚Üí divisible ‚Üí cut ‚Üí componentCount++
6. Now A becomes a leaf
   - A=4 ‚Üí 4%3=1 ‚Üí pass (no neighbour left)
   - Final sum must be divisible by k ‚Üí root side is 0 ‚Üí componentCount++

### Final result
3 components

---

## üßæ Code (TypeScript)

```ts
function maxKDivisibleComponents(n: number, edges: number[][], values: number[], k: number): number {
    if (n === 1) return 1;

    const dependancy = new Array(n).fill(0);
    const graph = new Map<number, number[]>();

    // Build graph and degree counts
    for (const [u, v] of edges) {
        dependancy[u]++;
        dependancy[v]++;

        if (!graph.has(u)) graph.set(u, []);
        if (!graph.has(v)) graph.set(v, []);

        graph.get(u)!.push(v);
        graph.get(v)!.push(u);
    }

    // Start with all leaves
    const queue: number[] = [];
    for (let i = 0; i < n; i++) {
        if (dependancy[i] === 1) {
            queue.push(i);
        }
    }

    let index = 0;
    let componentCount = 0;

    // Onion peel
    while (index < queue.length) {
        const node = queue[index++];
        dependancy[node] = 0; // mark processed

        let carryValue = 0;

        if (values[node] % k === 0) {
            componentCount++;
        } else {
            carryValue = values[node];
        }

        if (graph.has(node)) {
            for (const nei of graph.get(node)!) {
                if (dependancy[nei] > 0) { // still in tree
                    dependancy[nei]--;
                    values[nei] += carryValue;

                    if (dependancy[nei] === 1) {
                        queue.push(nei);
                    }
                }
            }
        }
    }

    return componentCount;
}
```

---

## ‚è±Ô∏è Complexity

- **Time:** `O(n)`  
  Each node becomes a leaf once, each edge processed twice.

- **Space:** `O(n)`  
  Graph + queue + bookkeeping arrays.

This meets constraints comfortably for `n = 3 * 10^4`.

---




