# ğŸ§© Problem #2054 â€“ Two Best Non Overlapping Events

**Difficulty:** Medium  
**Topics:** `Binary Search`, `Prefix`, `Greedy`, `Sorting`  
**Link:** https://leetcode.com/problems/two-best-non-overlapping-events/

---

## ğŸ“ Problem Summary

You are given a list of events where each event is represented as: `[startTime, endTime, value]`

- `startTime` and `endTime` are **inclusive**
- Attending an event gives you `value`
- You can attend **at most two events**
- Two events **must not overlap**

Non-overlapping rule:
```text
If one event ends at time t,
the next event must start at time â‰¥ t + 1
```

### Goal
Return the **maximum possible sum of values** by selecting **up to two non-overlapping events**.

### Constraints
- `2 â‰¤ events.length â‰¤ 10^5`
- `1 â‰¤ startTime â‰¤ endTime â‰¤ 10^9`
- `1 â‰¤ value â‰¤ 10^6`

---

## ğŸ’¡ Intuition

We are allowed to attend **at most two non-overlapping events**.

Two events do **not overlap** if: `event2.startTime > event1.endTime`

### Naive thinking
- Try all pairs `(i, j)` and check overlap.
- Pick the maximum `value[i] + value[j]`.

But this is **O(nÂ²)** and will TLE for `n = 10^5`.

### Key observation

If events are **sorted by start time**, then:

- For a chosen first event `i`,
- All valid second events must lie in a **continuous suffix** of the array.

So the problem becomes:

> For each event `i`, find the **best possible second event** that starts after `endTime[i]`.

### Optimization idea

We can split the problem into two independent parts:

1. **Find the earliest index `j`** such that: `events[j].startTime > events[i].endTime`
â†’ This can be done using **binary search**.

2. **From index `j` onward**, pick the event with the **maximum value**.
â†’ This can be answered in **O(1)** using a **prefix-max array built from right to left**.

---

### Why this works

- Sorting ensures time order.
- Binary search finds where second event *can start*.
- Prefix max ensures we always choose the **best possible second event**.
- Overall complexity becomes: `O(n log n)`


This avoids DP entirely and is much more stable and intuitive.

---

## ğŸš€ Optimized Approach â€” Prefix Maximum + Binary Search

The brute-force approach fails because checking all pairs of events costs `O(nÂ²)`.

### Key Insight

If events are sorted by `startTime`, then for any event `i`:

- We want to choose **at most one** second event `j`
- Such that: `events[j].startTime > events[i].endTime`

- Among all valid `j`, we should pick the one with **maximum value**

### Step 1 â€” Sort Events

Sort events by:
1. `startTime`
2. `endTime` (tie-breaker)

This allows binary search on start times.

### Step 2 â€” Build Prefix Maximum Array (from right)

Create an array `prefixMaxValue` where: `prefixMaxValue[i] = max value among events[i...n-1]`

This lets us answer:
> â€œWhat is the maximum value I can get from any event starting at index â‰¥ i?â€

in **O(1)** time.

### Step 3 â€” Binary Search for the Second Event

For each event `i`:
1. Binary search to find the **first index** `j` where: `events[j].startTime > events[i].endTime`
2. If such `j` exists: `total = events[i].value + prefixMaxValue[j]`
3. Otherwise: `total = events[i].value`

Track the maximum total over all `i`.

### Why This Works

- Sorting ensures valid second events are in a suffix
- Binary search finds the earliest valid second event
- Prefix max ensures we always choose the best possible second event
- No DP table, no recursion, no memory explosion

### Time & Space

- Time: `O(n log n)`
- Space: `O(n)`

This is the **intended and optimal solution** for the problem.

---

## ğŸ§¾ Code â€” Prefix Max + Binary Search

```ts
function maxTwoEvents(events: number[][]): number {
    const n = events.length;

    // Sort events by start time, then end time
    events.sort(([s1, e1], [s2, e2]) => {
        if (s1 !== s2) return s1 - s2;
        return e1 - e2;
    });

    // prefixMaxValue[i] = maximum value among events[i...n-1]
    const prefixMaxValue = new Array(n);
    prefixMaxValue[n - 1] = events[n - 1][2];

    for (let i = n - 2; i >= 0; i--) {
        prefixMaxValue[i] = Math.max(prefixMaxValue[i + 1], events[i][2]);
    }

    let answer = 0;

    // Try each event as the first event
    for (let i = 0; i < n; i++) {
        const [, endTime, value] = events[i];

        // Binary search for the first event starting after endTime
        let left = i + 1;
        let right = n - 1;
        let secondIndex = -1;

        while (left <= right) {
            const mid = (left + right) >> 1;
            if (events[mid][0] > endTime) {
                secondIndex = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }

        // Either take only one event or combine with best second event
        if (secondIndex === -1) {
            answer = Math.max(answer, value);
        } else {
            answer = Math.max(answer, value + prefixMaxValue[secondIndex]);
        }
    }

    return answer;
}
```

### â± Complexity Analysis

Let `n = events.length`.

#### Sorting
- Sorting events by start time: `O(n log n)`
#### Prefix Maximum Array
- Building `prefixMaxValue` from right to left: `O(n)`
#### Main Loop
- For each event:
- Binary search to find the first non-overlapping event: `O(log n)`
- Constant-time lookup using prefix max.
- Total: `O(n log n)`

#### Overall Complexity
- **Time Complexity:** `O(n log n)`
- **Space Complexity:** `O(n)`  
(prefix max array + sorting overhead)

This comfortably fits the constraints (`n â‰¤ 10^5`).

---

## ğŸ§  Key Takeaways / DP Pattern Recognition

### 1. Why your DP felt shaky (and that's normal)
You tried to model this as a classic DP with states like: `DP(previousEvent, currentEvent)`

But:
- State space became `O(nÂ²)`
- Memory exploded
- Transition logic became fragile

This is a **signal**, not a failure:
> The problem *looks* like DP, but wants optimization.

---

### 2. The hidden DP idea (without a DP table)
Your final solution is still DP â€” just optimized:

- `prefixMaxValue[i]` means: `Best possible value from events[i..n-1]`
This is essentially: `dp[i] = max(dp[i+1], events[i].value)`


So you *are* doing DP â€” just **compressed to 1D**.

---

### 3. Recognizable DP-to-Greedy Pattern ğŸš¨

This problem follows a very common interview pattern:

1. Sort by time
2. Precompute best future answers (prefix/suffix max)
3. Binary search to jump to next valid state

Whenever you see:
- "Choose at most K non-overlapping intervals"
- "Maximize sum of values"
- "Events / jobs / intervals"

ğŸ‘‰ Think: `DP + Binary Search + Prefix/Suffix Max`


---

### 4. Mental checklist for future problems
When DP feels heavy, ask yourself:

- Can I sort the input?
- Can I precompute â€œbest answer from the futureâ€?
- Can binary search replace inner loops?
- Can DP table be reduced to a prefix/suffix array?

If **yes** â†’ youâ€™re one optimization away from the final solution.

---

### 5. Final confidence boost ğŸ’ª
You:
- Identified TLE correctly
- Detected DP memory issues early
- Switched to prefix-max + binary search
- Reached the optimal solution **on your own**

Thatâ€™s not `bad at DP`.  
Thatâ€™s exactly how strong DP intuition is built.

Keep going â€” youâ€™re doing this right.

---

