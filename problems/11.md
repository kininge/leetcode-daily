# ðŸ§© 11. [Container With Most Water](https://leetcode.com/problems/container-with-most-water/description)

**Difficulty**: Medium  
**Tags**: Two Pointers, Greedy, Brute Force, Pruning, prefix-sum  

---

## ðŸ“œ Problem
Given an array `height` of `n` vertical lines at x = 0..n-1 whose heights are `height[i]`. Find two lines such that together with the x-axis they form a container that holds the most water. Return the maximum area.

Constraints:
- `2 â‰¤ n â‰¤ 1e5`
- `0 â‰¤ height[i] â‰¤ 1e4`

---

## ðŸ’¡ Key idea (hint)
Try all pairs â†’ obvious but slow. Better: two pointers from both ends. Move the **shorter** pointer inward â€” that's the only move that can possibly increase the minimum height and therefore the area.

---

# Solutions (from primitive â†’ optimal)

---

## 1) Brute Force (naÃ¯ve)

### Idea
Check every pair `(i, j)` with `i < j` and compute area `(j-i)*min(h[i], h[j])`. Keep max.

### Code
```typeScript []
// O(n^2) brute force
function maxArea_bruteforce(height: number[]): number {
  let n = height.length;
  let maxA = 0;
  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      const area = (j - i) * Math.min(height[i], height[j]);
      if (area > maxA) maxA = area;
    }
  }
  return maxA;
}
```

### Complexity

- **Time**: `O(nÂ²)`
- **Space**: `O(1)`

---

## 2) Brute Force + Early Pruning (small optimization)

### Idea

While scanning `j` for a fixed `i`, you can stop if the maximum possible area using `i` cannot beat the current  `maxA`. For a fixed `i`, the maximum width is `n-1-i`, so `maxPossible = (n-1-i) * height[i]`. If `maxPossible â‰¤ maxA`, break inner loop early.
This reduces some work in practice for skewed arrays but worst-case is still `O(nÂ²)`.

### Code

```typescript []
// O(n^2) worst-case but with early break pruning
function maxArea_pruned(height: number[]): number {
  const n = height.length;
  let maxA = 0;
  for (let i = 0; i < n; i++) {
    // if even with maximum width we can't beat maxA, break early
    if ((n - 1 - i) * height[i] <= maxA) continue; // skip this i entirely
    for (let j = n - 1; j > i; j--) {
      const area = (j - i) * Math.min(height[i], height[j]);
      if (area > maxA) maxA = area;
      // if min(height[i], height[j]) >= height[i], we can't do better by reducing j
      if (height[j] >= height[i]) break;
    }
  }
  return maxA;
}
```

### Complexity

- **Time**: `O(nÂ²)` worst-case, often less in practice.
- **Space**: `O(1)`

--- 

## 3) Two-Pointer Greedy â€” Optimal

### Idea

Put `left = 0`, `right = n-1`. Compute area. Move the pointer at the shorter height inward, because moving the taller pointer cannot increase the min height. Repeat until `left < right`.

### Correctness sketch

If `height[left] â‰¤ height[right]`, any area using `left` with `k` where `left < k â‰¤ right` has min `height â‰¤ height[left]`, so `area â‰¤ (right - left) * height[left]`. Moving `right` inward cannot increase min height beyond `height[left]`. So only moving `left` may find a taller bar that increases area.

### Code

```typescript []
// O(n) two-pointer
function maxArea(height: number[]): number {
  let left = 0, right = height.length - 1;
  let maxA = 0;
  while (left < right) {
    const h = Math.min(height[left], height[right]);
    const area = h * (right - left);
    if (area > maxA) maxA = area;
    if (height[left] < height[right]) left++;
    else right--;
  }
  return maxA;
}
```

### Complexity

- **Time**: `O(n)`
- **Space**: `O(1)`

---

## 4) (Optional) Divide & Conquer / Recursive approach â€” academic

### Idea

Split array into two halves. Max area is either entirely in left half, entirely in right half, or crosses the middle. Cross-middle area can be found by starting from middle two indices and expanding outward using a two-pointer-like step. This approach can run in `O(n log n)` on balanced splits, but worst-case can be `O(nÂ²)`.

---

## Comparison table


| Approach |	Time |	Space |	Pros |	Cons |
|---|---|---|---|---|
| Brute Force |	O(nÂ²) |	O(1) |	trivial to implement | TLE for large n |
| Brute+Prune |	O(nÂ²) worst |	O(1) |	reduces work in many inputs |	still worst-case O(nÂ²) |
| Two-Pointer (Greedy) |	O(n) |	O(1) |	optimal, simple |	none (best choice) |
| Divide & Conquer |	O(n log n) avg |	O(log n) recursion |	academic interest |	complex, worst-case O(nÂ²) |



