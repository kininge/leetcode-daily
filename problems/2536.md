# ğŸ§© Problem #2536 â€“ Increment Submatrices by One

**Difficulty:** Medium  
**Topics:** `Matrix`, `Prefix Sum`
**Link:** [Leetcode](https://leetcode.com/problems/increment-submatrices-by-one/)

---

## ğŸ“ Problem Summary

You start with an `n x n` zero matrix.  
Each query `[r1, c1, r2, c2]` means:

Increment every cell `(x, y)` such that  
`r1 â‰¤ x â‰¤ r2` and `c1 â‰¤ y â‰¤ c2`.

Return the final matrix.

---

## ğŸ’¡ Intuition

Instead of incrementing every cell in the submatrix for each query, mark only the borders using a difference-array approach so prefix sums can rebuild the final matrix efficiently.

Your method already uses a row-wise difference idea.  
The optimal approach extends it to a **2D difference grid**.

---

## ğŸƒ Approach 1 â€” Your Method (Row-wise Difference Array)

### âœ”ï¸ Idea  
For each query, update the start and end columns of every affected row:

- `matrix[i][b] += 1`
- `matrix[i][d+1] -= 1`

Then apply prefix sums across each row.

### â±ï¸ Complexity
- Worst-case update: `O(q * (r2 - r1 + 1))`
- Final build: `O(nÂ²)`
- Total is still performant for constraints.

### âœ… Code (TypeScript)
```ts
function rangeAddQueries(n: number, queries: number[][]): number[][] {
    const matrix: number[][] = [];
    for (let i = 0; i < n; i++) matrix.push(new Array(n).fill(0));

    for (const [a, b, c, d] of queries) {
        for (let i = a; i <= c; i++) {
            matrix[i][b] += 1;
            if (d < n - 1) matrix[i][d + 1] -= 1;
        }
    }

    for (let i = 0; i < n; i++) {
        let count = 0;
        for (let j = 0; j < n; j++) {
            count += matrix[i][j];
            matrix[i][j] = count;
        }
    }

    return matrix;
}
```

---

## ğŸ€ Approach 2 â€” Optimal Method (2D Difference Array)

### âœ”ï¸ Idea  
Mark the rectangle with four corner updates:

- `diff[r1][c1] += 1`  
- `diff[r1][c2 + 1] -= 1`  
- `diff[r2 + 1][c1] -= 1`  
- `diff[r2 + 1][c2 + 1] += 1`

Then:

1. Prefix-sum across rows  
2. Prefix-sum down columns  

This reconstructs the full matrix.

### â­ Why it's better  
Each query becomes **O(1)**. Total: `O(q + nÂ²)` â†’ optimal.

### â±ï¸ Complexity
- Updates: `O(1)` per query  
- Build: `O(nÂ²)`  
- Total optimal.

### ğŸš€ Code (TypeScript)
```ts
function rangeAddQueries(n: number, queries: number[][]): number[][] {
  const diff = Array.from({ length: n + 1 }, () => new Array(n + 1).fill(0));

  for (const [r1, c1, r2, c2] of queries) {
    diff[r1][c1]++;
    diff[r1][c2 + 1]--;
    diff[r2 + 1][c1]--;
    diff[r2 + 1][c2 + 1]++;
  }

  for (let i = 0; i <= n; i++) {
    let run = 0;
    for (let j = 0; j <= n; j++) {
      run += diff[i][j];
      diff[i][j] = run;
    }
  }

  for (let j = 0; j <= n; j++) {
    let run = 0;
    for (let i = 0; i <= n; i++) {
      run += diff[i][j];
      diff[i][j] = run;
    }
  }

  return Array.from({ length: n }, (_, i) => diff[i].slice(0, n));
}
```

---

## ğŸ†š Comparison

| Feature | Your Approach | Optimal 2D Diff |
|--------|----------------|----------------|
| Per-query work | O(height of query) | **O(1)** |
| Total time | Good | **Best possible** |
| Technique | Row-diff | Full 2D diff |

---

