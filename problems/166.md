# ðŸ§© 166. Fraction to Recurring Decimal

**Difficulty:** Medium  
**Tags:** Math, Simulation, Hash Map, String  
**Link:** [LeetCode](https://leetcode.com/problems/fraction-to-recurring-decimal/)

---

## ðŸ§  Intuition  
Perform long division: the integer part is `floor(numerator / denominator)`. The fractional part is generated by repeatedly multiplying the remainder by 10 and extracting digits. A repeating fractional cycle occurs exactly when a remainder repeats â€” because the remainder uniquely describes the division state immediately before producing the next digit.

Key invariant: always store the **canonical remainder** `r` (with `0 <= r < denominator`) **before** you multiply by 10 to generate the next digit. If you store remainders inconsistently (sometimes after multiplying), you will miss cycles or produce wrong start indices.

---

## ðŸ’¡ Approach â€” Canonical Long Division

1. Handle sign and absolute values.  
2. Compute the integer (whole) part `q = Math.floor(|num| / |den|)` and remainder `r = |num| % |den|`. If `r === 0`, return `q` (with sign).  
3. For fractional digits:
   - Keep an array `digits[]` for fractional digits.
   - Keep a `Map<remainder, index>` mapping a canonical remainder to the index in `digits` where the digit produced by that remainder will be appended.
   - Loop while `r != 0`:
     - If `seen.has(r)`: digits from `seen.get(r)` to end repeat â†’ build string with parentheses and return.
     - `seen.set(r, digits.length)` (record position for this remainder).
     - `r *= 10`; `digit = Math.floor(r / den)`; `digits.push(digit.toString())`; `r = r % den`.
4. If loop finishes (`r === 0`), join digits and return non-repeating decimal.

This method is simple, robust, and handles all repeat patterns correctly.

---

## âœ… Implementation (JavaScript)

```javascript []
function fractionToDecimal(numerator: number, denominator: number): string {
    //edge case
    if(numerator === 0) return "0";

    // -ve number handle
    let isNegative = false;
    if(numerator < 0) { 
        numerator *= -1;
        isNegative = !isNegative;
    }
    if(denominator < 0) {
        denominator *= -1; 
        isNegative = !isNegative;
    }

    const beforeDecimal = Math.floor(numerator/denominator);
    let reminder = numerator%denominator;
    let afterDecimal = "";
    const reminderStore = new Map(); // to check repeating reminders

    function constructAnswer(repetationIndex = null){
        let ans = (isNegative ? "-" : "") + beforeDecimal;

        if(afterDecimal !== ""){
            ans +=  ".";

            if(repetationIndex){
                ans += afterDecimal.substring(0, repetationIndex); // non recuring part
                ans += "(" + afterDecimal.substring(repetationIndex, ) + ")"; // recuring part
            } else ans +=  afterDecimal; // when faction has only non recuring part
        }

        return ans;
    }

    // handel division
    while(true){ 
        // in case of complete division
        if(reminder === 0) return constructAnswer();
        
        reminder *= 10;
        afterDecimal += Math.floor(reminder/denominator)
        reminder = reminder%denominator;

        if(reminderStore.has(reminder)){
            const index = reminderStore.get(reminder);
            return constructAnswer(index); 
        }else{
            reminderStore.set(reminder, afterDecimal.length);
        }
    }

    return ""; // never reah this line 
};
```

## ðŸ“Š Complexity

- **Time**: `O(m)` where `m` is the number of fractional digits produced until termination or cycle. In the worst case `m < denominator`, so `O(denominator)`. For constraints this is fine.
- **Space**: `O(m)` for `digits` + `seen` (worst-case `O(denominator)`).
