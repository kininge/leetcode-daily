# 🧩 Problem #326 - Power of Three

**Difficulty:** Easy
**Tags:** Math

---

## 🧠 Intuition
If `n` is a power of three, it can be written as `3^x`.  
The largest power of three that fits within a 32-bit signed integer is:

```text
  3^19 = 1162261467
```

Every smaller power of three is a divisor of this number.  
So instead of looping or recursing, we can check:

> `n` is a power of three ⇔ `n > 0` **and** `1162261467 % n == 0`.

This works because:
- If `n = 3^k` where `0 ≤ k ≤ 19`, it divides `3^19` evenly.
- If `n` has any other prime factor, it will not divide `3^19`.

---

## 💡 Approach 1 — O(1) Divisibility Trick
1. Precompute `MAX_POWER_3 = 1162261467`.
2. Check `(n > 0) && (MAX_POWER_3 % n === 0)`.

**Code:**
```javascript
var isPowerOfThree = function(n) {
    const MAX_POWER_3 = 1162261467; // 3^19
    return (n > 0) && (MAX_POWER_3 % n === 0);
};
```

## 💡 Approach 2 — Iterative Division
1. If `n < 1`, return `false`.
2. While `n % 3 === 0`, divide `n` by `3`.
3. At the end, return `n === 1`.

**Code:**
```javascript
var isPowerOfThree = function(n) {
    if (n < 1) return false;
    while (n % 3 === 0) {
        n = n / 3;
    }
    return n === 1;
};
```
## 📊 Complexity
| Approach                  | Time Complexity | Space Complexity |
|---------------------------|-----------------|------------------|
| O(1) Divisibility Trick   | O(1)            | O(1)             |
| Iterative Division        | O(log₃ n)       | O(1)             |

---

## 🔍 Notes
- Approach 1 is fastest and cleanest, but requires knowing the max power beforehand.
- Approach 2 works without precomputation and is still very efficient.
- Floating-point `Math.log` methods are possible but prone to precision errors.

