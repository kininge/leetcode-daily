# üß© Problem #3021 ‚Äì Alice and Bob Playing Flower Game

**Difficulty:** Medium  
**Topics:** `Dynamic Programming`, `Math`, `Combinatorics`  
**Link:** [Leetcode](https://leetcode.com/problems/alice-and-bob-playing-flower-game/description/)

---

## üìú Problem Summary
Two lanes of flowers contain `x` and `y` flowers. Alice moves first; each turn removes **one** flower from **one** lane.  
Whoever takes the **last** flower wins.

For all `1 ‚â§ x ‚â§ n`, `1 ‚â§ y ‚â§ m`, count pairs `(x, y)` where **Alice** wins.

---

## üí° Approach 1 ‚Äì Brute Force (Iterative Simulation)

> **Hint:** If you simulate any fixed ‚Äúalways take from lane 1 if possible‚Äù policy, the **total number of moves** is still `x + y`.

### Intuition
Simulate every `(x,y)`. Alternate turns, remove from lane 1 when possible else lane 2.  
If the last move is Alice‚Äôs, count it.

### Code
```javascript []
// O(n*m*(avg(x+y))) ‚Äî for tiny n,m only (sanity check)
function countPairsBruteIter(n, m) {
  let ans = 0;
  for (let x = 1; x <= n; x++) {
    for (let y = 1; y <= m; y++) {
      let X = x, Y = y;
      let aliceTurn = true;
      while (X > 0 || Y > 0) {
        if (X > 0) X--;
        else Y--;
        if (X === 0 && Y === 0 && aliceTurn) ans++;
        aliceTurn = !aliceTurn;
      }
    }
  }
  return ans;
}
```

### Complexity
 - Time: `O(n*m*(avg(x+y)))`
 - Space: `O(1)`

## üí° Approach 2 ‚Äì Recursive Game DP (Top-Down)

### Intuition
Think of this as a **two-player impartial game**.  
Define `win(x, y)` as: **can the current player force a win with `x` and `y` flowers remaining?**

- **Base case:**  
  `win(0, 0) = false` ‚Üí if no flowers are left, the current player cannot move and therefore loses.
  
- **Transition:**  
  A player can remove one flower from either lane (if available).  
  The current state is winning if **at least one move** puts the opponent into a losing state:  

``` text
win(x, y) = (x > 0 && !win(x-1, y)) || (y > 0 && !win(x, y-1))
```

- **Goal:**  
For every `(x, y)` with `1 ‚â§ x ‚â§ n` and `1 ‚â§ y ‚â§ m`, evaluate `win(x, y)`.  
Count how many are `true` ‚Üí those are pairs where Alice (the starting player) wins.

---

### Example Walkthrough
- `(1,1)` ‚Üí total = 2 moves ‚Üí Bob wins ‚Üí `win(1,1) = false`
- `(1,2)` ‚Üí total = 3 moves ‚Üí Alice wins ‚Üí `win(1,2) = true`

This matches the intuition: if `x+y` is odd, Alice wins; if even, Bob wins.  
But here we derive it by **explicit recursion** instead of jumping straight to parity.

---

```javascript []
// O(n*m) states ‚Äî educational; fine for small ranges
function countPairsRecursiveDP(n, m) {
  const memo = Array.from({ length: n + 1 }, () => Array(m + 1).fill(undefined));
  function win(x, y) {
    if (x === 0 && y === 0) return false;
    if (memo[x][y] !== undefined) return memo[x][y];
    let res = false;
    if (x > 0 && !win(x - 1, y)) res = true;
    else if (y > 0 && !win(x, y - 1)) res = true;
    memo[x][y] = res;
    return res;
  }
  let ans = 0;
  for (let x = 1; x <= n; x++) {
    for (let y = 1; y <= m; y++) {
      if (win(x, y)) ans++;
    }
  }
  return ans;
}
```

### Complexity
- **States:** `O(n*m)` possible `(x,y)` combinations  
- **Per state:** `O(1)` transitions (two moves max)  
- **Time:** `O(n*m)`  
- **Space:** `O(n*m)` (for memoization table)

---

## üí° Approach 3 ‚Äì Parity Counting (Combinatorial)

> **Hint:** Each move removes exactly **one** flower. So the total number of moves is‚Ä¶ `x + y`. Who moves on odd turns?

### Key Insight
- Alice plays on **odd-numbered** turns.  
- Therefore, Alice **wins iff** `x + y` is **odd**.

So we just need to **count pairs with different parity**.

### Counting Different Parities
Let:
- `even(k) = ‚åäk/2‚åã`
- `odd(k)  = ‚åàk/2‚åâ`

Then the number of winning pairs is:
- `even(n) * odd(m)  +  odd(n) * even(m)`

Because:
- `(even x, odd y)` ‚Üí `x + y` odd  
- `(odd x, even y)` ‚Üí `x + y` odd

### Tiny Examples (sanity)
- `n=3, m=2`:  
  `even(3)=1`, `odd(3)=2`, `even(2)=1`, `odd(2)=1`  
  Count = `1*1 + 2*1 = 3` ‚úÖ
- `n=1, m=1`:  
  `even(1)=0`, `odd(1)=1`  
  Count = `0*1 + 1*0 = 0` ‚úÖ

```javascript []
function countPairsParity(n, m) {
  const evenN = Math.floor(n / 2), oddN = Math.ceil(n / 2);
  const evenM = Math.floor(m / 2), oddM = Math.ceil(m / 2);
  return evenN * oddM + oddN * evenM;
}
```

### Complexity
- **Time:** `O(1)`  
- **Space:** `O(1)`

### Why This Works (short version)
Game length is fixed to `x + y`. If it‚Äôs odd, the 1st player (Alice) makes the final move; if even, the 2nd player (Bob) does. Counting pairs with odd sum gives the answer directly.

> You were already on this track‚Äînice parity read. Now let‚Äôs package it cleanly for the write-up.

---

### When to Use
- **Educational**: Shows the game-theory recursion explicitly.  
- **Not practical** for large `n, m` (`1e5`), but useful for **small ranges** to validate brute force or to discover the parity pattern.

---

## üí° Approach 4 ‚Äì Closed Form

> **Hint:** Your Approach 3 already reduced it to counting pairs with **odd** `x + y`. What happens to that count if you multiply out the even/odd buckets?

### Key Result
The count simplifies to a **single expression**:
\[
\boxed{\left\lfloor \dfrac{n \cdot m}{2} \right\rfloor}
\]

### Why This Is True (quick)
From Approach 3:
- `even(k)=‚åäk/2‚åã`, `odd(k)=‚åàk/2‚åâ`
- Count = `even(n)*odd(m) + odd(n)*even(m)`

Algebra (handle n,m parity jointly) collapses that sum to `‚åän¬∑m / 2‚åã`.  
Intuition: among all `n¬∑m` pairs, **exactly half** have odd sum; when `n¬∑m` is odd, the floor takes the extra one away.

``` javascript []
var flowerGame = function(n, m) {
  return Math.floor((n * m) / 2);
};
```

### Complexity
- **Time:** `O(1)`
- **Space:** `O(1)`

---

## üîç Comparison of Approaches

| Approach | Idea | Time | Space | When to use |
|---|---|---:|---:|---|
| 1) Brute Force (Iterative) | Simulate every game | `Œò(n*m*(avg x+y))` | `O(1)` | Sanity for tiny inputs |
| 2) Recursive DP (Top-Down) | `win(x,y)` with memo | `O(n*m)` | `O(n*m)` | Educational / discover pattern |
| 3) Parity Counting | Count different parities | `O(1)` | `O(1)` | Clean derivation |
| 4) Closed Form | Direct formula `‚åän¬∑m/2‚åã` | `O(1)` | `O(1)` | Final submission |

---

## üß™ Sanity Checks (examples)

- `n=3, m=2` ‚Üí `‚åä6/2‚åã = 3` ‚úÖ (example)
- `n=1, m=1` ‚Üí `‚åä1/2‚åã = 0` ‚úÖ (example)
- `n=3, m=3` ‚Üí `‚åä9/2‚åã = 4` ‚úÖ
- `n=2, m=6` ‚Üí `‚åä12/2‚åã = 6` ‚úÖ

---

## üìù Notes & Pitfalls

- **Don‚Äôt overthink with casework.** The parity buckets already imply `‚åän¬∑m/2‚åã`.
- **JS bitwise gotcha (if you code it):** Avoid `>> 1`; bitwise is 32-bit and `n*m` can be `1e10`. Use arithmetic floor.
- Tiny roast: `EventInN` ‚Üí **EvenInN**. Unless you‚Äôre hosting a hackathon.

---



