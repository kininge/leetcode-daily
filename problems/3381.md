# ðŸ§© Problem #3381 â€“ Maximum Subarray Sum With Length Divisible by K

**Difficulty:** Medium  
**Topics:** Prefix Sum, Modulo, Arrays, Greedy, Dynamic Programming    
**Link:** https://leetcode.com/problems/maximum-subarray-sum-with-length-divisible-by-k/

---

## ðŸ“ Problem Summary

You are given an integer array `nums` and an integer `k`.

Your goal:  
Find the **maximum possible sum** of a subarray whose **length is divisible by `k`**.

Formally, among all subarrays `nums[l..r]` such that:
```text
(r - l + 1) % k == 0
```

Return the maximum value of:
```text
sum(nums[l..r])
```

---

## ðŸ’¡ Intuition

Let `P[t]` be the prefix sum of the first `t` elements:
```text
P[0] = 0
P[t] = nums[0] + ... + nums[t-1]
```

The sum of subarray `nums[l..r]` is:
```text
P[r+1] - P[l]
```

We want:
```text
(r - l + 1) % k == 0
â‡” r + 1 â‰¡ l (mod k)
```


Meaning:

> The prefix indices `l` and `r+1` must have the **same remainder modulo k**.

So for each prefix index `t`, to form a valid subarray ending at index `t-1`,  
We only need a previous prefix index`s < t` where:
```text
s % k == t % k
```

And we want to **maximise**:
```text
P[t] - P[s]
```

To do that, we keep:
```text
minPrefix[r] = minimum prefix sum P[s] seen for indices s where s % k == r
```

Then:
```text
candidate = P[t] - minPrefix[t % k]
```

This gives an **O(n)** solution.

---

## ðŸƒ Approach â€” Prefix Sum + Remainder Buckets (O(n))

### Steps

1. Maintain a running prefix sum `prefix`.
2. Keep an array `minPrefix[0..k-1]` where:
   - `minPrefix[r]` = smallest prefix sum seen at indices whose index % k = r.
3. Initialize:
   - `prefix = 0`
   - `minPrefix[:] = Infinity`
   - `minPrefix[0] = 0` (prefix index 0 has sum 0 with remainder 0)
4. For each index `i`:
   - `prefix += nums[i]`
   - Let `t = i + 1`
   - Let `r = t % k`
   - The best valid subarray ending at `i` is:

     ```
     prefix - minPrefix[r]
     ```

   - Update the global answer.
   - Update `minPrefix[r] = min(minPrefix[r], prefix)`
5. Return the final answer.

---

## ðŸ§© Visual Diagram â€” How the Prefix & Remainder Trick Works

Imagine we build the prefix sum array `P`:

Index (t):     0    1    2    3    4    5    ...
Prefix P[t]:   0   P1   P2   P3   P4   P5   ...

For each prefix index `t`, the corresponding subarray end is:
- subarray ending at index `t-1`

A subarray from `l` to `r` is valid when:
```text
(r - l + 1) % k == 0
```

Using prefix sums, that becomes:
```text
(r + 1) % k == l % k
```

### ðŸ”— Visualizing the condition

prefix index: 0 1 2 3 4 5 6
prefix sum: P0 P1 P2 P3 P4 P5 P6
index % k (k=3): 0 1 2 0 1 2 0

To form a valid subarray ending at t:
```text
s % k == t % k
```

So we only match indices that land in the same column:
Group r = 0: indices {0, 3, 6, 9, ...}
Group r = 1: indices {1, 4, 7, 10, ...}
Group r = 2: indices {2, 5, 8, 11, ...}


### ðŸ” How we find the best subarray ending at prefix index t

For a given `t`, let:
```text
r = t % k
```

We Want:
```text
max(P[t] - P[s]) where s % k == r and s < t
```

Which is equivalent to:
```text
P[t] - min_prefix_in_same_group
```

So we maintain:
```text
minPrefix[r] = smallest prefix sum seen so far in group r
```


### ðŸ“˜ Example walkthrough (k = 3)

Suppose prefix sums look like this:
```text
t: 0 1 2 3 4 5
P[t]: 0 5 8 4 11 13
t % 3: 0 1 2 0 1 2
```

We maintain:
```text
minPrefix[0] = P[0] = 0
minPrefix[1] = P[1] = 5
minPrefix[2] = P[2] = 8
```

When t = 5:
```text
t % 3 = 2
candidate = P[5] - minPrefix[2]
= 13 - 8
= 5
```

This corresponds to subarray:
from prefix index s=2 to t=5
â‡’ subarray nums[2..4]


### ðŸ’¡ Why it works

Because the length condition:
```text
(r - l + 1) % k == 0
```

becomes:
```text
(t = r+1) and (s = l)
t % k == s % k
```


So grouping prefix indices by `t % k` automatically enforces the length rule.
We then pick the **smallest prefix sum** in that group to maximize the subarray sum.

---

## ðŸ§¾ Code (TypeScript)

```ts
function maxSubarraySum(nums: number[], k: number): number {
    const n = nums.length;
    let prefix = 0;
    let ans = -Infinity;

    // minPrefix[r] = smallest prefix P[s] for indices s where s % k == r
    const minPrefix = new Array<number>(k).fill(Infinity);
    minPrefix[0] = 0; // prefix index 0 â†’ sum 0 â†’ remainder 0

    for (let i = 0; i < n; i++) {
        prefix += nums[i];
        const t = i + 1;
        const r = t % k;

        // best subarray ending at i with length divisible by k
        const candidate = prefix - minPrefix[r];
        if (candidate > ans) ans = candidate;

        // update min prefix for this remainder class
        if (prefix < minPrefix[r]) {
            minPrefix[r] = prefix;
        }
    }

    return ans;
}
```

---

## â±ï¸ Complexity

- **Time:** `O(n)`
- **Space:** `O(k)`

This is optimal and avoids all nested loops.

---




