# ðŸ§© Problem #407 - Trapping Rain Water II

**Difficulty:** Hard  
**Tags:** Heap, Breadth Frist Search, Graph, Matrix
**Link:** [LeetCode](https://leetcode.com/problems/trapping-rain-water-ii/description/)  

---

## ðŸ“œ Problem Summary
We are given an `m Ã— n` matrix `heightMap` representing terrain heights. Rain falls on it, and water can collect in valleys bounded by higher terrain.  

Return the **total volume of water** trapped after raining.  

Constraints:
- `1 <= m, n <= 200`  
- `0 <= heightMap[i][j] <= 2 * 10^4`  

---

## ðŸ’¡ Intuition
This is a 2D generalisation of the 1D "Trapping Rain Water" problem.  

- Water at a cell is determined by the **lowest boundary height** that can contain it.  
- Boundaries are always at the **edges** (outermost cells).  
- If we start from the lowest boundary and move inward, we can â€œflood fillâ€ the map, raising water levels where possible.

This naturally suggests:
- Use a **min-heap** (priority queue) seeded with all boundary cells.  
- Pop the lowest-height cell, then explore its neighbours:  
  - If a neighbour is lower, water can be trapped.  
  - Push neighbor with effective height = `max(neighborHeight, boundaryHeight)`.  

This is essentially **multi-source BFS with a min-heap**.

---

## ðŸ§­ Approach â€” Min-Heap + BFS
1. Initialise a min-heap with all boundary cells (`O(m+n)` cells).  
2. Mark them as visited.  
3. While the heap is not empty:  
   - Pop the lowest boundary cell.  
   - For each neighbour not visited:  
     - If neighbor height < boundary height, trap water = `boundary - neighbor`.  
     - Push neighbor with effective height = `max(neighbor, boundary)`.  
     - Mark as visited.  
4. Accumulate trapped water.  

---

## âœ… Complexity
- **Time:** `O(m * n * log(m * n))` â€” each cell pushed/popped once from heap.  
- **Space:** `O(m * n)` â€” visited + heap.  

---

## ðŸ“ Implementation (TypeScript)
```ts
function trapRainWater(heightMap: number[][]): number {
  const n = heightMap.length;
  if (n === 0) return 0;
  const m = heightMap[0].length;
  if (n < 3 || m < 3) return 0; // no interior -> no trapped water

  const visited: boolean[][] = Array.from({ length: n }, () => Array(m).fill(false));
  const heap = new MinHeap<{ h: number; x: number; y: number }>((a, b) => a.h < b.h);

  // Push all boundary cells into heap
  for (let j = 0; j < m; j++) {
    heap.push({ h: heightMap[0][j], x: 0, y: j });
    visited[0][j] = true;
    heap.push({ h: heightMap[n - 1][j], x: n - 1, y: j });
    visited[n - 1][j] = true;
  }
  for (let i = 1; i < n - 1; i++) {
    heap.push({ h: heightMap[i][0], x: i, y: 0 });
    visited[i][0] = true;
    heap.push({ h: heightMap[i][m - 1], x: i, y: m - 1 });
    visited[i][m - 1] = true;
  }

  const dirs = [[-1,0], [0,1], [1,0], [0,-1]];
  let trapped = 0;

  while (!heap.isEmpty()) {
    const { h, x, y } = heap.pop()!;
    for (const [dx, dy] of dirs) {
      const nx = x + dx, ny = y + dy;
      if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
      if (visited[nx][ny]) continue;

      let nh = heightMap[nx][ny];
      if (nh < h) {
        trapped += h - nh; // trap water
        nh = h;            // water level rises
      }
      visited[nx][ny] = true;
      heap.push({ h: nh, x: nx, y: ny });
    }
  }
  return trapped;
}

/* Minimal MinHeap implementation */
class MinHeap<T> {
  private heap: T[] = [];
  private cmp: (a: T, b: T) => boolean;

  constructor(cmp: (a: T, b: T) => boolean) {
    this.cmp = cmp;
  }

  isEmpty(): boolean {
    return this.heap.length === 0;
  }

  push(val: T): void {
    this.heap.push(val);
    this._siftUp(this.heap.length - 1);
  }

  pop(): T | null {
    if (this.heap.length === 0) return null;
    if (this.heap.length === 1) return this.heap.pop()!;
    this._swap(0, this.heap.length - 1);
    const root = this.heap.pop()!;
    this._siftDown(0);
    return root;
  }

  private _siftUp(idx: number): void {
    let i = idx;
    while (i > 0) {
      const p = Math.floor((i - 1) / 2);
      if (this.cmp(this.heap[i], this.heap[p])) {
        this._swap(i, p);
        i = p;
      } else break;
    }
  }

  private _siftDown(idx: number): void {
    let i = idx;
    const n = this.heap.length;
    while (i * 2 + 1 < n) {
      let child = i * 2 + 1;
      if (child + 1 < n && this.cmp(this.heap[child + 1], this.heap[child])) {
        child = child + 1;
      }
      if (this.cmp(this.heap[child], this.heap[i])) {
        this._swap(child, i);
        i = child;
      } else break;
    }
  }

  private _swap(a: number, b: number): void {
    [this.heap[a], this.heap[b]] = [this.heap[b], this.heap[a]];
  }
}
```

## ðŸ”‘ Key Takeaways

- Always think of boundaries first in water-trapping problems.
- This is a 2D extension of the two-pointer technique in 1D, but implemented with a heap + BFS.
- The min-heap ensures we always expand from the lowest boundary, guaranteeing correctness.

