# üß© Problem #3512 ‚Äì Minimum Operations to Make Array Sum Divisible by K

**Difficulty:** Easy  
**Topics:** Array, Math, Modulo  
**Link:** https://leetcode.com/problems/minimum-operations-to-make-array-sum-divisible-by-k/

---

## üìù Problem Summary

You are given:
- An integer array `nums`
- An integer `k`

You may perform the following operation any number of times:

```text
Select an index i and replace nums[i] with nums[i] - 1
```


Each operation reduces exactly **1** from the total array sum.

Your task:
Return the **minimum number of operations** required so that the **sum of the array becomes divisible by k**.

## üí° Intuition

Let:
```text
S = sum(nums)
```


This decreases the **total sum** by exactly `1`:
```text
S ‚Üí S - 1 ‚Üí S - 2 ‚Üí S - 3 ‚Üí ...
```

We want the smallest `x` such that:
```text
(S - x) % k == 0
```

Rearrange:
```text
x ‚â° S (mod k)
```

The smallest non-negative solution is:
```text
x = S % k
```


That‚Äôs it.

We don‚Äôt care which index `i` we pick ‚Äî the operation always subtracts **1** from the sum.

So the answer is simply **the remainder of the sum when divided by `k`**.

---

## üçÉ Approach ‚Äî Reduce Total Sum Until Divisible

1. Compute the sum of all elements:
```text
S = sum(nums)
```
2. If `S%k == 0`, no operations are needed.
3. Otherwise, we must subtract `S%k` from the sum to make it divisible by `k`.

Each operation subtracts exactly 1, so:
```text
minimum operations = S % k
```

This is optimal and cannot be improved.

---

## üßæ Code (TypeScript)

```ts
function minOperations(nums: number[], k: number): number {
    const total = nums.reduce((sum, n) => sum + n, 0);
    return total % k;
}
```

---

## ‚è±Ô∏è Complexity

- **Time:** `O(n)`
- **Space:** `O(1)`

We only compute the sum and one modulo operation.

---


