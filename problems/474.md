# ğŸ§© Problem #474 â€“ Ones and Zeroes

**Difficulty:** Medium  
**Topics:** `Dynamic Programming`, `Knapsack`  
**Link:** [Leetcode](https://leetcode.com/problems/ones-and-zeroes)

---

## âš™ï¸ Problem Intuition

Each string can be seen as an *item* that consumes some number of `0`s and `1`s.  
We can only pick a subset of strings such that:
- total `0`s â‰¤ m  
- total `1`s â‰¤ n  

The goal is to maximise how many strings we can pick.

This is a **0/1 Knapsack Problem** but with **two capacities** (m and n).  
Each string = an item with weight = (zeros, ones) and value = 1.

---

## ğŸ§  Approach 1 â€” Brute Force (DFS)

Try all subsets of strings recursively.

At each index:
- Either include the string (if budget allows)
- Or skip it

```ts
function findMaxForm(strs: string[], m: number, n: number): number {
  const counts: [number, number][] = strs.map(s => {
    const z = s.split('').filter(c => c === '0').length;
    const o = s.length - z;
    return [z, o];
  });

  function dfs(i: number, zeros: number, ones: number): number {
    if (i === strs.length) return 0;
    const [z, o] = counts[i];
    let skip = dfs(i + 1, zeros, ones);
    let take = 0;
    if (zeros + z <= m && ones + o <= n)
      take = 1 + dfs(i + 1, zeros + z, ones + o);
    return Math.max(skip, take);
  }

  return dfs(0, 0, 0);
}
```

### âŒ Drawback:

**Time complexity** = `O(2^L)` L = number of strings â†’ up to 600 â†’ `TLE`

---

## âš™ï¸ Approach 2 â€” DFS + Memoization

We can store results by (index, usedZeros, usedOnes).

```ts
function findMaxForm(strs: string[], m: number, n: number): number {
  const counts: [number, number][] = strs.map(s => {
    const z = s.split('').filter(c => c === '0').length;
    const o = s.length - z;
    return [z, o];
  });

  const memo = new Map<string, number>();

  function dfs(i: number, zeros: number, ones: number): number {
    if (i === strs.length) return 0;
    const key = `${i}-${zeros}-${ones}`;
    if (memo.has(key)) return memo.get(key)!;

    const [z, o] = counts[i];
    let res = dfs(i + 1, zeros, ones);
    if (zeros + z <= m && ones + o <= n)
      res = Math.max(res, 1 + dfs(i + 1, zeros + z, ones + o));

    memo.set(key, res);
    return res;
  }

  return dfs(0, 0, 0);
}
```

âœ… Fixes overlapping subproblems
âŒ Still slower and memory-hungry due to a large state space.

---

## ğŸš€ Approach 3 â€” 2D Bottom-Up DP (Optimal)

Let `dp[i][j]` = the maximum strings we can include using at most `i` zeros and `j` ones.

For each string (zeros=z, ones=o):
- Traverse `i` from mâ†’z  
- Traverse `j` from nâ†’o  
- Update: `dp[i][j] = max(dp[i][j], 1 + dp[i - z][j - o])`


This is exactly the 0/1 knapsack pattern, just with two capacities.

```ts
function findMaxForm(strs: string[], m: number, n: number): number {
const counts: [number, number][] = strs.map(s => {
  const z = s.split('').filter(c => c === '0').length;
  const o = s.length - z;
  return [z, o];
});

const dp = Array.from({ length: m + 1 }, () => new Array(n + 1).fill(0));

for (const [z, o] of counts) {
  for (let i = m; i >= z; i--) {
    for (let j = n; j >= o; j--) {
      dp[i][j] = Math.max(dp[i][j], 1 + dp[i - z][j - o]);
    }
  }
}

return dp[m][n];
}
```

---

## ğŸ§® Example

Input:  
strs = ["10", "0001", "111001", "1", "0"]  
m = 5, n = 3  

Step 1: Count zeros/ones â†’ [[1,1],[3,1],[2,4],[0,1],[1,0]]  
Step 2: Fill dp table (m=5, n=3)  
Output: **4**

Possible subset: ["10", "0001", "1", "0"]

---

## ğŸ“Š Complexity

| Approach | Time | Space | Notes |
|-----------|------|--------|--------|
| Brute Force | O(2^L) | O(L) | Exponential |
| DFS + Memo | O(L * m * n) | O(L * m * n) | Large state but works |
| DP Bottom-Up | âœ… O(L * m * n) | âœ… O(m * n) | Best practical |

---

## ğŸ Key Takeaways

- This is a **multi-dimensional knapsack** problem (2D constraints).  
- Backward iteration ensures each string is used only once.  
- Converting to counts (zeros, ones) upfront simplifies logic.  
- **DP[m][n]** finally holds the largest subset size possible.

---

