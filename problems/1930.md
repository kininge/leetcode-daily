# üß© Problem #1930 ‚Äì Unique Length 3 Palindromic Subsequences

**Difficulty:** Medium  
**Topics:** `String`, `Prefix sum`, `Hash Map`  
**Link:** https://leetcode.com/problems/unique-length-3-palindromic-subsequences/

---

## üìù Problem Summary

You are given a string `s` consisting of lowercase English letters.

You must count how many **unique palindromes of length 3** can be formed as **subsequences** of `s`.

- A palindrome of length 3 has the form: `x y x`.
- A subsequence means you can delete some characters without reordering the rest.

Important:
- If the same palindrome (like `"aba"`) can be formed in multiple ways, it is counted **only once**.

You must return the **count of distinct palindromic subsequences of length 3**.

---

## üí° Intuition

- A length-3 palindrome has the structure: `xyx`
- To count unique palindromes, we must determine:
    1. The outer character `x`.
    2. All distinct characters `y` that appear between the first and last occurrence of `x`.
- **IMPORTANT LOGIC**
    - If a character `x` appears at least twice
    - Then each unique charater between *first* and *last* occarance of `x` will create unique palindrome `xyx`
    - Where `y` is unique charater between *first* and *last* occarance of `x`

# Approach

## STEP 1

- Scan and find all 26 character's *first* and *last* indexes.
![Screenshot 2025-11-21 at 1.37.10‚ÄØPM.png](https://assets.leetcode.com/users/images/a40c7783-7671-4f7b-9f29-d55f1fa8453c_1763716961.4152105.png)

## STEP 2

- Generate character map prefix matrix at each index
![Screenshot 2025-11-21 at 2.06.45‚ÄØPM.png](https://assets.leetcode.com/users/images/0c25f5d0-fe4c-4195-8a80-472c64cfa62b_1763717062.7496402.png)

## STEP 3

- For characters `a` to `z` find unique characters between them.
```text
Diffrence map = prefix[L-1] - Prefix[F]
```
![Screenshot 2025-11-21 at 2.35.14‚ÄØPM.png](https://assets.leetcode.com/users/images/565cbf3a-defb-4c84-94d9-aafb865b7a76_1763717211.9850376.png)


# Complexity
- **Time complexity:** `O(26 * n)`
    - Prefix building takes `O(26n)`, and checking all character pairs is constant overhead.

- **Space complexity:** `O(26 * n)`
    - To generate a prefix matrix

# Code
```typescript []
function countPalindromicSubsequence(s: string): number {
    const n = s.length;

    // O(n) - index of first occarance of any char
    const firstCharIndex = new Array(26).fill(null);
    // O(n) - index of last occurrence of any char
    const lastCharIndex = new Array(26).fill(null);
    // O(26*n) - prefix matrix of of char at each index
    const prefixChar = [];

    // O(26*n) - generate first and last index of each char AND prefix character map
    for(let i=0; i<n; i++){
        const charIndex = s.charCodeAt(i)-97;

        // first index update
        if(firstCharIndex[charIndex] === null) firstCharIndex[charIndex] = i;
        // last index update
        else lastCharIndex[charIndex] = i;

        const previousCharMap = (i === 0) ? new Array(26).fill(0) : [...prefixChar[i-1]];
        previousCharMap[charIndex] += 1; // prefix update
        prefixChar.push(previousCharMap);
    }

    let uniquePalindroms:number = 0;
    // O(26*26)
    for(let i=0; i<26; i++){
        const firstIndex = firstCharIndex[i];
        const lastIndex = lastCharIndex[i];

        // char at least repeat for 2 times in 's' 
        if(firstIndex !== null && lastIndex !== null){
            const secondLastMap = prefixChar[lastIndex-1];
            const firstMap = prefixChar[firstIndex];

            // diffMap = prefix[L-1] - prefix[F];
            // count of unique characters in diffMap is the answer
            for(let j=0; j<26; j++){
                if((secondLastMap[j] - firstMap[j]) > 0) uniquePalindroms++;
            }
        }
    }

    return uniquePalindroms;
}
```

---
