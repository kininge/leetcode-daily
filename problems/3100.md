# ðŸ§© Problem #3100 - Water Bottles II

**Difficulty:** Medium  
**Tags:** Greedy, Simulation, Math  
**Link:** [Water Bottle ii](https://leetcode.com/problems/water-bottles-ii/description)

---

## ðŸ“œ Problem Summary
You have `numBottles` full bottles initially. In one operation you may:
- Drink any number of full bottles (each becomes an empty bottle).
- Exchange `numExchange` empty bottles for **one** full bottle, then **increment** `numExchange` by 1.

You cannot exchange multiple batches for the same `numExchange` value. Return the maximum number of bottles you can drink.

---

## ðŸ’¡ Key idea (hint)
Drink bottles in batches of size `min(fullBottles, currExchange)`. If you drank exactly `currExchange` bottles you get one exchange (one full bottle back) and `currExchange` increases by one. Repeat greedily.

---

## Approach (Greedy simulation)
- Keep `fullBottles`, `currExchange`, and `totalDrunk`.
- While `fullBottles > 0`:
  - `drinkNow = min(fullBottles, currExchange)`.
  - `totalDrunk += drinkNow; fullBottles -= drinkNow`.
  - If `drinkNow == currExchange`: `fullBottles++`, `currExchange++`.
- Return `totalDrunk`.

This batch strategy is optimal because exchanging requires exactly `currExchange` empties and you can't do multiple exchanges for the current `currExchange` value â€” so drinking any other amount can't increase the number of exchanges you can perform.

---

## Complexity
- Time: O(totalDrinks) â€” trivial for constraints.  
- Space: O(1).

---

## Implementation (TypeScript)
```ts
function maxBottlesDrunk(numBottles: number, numExchange: number): number {
  let fullBottles = numBottles;
  let currExchange = numExchange;
  let totalDrunk = 0;

  while (fullBottles > 0) {
    const drinkNow = Math.min(fullBottles, currExchange);
    totalDrunk += drinkNow;
    fullBottles -= drinkNow;
    if (drinkNow === currExchange) {
      fullBottles += 1;
      currExchange += 1;
    }
  }
  return totalDrunk;
}
```
