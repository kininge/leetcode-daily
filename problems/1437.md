# ðŸ§© Problem #1437 â€“ Check If All 1s Are at Least Length K Places Away

**Difficulty:** Easy  
**Topics:** `Array`, `Greedy`    
**Link:** https://leetcode.com/problems/check-if-all-1s-are-at-least-length-k-places-away/

---

## ðŸ“ Problem Summary

Given a binary array `nums` and an integer `k`, return `true` if every pair of `1`s in `nums` is at least `k` places apart (i.e., there are at least `k` zeros between any two `1`s). Otherwise return `false`.

---

## ðŸ’¡ Intuition

**Hint:** Track the position of the previous `1`.  
For each `1` at index `i`, check `i - prevIndex - 1 >= k` (where `prevIndex` is index of last `1`).  
If that fails for any pair, return `false`.  
If `k === 0`, always return `true`.

---

## âš ï¸ Pointed Mistake / Style note

Your solution is correct logically. No functional bug detected.

Small style suggestions:
- You can simplify by storing the index of the last seen `1` instead of using `setBitFound` and a `gap` counter â€” clearer and fewer branches.
- Early `if (k === 0) return true;` is good.
- Name `setBitFound` could be `seenOne` or use `lastOneIndex = -Infinity` to avoid the boolean flag.

---

## ðŸƒ Approach 1 â€” Your Solution (Cleaned)

### Idea
Keep a boolean once you encounter the first `1`. Count zeros after that; when you see the next `1`, ensure the counted zeros >= `k`.

### Complexity
- Time: `O(n)`  
- Space: `O(1)`

### Code (Typescript)
```ts
function kLengthApart(nums: number[], k: number): boolean {
    if (k === 0) return true;

    let gap = 0;
    let seenOne = false;

    for (const bit of nums) {
        if (seenOne && bit === 0) {
            gap++;
        } else if (seenOne && bit === 1) {
            if (gap < k) return false;
            gap = 0;
        } else if (!seenOne && bit === 1) {
            seenOne = true;
        }
    }
    return true;
}
```

---

## ðŸ€ Approach 2 â€” Index Tracking (Simpler)

### Idea
Keep `last = -Infinity` (or `-k-1`) as the index of the previous `1`.  
When you find a `1` at index `i`, check `i - last - 1 >= k`.  
If false â†’ return `false`. Otherwise set `last = i`.

### Complexity
- Time: `O(n)`  
- Space: `O(1)`

### Code (Typescript)
```ts
function kLengthApart(nums: number[], k: number): boolean {
    if (k === 0) return true;

    let last = -Infinity; // or -k-1
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] === 1) {
            if (last !== -Infinity && (i - last - 1) < k) return false;
            last = i;
        }
    }
    return true;
}
```
### Alternate initialisation (avoid -Infinity): 

```ts 
function kLengthApart(nums: number[], k: number): boolean {
    if (k === 0) return true;

    let last = -k - 1; // ensures first 1 always passes
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] === 1) {
            if (i - last - 1 < k) return false;
            last = i;
        }
    }
    return true;
}
```

---

## ðŸ†š Comparison

| Feature | Your (gap counter) | Index Tracking |
|--------|---------------------|----------------|
| Clarity | Clear but more branches | Cleaner logic |
| Time | O(n) | O(n) |
| Space | O(1) | O(1) |
| Preference | Works fine | Slightly simpler & idiomatic |

---

