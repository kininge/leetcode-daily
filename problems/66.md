# üß© Problem #66 ‚Äì Plus One

**Difficulty:** Easy  
**Topics:** `Array`, `Math`  
**Link:** https://leetcode.com/problems/plus-one/

---

## üìù Problem Summary

You are given a large integer represented as an array of digits `digits`.

- Each `digits[i]` is a single digit (`0‚Äì9`)
- Digits are ordered from **most significant ‚Üí least significant**
- The number has **no leading zeros**

Your task is to **increment the number by 1** and return the resulting array of digits.

### Example
```text
Input: [1,2,3]
Output: [1,2,4]
---
Input: [9,9]
Output: [1,0,0]
```


### Constraints
- `1 ‚â§ digits.length ‚â§ 100`
- `0 ‚â§ digits[i] ‚â§ 9`
- No leading zeros

---

## üí° Intuition

The number is represented as an array of digits, just like manual arithmetic.

To add `1`:
- Start from the **least significant digit** (rightmost).
- Add `1` and track the **carry**.
- If a digit becomes `10`, set it to `0` and carry `1` to the next digit.
- Stop early if carry becomes `0`.

Edge case:
- If all digits are `9` (e.g., `[9,9,9]`), the result becomes `[1,0,0,0]`.

This mimics elementary addition and works in one pass from right to left.

---

## üõ† Approach

This is a classic **digit addition with carry** problem, similar to how we do addition by hand.

### Key idea

- Start from the **least significant digit** (rightmost).
- Add `1` initially (since we are incrementing by one).
- Propagate the carry to the left **only if needed**.
- Stop early if carry becomes `0`.
- If after processing all digits, carry is still `1`, prepend it to the array.

### Why this works

- Each digit can only cause a carry once.
- The maximum carry propagation happens when all digits are `9`.
- The array size is small (`‚â§ 100`), so this direct simulation is optimal.

### Steps

1. Initialize `carry = 1`.
2. Traverse digits from right to left:
   - `digits[i] = (digits[i] + carry) % 10`
   - `carry = floor((digits[i] + carry) / 10)`
3. If `carry == 1` after loop, insert it at the front.
4. Return the modified digits array.

### üßæ Code (TypeScript)

```ts
function plusOne(digits: number[]): number[] {
    let carry = 1; // we are adding exactly one

    // iterate from least significant digit to most
    for (let i = digits.length - 1; i >= 0; i--) {
        if (carry === 0) break;

        const sum = digits[i] + carry;
        digits[i] = sum % 10;
        carry = Math.floor(sum / 10);
    }

    // if carry is still left, prepend it
    return carry === 0 ? digits : [carry, ...digits];
}
```

### ‚è± Complexity Analysis

Let `n = digits.length`.

#### Time Complexity
- **O(n)**  
  In the worst case (e.g. `[9,9,9]`), we traverse all digits once from right to left.

#### Space Complexity
- **O(1)** auxiliary space  
  - The operation is done **in-place** on the input array.
  - Only one extra digit may be added at the front in the case of a final carry (e.g. `[9,9] ‚Üí [1,0,0]`).

This is optimal for the problem.


---
