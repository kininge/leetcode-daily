# üß© Problem #1018 ‚Äì Binary Prefix Divisible By 5

**Difficulty:** Easy  
**Topics:** `Array`, `Math`, `Bit Manipulation`, `Prefix`  
**Link:** https://leetcode.com/problems/binary-prefix-divisible-by-5/

---

## üìù Problem Summary

You are given a binary array `nums` (elements are 0 or 1).

Define `x_i` as the **integer value** of the binary number formed by `nums[0..i]`
(from most significant bit to least significant bit).

For example, if `nums = [1, 0, 1]`:
- `x_0` = `1` (binary "1")
- `x_1` = `2` (binary "10")
- `x_2` = `5` (binary "101")

You must return an array `answer` where:

```text
answer[i] = true  if x_i is divisible by 5
answer[i] = false otherwise
```

Constraints:
- `1 <= nums.length <= 10^5`
- `nums[i]` is `0` or `1`

---

## üí° Intuition (hint first)

We are building a prefix binary number:

```text
x_0 = b0
x_1 = b0b1 (in binary)
x_2 = b0b1b2
...
```

If `x` is the value of the prefix up to `i-1`, then adding the next bit `b` gives:

```text
x_new % 5 = ( (x * 2 + b) % 5 )
```

Keeping only `x%5` at every step avoids big numbers and is 100% precise.

---


---

## ‚ö†Ô∏è What Was Wrong in My Original Solution

I wrote:

```ts
let num = 0;
for (let i = 0; i < n; i++) {
    num *= 2;
    if (nums[i] === 1) num++;
    answer[i] = (num % 5 === 0);
}
```

### Logical idea:

- Build the prefix `num` as an integer
- Check `num%5 === 0`

### The problem:

- `num` grows exponentially with `i`.
- JavaScript numbers are `IEEE 754` doubles and store integers exactly only up to `2^53`.
- With many bits (like the long test input), num becomes inexact.
- Once `num` is inexact, `num%5` is no longer reliable ‚Üí some prefixes that are divisible by 5 look like they are not (and vice versa).

### Conclusion:
The algorithmic idea was fine. The big-int / precision issue broke the answer.

---

## üçÉ Correct Approach ‚Äì Track Modulo Only

### Idea

We never need the full integer `x_i` ‚Äî we only need `x_i % 5`.

Maintain `rem` = `current prefix % 5`.

For each bit `b = nums[i]`:

```text
rem_new = (rem * 2 + b) % 5
```

Then:

```text
answer[i] = (rem_new === 0)
```

Since `rem` is always in `[0, 4]`, it never overflows and is always precise.

### Steps

1. Initialise `rem = 0`.
2. Loop `i` from `0` to `n-1`:
  - `rem = (rem * 2 + nums[i]) % 5`
  - `answer[i] = (rem === 0)`
3. Return `answer`.

---

## üßæ Code (TypeScript)

```ts
function prefixesDivBy5(nums: number[]): boolean[] {
    const n = nums.length;
    const answer = new Array<boolean>(n);
    let rem = 0; // prefix value modulo 5

    for (let i = 0; i < n; i++) {
        rem = (rem * 2 + nums[i]) % 5;
        answer[i] = (rem === 0);
    }

    return answer;
}
```

---

## ‚è±Ô∏è Complexity

We process each bit exactly once.

- Time: `O(n)`  
- Space: `O(n)` for the answer array, `O(1)` extra for the `rem` variable.

No large integers, no overflow, and 100% precise modulo tracking.

---
