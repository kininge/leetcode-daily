# ğŸ§© Problem #3432 â€“ Count Partitions with Even Sum Difference

**Difficulty:** Easy  
**Topics:** Prefix Sum, Math  
**Link:** https://leetcode.com/problems/count-partitions-with-even-sum-difference/

---

## ğŸ“ Problem Summary

You are given an array `nums` of length `n`.

A **partition** is an index `i` (0 â‰¤ i < n âˆ’ 1) that splits the array:

- Left  = nums[0..i]
- Right = nums[i+1..nâˆ’1]

We want to count how many partitions satisfy:
```text
(sum_left âˆ’ sum_right) is even
```

Return the count of such valid partitions.

---

## ğŸ’¡ Intuition

Let:

- `L = sum(nums[0..i])`
- `S = total sum of the array`
- Then `R = sum(nums[i+1..]) = S âˆ’ L`

The condition is:
```text
difference = L âˆ’ R = 2L âˆ’ S
difference must be even
```

Key insight:

- `2L` is always even.
- So `2L âˆ’ S` is even **iff `S` is even**.

This means:

> If the **total sum is odd**, **no** partition is valid.  
> If the **total sum is even**, **every** partition is valid.

---

## ğŸƒ Approach 1 â€” Prefix-Sum + Direct Difference Check

Steps:
1. Convert `nums` into its prefix-sum array.
2. For each partition index `i`, compute:
  ```text
    diff = 2 * prefix[i] - totalSum
  ```
3. If `diff` is even â†’ valid partition.

This is correct but performs unnecessary work.

---

## ğŸ§¾ Code â€” Approach 1 (Prefix-Sum)

```ts
function countPartitions(nums: number[]): number {
    const n = nums.length;

    // prefix sum
    for (let i = 1; i < n; i++) {
        nums[i] += nums[i - 1];
    }

    let partitions = 0;
    const total = nums[n - 1];

    for (let i = 0; i < n - 1; i++) {
        const difference = 2 * nums[i] - total;
        if (difference % 2 === 0) partitions++;
    }

    return partitions;
}
```

---

## ğŸŒ± Approach 2 â€” Observing the Parity Pattern

We use the fact:

```text
2L âˆ’ S is even â‡” S is even
```

So:

- If `totalSum` is **odd** â†’ answer is **0**
- If `totalSum` is **even** â†’ every partition `i = 0..n-2` works  
  â†’ There are `n âˆ’ 1` such partitions.

This avoids prefix sums entirely.

---

## ğŸ§¾ Code â€” Approach 2 (Optimal Math)

```ts
function countPartitions(nums: number[]): number {
    const total = nums.reduce((sum, x) => sum + x, 0);
    const n = nums.length;

    if (total % 2 !== 0) return 0;  // odd sum â†’ no valid partitions
    return n - 1;                   // even sum â†’ all partitions valid
}
```

---

## ğŸ“Š Complexity Comparison

| Approach | Time | Space | Notes |
|---------|------|--------|-------|
| Prefix Sum (Your original) | O(n) | O(1) | Correct, but unnecessary work |
| Math-only (Optimal) | O(n) | O(1) | Simplifies the parity logic completely |

Both solutions are correct â€” the math solution is simply cleaner.

---
