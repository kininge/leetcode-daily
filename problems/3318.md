# ğŸ§© Problem #3318 â€“ Find X Sum of All K Long Subarrays I

**Difficulty:** Easy  
**Topics:** `Array`, `Hash Map`, `Sliding Window`, `Sorting`   
**Link:** [Leetcode](https://leetcode.com/problems/find-x-sum-of-all-k-long-subarrays-i)

---

## ğŸ§  Problem Intuition

We are asked to find the **x-sum** of every contiguous subarray of length `k`.

The x-sum is defined as:
1. Count occurrences of each element in the subarray.
2. Keep only the top `x` most frequent elements.
   - If two elements have the same frequency, the **larger value** is considered more frequent.
3. Sum up all elements (frequency Ã— value) of those top `x` elements.

We must repeat this process for all subarrays of size `k`.

---

## âš™ï¸ Example

Input:  
`nums = [1,1,2,2,3,3]`, `k = 3`, `x = 2`

Subarrays of length 3:
1. [1,1,2] â†’ freq = {1:2, 2:1} â†’ top 2 â†’ sum = 1Ã—2 + 2Ã—1 = 4  
2. [1,2,2] â†’ freq = {1:1, 2:2} â†’ top 2 â†’ sum = 1Ã—1 + 2Ã—2 = 5  
3. [2,2,3] â†’ freq = {2:2, 3:1} â†’ sum = 2Ã—2 + 3Ã—1 = 7  
4. [2,3,3] â†’ freq = {2:1, 3:2} â†’ sum = 2Ã—1 + 3Ã—2 = 8  

Output: `[4, 5, 7, 8]`

---

## ğŸ§© Approach 1 â€“ Brute Force

### ğŸ’¡ Idea
For each window of length `k`,  
1. Build a frequency map of all elements.  
2. Sort elements by frequency (descending) and value (descending for ties).  
3. Take the top `x` and compute the weighted sum.

### ğŸ’» Code (Typescript)
```ts
function findXSum(nums: number[], k: number, x: number): number[] {
    const n = nums.length;
    const ans: number[] = [];

    for (let i = 0; i <= n - k; i++) {
        const freq = new Map<number, number>();

        // count frequencies in the current window
        for (let j = i; j < i + k; j++) {
            freq.set(nums[j], (freq.get(nums[j]) ?? 0) + 1);
        }

        let sum = 0;
        if (freq.size <= x) {
            for (const [num, count] of freq.entries()) sum += num * count;
        } else {
            const freqList = Array.from(freq.entries()).map(([num, count]) => [count, num]);

            freqList.sort((a, b) => {
                if (a[0] !== b[0]) return b[0] - a[0]; // higher frequency first
                return b[1] - a[1]; // for equal freq, higher number first
            });

            for (let i = 0; i < x; i++) {
                const [count, num] = freqList[i];
                sum += count * num;
            }
        }

        ans.push(sum);
    }

    return ans;
}
```

### ğŸ§® Complexity

- **Time:** `O((nâˆ’k+1) Ã— (k log k))`
- **Space:** `O(k)`

### âš ï¸ Drawbacks

- Rebuilds and sorts a new frequency map for every subarray window.
- Fine for small constraints, but inefficient for larger inputs.

---

## âš¡ Approach 2 â€“ Sliding Window + Frequency Array (Optimized)

### ğŸ’¡ Idea
Since all numbers are between 1 and 50,  
We can maintain a **frequency array** to count occurrences inside the sliding window.

When computing each x-sum:
- Build a list of all `(frequency, value)` pairs with frequency > 0.
- Sort them by:
  - **frequency descending**, and  
  - **value descending** (for ties).
- Pick top `x` entries and add `(frequency Ã— value)` for each.

This ensures we always pick the correct elements by the problemâ€™s definition.

### ğŸ’» Code
```ts
function findXSum(nums: number[], k: number, x: number): number[] {
    const n = nums.length;
    const ans: number[] = [];
    const freq = new Array(51).fill(0);

    //Initialise first window
    for (let i = 0; i < k; i++) freq[nums[i]]++;

    const calcXSum = (): number => {
        // Build (frequency, value) pairs
        const pairs: [number, number][] = [];
        for (let val = 1; val <= 50; val++) {
            if (freq[val] > 0) pairs.push([freq[val], val]);
        }

        // Sort by frequency (desc), then value (desc)
        pairs.sort((a, b) => {
            if (a[0] !== b[0]) return b[0] - a[0];
            return b[1] - a[1];
        });

        // Sum top x elements
        let taken = 0, sum = 0;
        for (const [count, val] of pairs) {
            if (taken >= x) break;
            sum += count * val;
            taken++;
        }
        return sum;
    };

    ans.push(calcXSum());

    // Slide the window
    for (let i = k; i < n; i++) {
        freq[nums[i - k]]--;
        freq[nums[i]]++;
        ans.push(calcXSum());
    }

    return ans;
}
```

### ğŸ§® Complexity

- **Time:** `O((nâˆ’k+1) Ã— 50 log 50)` â†’ effectively `O(n)`
- **Space:** `O(50)` â†’ constant

### âœ… Pros

- Correctly respects â€œfrequency-first, value-secondâ€ ranking.
- Still constant-time per window since 50 is tiny.
- Much cleaner and reliable for all test cases.

---

## ğŸ¯ Comparison

| Approach | Description | Time | Space | Notes |
|-----------|-------------|------|--------|--------|
| Brute Force | Build & sort new map for each window | O((nâˆ’k+1) Ã— k log k) | O(k) | Clear but redundant |
| Sliding Window | Maintain frequency array, O(1) updates | O(n Ã— 50) â‰ˆ O(n) | O(50) | Best for small value range |

---

âœ… **Key takeaway:**  
When values are bounded (`â‰¤50`), replace heavy sorting with a fixed-size frequency array + sliding window.  
Thatâ€™s the real optimisation trick here.

---
