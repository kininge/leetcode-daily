# ğŸ§© Problem #1351 â€“ Count Negative Numbers in a Sorted Matrix

**Difficulty:** Easy  
**Topics:** `Matrix`, `Binary Search`, `Two Pointers`  
**Link:** https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/

---

## ğŸ“ Problem Summary

You are given an `m x n` matrix `grid` where:

- Each row is sorted in **non-increasing** order (left â†’ right).
- Each column is sorted in **non-increasing** order (top â†’ bottom).

Your task is to count how many **negative numbers** exist in the matrix.

### Constraints
- `1 â‰¤ m, n â‰¤ 100`
- `-100 â‰¤ grid[i][j] â‰¤ 100`

### Follow-up
Can you solve it in **O(m + n)** time?

---

## ğŸ’¡ Intuition

The matrix has two important properties:

1. **Rows are sorted in non-increasing order**  
   â†’ Left to right values never increase.
2. **Columns are sorted in non-increasing order**  
   â†’ Top to bottom values never increase.

That means:
- Once you see a **negative number** in a row, **everything to the right is also negative**.
- Once you see a **negative number** in a column, **everything below is also negative**.

This gives us two natural approaches:

---

### ğŸ”¹ Approach 1 â€” Row-wise scanning (your solution)

Scan each row from left to right:
- When the first negative value appears at column `j`,
  - all columns `j ... m-1` are negative
  - add `(m - j)` to the answer
- Move to the next row

This avoids scanning unnecessary cells after the first negative in a row.

---

### ğŸ”¹ Approach 2 â€” Staircase walk (O(n + m))

Start from the **top-right corner** of the matrix:
- If the current value is **negative**:
  - then all values **below** it in that column are negative
  - add `(rows - currentRow)` to the count
  - move **left**
- If the current value is **non-negative**:
  - move **down**

This way:
- Each step moves either **left** or **down**
- Total moves â‰¤ `n + m`

This achieves the optimal time complexity asked in the follow-up.

---

## ğŸƒ Approach 1 â€” Scan Rows with Early Break (O(m Ã— n))

### Idea

Each row is sorted in **non-increasing order**.

So in a row:
- All non-negative values come **before** negative values.
- Once we encounter the **first negative**, every element to its right is also negative.

### Steps

1. Iterate row by row.
2. For each row, scan from left to right.
3. When `grid[i][j] < 0`:
   - All elements from `j` to `m-1` are negative.
   - Add `(m - j)` to the count.
   - Break out of the current row.

### Code

```ts
function countNegatives(grid: number[][]): number {
    const n = grid.length;
    const m = grid[0].length;

    let count = 0;

    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            if (grid[i][j] < 0) {
                count += (m - j);
                break;
            }
        }
    }

    return count;
}
```

### Why it works

- Sorting property lets us skip unnecessary checks.
- In the worst case (no negatives), we scan the full matrix.
- Simple, readable, and passes constraints easily.

---

## ğŸ§¾ Code â€” Approach 2 (Staircase / Bottom-Left Walk)

```ts
function countNegatives(grid: number[][]): number {
    const n = grid.length;
    const m = grid[0].length;

    let row = n - 1;   // start from bottom-left
    let col = 0;
    let count = 0;

    while (row >= 0 && col < m) {
        if (grid[row][col] < 0) {
            // all elements to the right in this row are also negative
            count += (m - col);
            row--; // move up
        } else {
            col++; // move right
        }
    }

    return count;
}
```

### Why this works

- The matrix is sorted non-increasingly both row-wise and column-wise.
- Starting from the bottom-left corner:

  - If the current value is negative â†’ everything to its right is also negative.
  - If itâ€™s non-negative â†’ everything above is also non-negative.

- Each step moves either up or right, so we never revisit a cell.

### Complexity

- **Time:** `O(n + m)`
- **Space:** `O(1)`

This is the optimal solution and answers the follow-up directly.

---

## â± Complexity Analysis

### Approach 1 â€” Row-wise Scan (Your Solution)

- **Time Complexity:** `O(m * n)`
  - In the worst case (no negatives until the end), each row scans all `n` columns.
- **Space Complexity:** `O(1)`
  - Only a counter variable is used.

This approach is simple and efficient enough for given constraints (`m, n â‰¤ 100`), and it smartly skips the rest of the row once a negative is found.

---

### Approach 2 â€” Staircase Traversal (Optimal Follow-up)

- **Time Complexity:** `O(m + n)`
  - Start from the **top-right corner** and move:
    - left when the value is negative,
    - down when the value is non-negative.
  - Each row and column is visited at most once.
- **Space Complexity:** `O(1)`
  - Uses constant extra space.

This approach leverages the **sorted row-wise and column-wise** property fully and satisfies the follow-up requirement.

---

### When to use which?

- Use **Approach 1** when:
  - Constraints are small (as here),
  - You want simpler, more readable code.

- Use **Approach 2** when:
  - The problem explicitly asks for optimal `O(m + n)`,
  - Or constraints are large and performance matters.

---

### Key Insight

The matrix being sorted in **both directions** allows you to:
- Either break early per row (Approach 1),
- Or traverse it like a staircase (Approach 2) for linear time.

Both are correct â€” the second is just more elegant algorithmically.

---
