# ğŸ§© Problem #1526 â€“ Minimum Number of Increments on Subarrays to Form a Target Array

**Difficulty:** Hard  
**Topics:** `Greedy`, `Array`, `Difference Array`  
**Link:** [Leetcode](https://leetcode.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array)

---


## ğŸ§  Problem Intuition

We start with an array of all zeros and can increment **any subarray** by `+1` per operation.  
We need the *minimum number of such operations* to form the `target` array.

You can visualise this like **building histograms** â€” each numberâ€™s height shows how tall a column is.  
The trick lies in realizing when a *new set of increments* must start.

---

## âš™ï¸ Example

Input:  
`target = [3, 1, 5, 4, 2]`

Visualization:

```text
//         5
//         4 4
//     2   4 4
//     2   3 3 3
//     1 1 1 1 1
//   -------------
//   [ 3 1 5 4 2 ]
```

**Output: ** `7`

---

## ğŸ§© Approach 1: Brute Force (Histogram Layer Counting)

### ğŸ’¡ Idea
Treat each level (height) of the histogram separately.  
For every height from 1 â†’ max(target),  
count how many **continuous groups** of bars reach at least that height.

Each group = one subarray increment operation.

---

### ğŸ§¾ Steps
1. Find the maximum number in `target`.  
2. For each level `h` from `1` to `maxNum`,  
   scan the entire array and count how many contiguous batches are â‰¥ `h`.  
3. Sum them all â€” thatâ€™s the total number of operations.

---

### ğŸ§® Complexity
- **Time:** O(n Ã— max(target)) â†’ âŒ *TLE for large input*  
- **Space:** O(1)

---

### ğŸ’» Code (Typescript)
```Typescript[]
function minNumberOperations(target: number[]): number {
    let maxNum = target.reduce((red, num) => Math.max(red, num));
    let operations = 1; // minimum value 1

    for (let h = 2; h <= maxNum; h++) {
        let inBatch = false;
        for (let i = 0; i < target.length; i++) {
            const num = target[i];

            if (num >= h) {
                if (!inBatch) inBatch = true;
            }

            if (num < h || i === target.length - 1) {
                if (inBatch) {
                    inBatch = false;
                    operations++;
                }
            }
        }
    }

    return operations;
}
```

---

## âš¡ Approach 2: Optimized (Greedy â€“ Track Increases Only)

### ğŸ’¡ Idea
Instead of scanning level by level, just notice **when the height increases**.

If `target[i] > target[i-1]`,  
it means we must perform `(target[i] - target[i-1])` *new* operations starting from that point.  
If the height decreases, we donâ€™t add anything â€” the previous operations already covered it.

So total operations =  
`target[0] + sum(max(0, target[i] - target[i-1]))`

---

### ğŸ§¾ Steps
1. Start with `ops = target[0]`.  
2. For each index `i > 0`,  
   - If `target[i] > target[i-1]`, add the difference.  
   - Else, skip.  
3. Return `ops`.

---

### ğŸ§® Complexity
- **Time:** O(n)  
- **Space:** O(1)

---

### ğŸ’» Code (Typescript)
```Typescript[]
function minNumberOperations(target: number[]): number {
    let ops = target[0];

    for (let i = 1; i < target.length; i++) {
        if (target[i] > target[i - 1]) {
            ops += target[i] - target[i - 1];
        }
    }

    return ops;
}
```

---

## ğŸ¯ Comparison

| Approach | Idea | Time | Space | Works For Large n |
|-----------|------|------|--------|-------------------|
| Brute Force | Count histogram layers | O(n Ã— max) | O(1) | âŒ No |
| Optimized | Add only height differences | O(n) | O(1) | âœ… Yes |

---

## ğŸ’¬ Common Mistake
Beginners often simulate *each increment* or *each height level*,  
missing that **only upward changes** in the array contribute to the final count.

---
