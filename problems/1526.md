# 🧩 Problem #1526 – Minimum Number of Increments on Subarrays to Form a Target Array

**Difficulty:** Hard  
**Topics:** `Greedy`, `Array`, `Difference Array`  
**Link:** [Leetcode](https://leetcode.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array)

---


## 🧠 Problem Intuition

We start with an array of all zeros and can increment **any subarray** by `+1` per operation.  
We need the *minimum number of such operations* to form the `target` array.

You can visualise this like **building histograms** — each number’s height shows how tall a column is.  
The trick lies in realizing when a *new set of increments* must start.

---

## ⚙️ Example

Input:  
`target = [3, 1, 5, 4, 2]`

Visualization:

```text
//         5
//         4 4
//     2   4 4
//     2   3 3 3
//     1 1 1 1 1
//   -------------
//   [ 3 1 5 4 2 ]
```

**Output: ** `7`

---

## 🧩 Approach 1: Brute Force (Histogram Layer Counting)

### 💡 Idea
Treat each level (height) of the histogram separately.  
For every height from 1 → max(target),  
count how many **continuous groups** of bars reach at least that height.

Each group = one subarray increment operation.

---

### 🧾 Steps
1. Find the maximum number in `target`.  
2. For each level `h` from `1` to `maxNum`,  
   scan the entire array and count how many contiguous batches are ≥ `h`.  
3. Sum them all — that’s the total number of operations.

---

### 🧮 Complexity
- **Time:** O(n × max(target)) → ❌ *TLE for large input*  
- **Space:** O(1)

---

### 💻 Code (Typescript)
```Typescript[]
function minNumberOperations(target: number[]): number {
    let maxNum = target.reduce((red, num) => Math.max(red, num));
    let operations = 1; // minimum value 1

    for (let h = 2; h <= maxNum; h++) {
        let inBatch = false;
        for (let i = 0; i < target.length; i++) {
            const num = target[i];

            if (num >= h) {
                if (!inBatch) inBatch = true;
            }

            if (num < h || i === target.length - 1) {
                if (inBatch) {
                    inBatch = false;
                    operations++;
                }
            }
        }
    }

    return operations;
}
```

---

## ⚡ Approach 2: Optimized (Greedy – Track Increases Only)

### 💡 Idea
Instead of scanning level by level, just notice **when the height increases**.

If `target[i] > target[i-1]`,  
it means we must perform `(target[i] - target[i-1])` *new* operations starting from that point.  
If the height decreases, we don’t add anything — the previous operations already covered it.

So total operations =  
`target[0] + sum(max(0, target[i] - target[i-1]))`

---

### 🧾 Steps
1. Start with `ops = target[0]`.  
2. For each index `i > 0`,  
   - If `target[i] > target[i-1]`, add the difference.  
   - Else, skip.  
3. Return `ops`.

---

### 🧮 Complexity
- **Time:** O(n)  
- **Space:** O(1)

---

### 💻 Code (Typescript)
```Typescript[]
function minNumberOperations(target: number[]): number {
    let ops = target[0];

    for (let i = 1; i < target.length; i++) {
        if (target[i] > target[i - 1]) {
            ops += target[i] - target[i - 1];
        }
    }

    return ops;
}
```

---

## 🎯 Comparison

| Approach | Idea | Time | Space | Works For Large n |
|-----------|------|------|--------|-------------------|
| Brute Force | Count histogram layers | O(n × max) | O(1) | ❌ No |
| Optimized | Add only height differences | O(n) | O(1) | ✅ Yes |

---

## 💬 Common Mistake
Beginners often simulate *each increment* or *each height level*,  
missing that **only upward changes** in the array contribute to the final count.

---
