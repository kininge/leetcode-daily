# 🧩 Problem #869 - Reordered Power of 2

**Difficulty:** Medium  
**Topics:**  `Array`, `Bit Manipulation`, `Hash Map`  
**Link:** [Leetcode](https://leetcode.com/problems/reordered-power-of-2/description/)

## 🧠 Intuition

We need to check if we can **reorder the digits** of n to form a power of two.  
Directly generating permutations is expensive (O(k!) for k digits), so we need a smarter check.

---

### Key Observations
1. Please try problem [231. Power of Two](https://leetcode.com/problems/power-of-two/description/) before solving this
    - we saw that n = 2^x means n has only 1 set bit in binary.
2. **Finite possibilities**  
   - For $$1 ≤ n ≤ 10^9$$, the largest power of 2 is $$2^{29} = 536,870,912$$  
   - There are 30 possible numbers for $$n = 2^x$$ in this range of $$1 <= n <= 10^9$$.
   
![Screenshot 2025-08-10 at 5.58.25 PM.png](https://assets.leetcode.com/users/images/a3b7fe8b-2956-404d-a182-e9ea6e192a8d_1754829655.3087282.png)

3. **Generate unique key from digits**  
   - If two numbers have exactly the same digits in any order, their digit frequency is identical.  
   - Example: 128 and 281 → both have {1:1, 2:1, 8:1}.
   - We can exactly compare that unique key from digits

---

## 💡 Approach

### Step 1 — Represent number as a digit frequency signature
**Example**:
128 → freq: [0,1,1,0,0,0,0,0,1,0]
812 → same freq

We encode this array as a short string key like:"0,1,1,0,0,0,0,0,1,0"

### Step 2 — Precompute all signatures of powers of 2 in range
Loop i from 0 to 29:
- Compute 1 << i
- Build its frequency unique key for all possible n = 2^x
- Store in a Set

### Step 3 — Genearte frequency unique key for n and check with possible numbers

---

## ⏱ Complexity

- **Precomputation:** O(30 × k) where k ≤ 10 digits  
- **Per check:** O(k)  
- **Space:** O(30) signatures

---

## 📝 Code — 

### 1. Frequency Encoding

```javascript []
    var reorderedPowerOf2 = function(n) {
        // Encode a number into digit frequency signature
        const encodeFreq = (num) => {
            const freq = new Array(10).fill(0); // O(10)
            while (num > 0) {
                freq[num % 10]++;
                num = Math.floor(num / 10);
            }
            return freq.join(','); // compact signature string
        };

        // Precompute signatures of all powers of 2 up to 1e9
        const possible = new Set();
        for (let i = 0; i < 30; i++) {
            possible.add(encodeFreq(1 << i));
        }

        // Check if n matches any power-of-2 signature
        return possible.has(encodeFreq(n));
    };
```


### 2. Sorting Digits

```javascript []
    var reorderedPowerOf2 = function(n) {
        const sortDigits = (num) => num.toString().split('').sort().join('');
        const target = sortDigits(n);
        
        const powerSet = new Set();
        for (let i = 0; i < 31; i++) {
            powerSet.add(sortDigits(1 << i));
        }

        return powerSet.has(target);
    };
```

- Simpler to write
- Uses $$O(k log k)$$ sort per encoding (still very fast for $$k ≤ 10$$)
- Highly optimized in JS engines like V8

---

## 🎯 Takeaways

- Converting inputs to normalized frequency unique key is a powerful trick for rearrangement problems (similar to anagram checks).
- Constraint analysis $$(1 ≤ n ≤ 10^9)$$ helps find finite search space.
- The 1 set bit property from [231. Power of Two](https://leetcode.com/problems/power-of-two/description/) problems doesn’t work here because digit rearrangement changes the binary representation.
