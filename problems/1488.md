# 🧩 Problem #1488 – Avoid Flood in The City

**Difficulty:** Medium  
**Topics:** `Greedy`, `Hash Map`, `Binary Search`, `Simulation`  
**Link:** [LeetCode](https://leetcode.com/problems/avoid-flood-in-the-city/)

---

## 📜 Problem Summary
You are given an integer array `rains` where:

- `rains[i] > 0` → it rains on lake `rains[i]`.
- `rains[i] == 0` → no rain; you can **choose one lake to dry**.

If it rains on a lake that is already full, the city floods 🌊.  
Return an array `ans` where:
- `ans[i] = -1` if it rains on that day.
- `ans[i] = x` if you choose to dry lake `x` on that day.
If it's impossible to avoid flooding, return an empty array `[]`.

---

## 💡 Approach 1 – Brute Force (O(N²))

### 🧩 Idea
Simulate the process directly:
1. Maintain a `Set` of filled lakes.
2. On a dry day (`rains[i] == 0`):
   - Look **ahead** in the array to find which filled lake will rain next.
   - Dry that one to prevent the nearest flood.
3. If a rain occurs on a lake that’s already full → flood → return `[]`.

### 🧮 Complexity
| Metric | Value |
|---------|--------|
| Time | **O(N²)** (because we scan ahead for every dry day) |
| Space | **O(N)** (to track filled lakes) |

---

### 💻 Code
```Typescript []
function avoidFlood(rains: number[]): number[] {
    const ans: number[] = new Array(rains.length).fill(null);
    const filledLakes: Set<number> = new Set();

    for(let i=0; i<rains.length; i++){
        const lake: number = rains[i];

        // dry day
        if(lake === 0){
            // if nothing to dry
            if(filledLakes.size === 0) ans[i] = 1;
            // searching the immediate lake that will be flooded
            else{
                let _lake = null;
                for(let j=(i+1); j<rains.length; j++){
                    if(filledLakes.has(rains[j])){
                        _lake = rains[j];
                        break;
                    }
                }
                
                // we can dry any lake
                if(_lake === null){
                    for(const filledLake of filledLakes){
                        _lake = filledLake;
                        break;
                    }
                }

                // dry lake
                ans[i] = _lake;
                filledLakes.delete(_lake);
            }
        }
        // rain day
        else { 
            ans[i] = -1;

            // lake is empty
            if(!filledLakes.has(lake)) filledLakes.add(lake);
            // city floded
            else return [];
        }
    }

    return ans;
};
```

---

## 💡 Approach 2 – Optimized Greedy + Binary Search (O(N log N))

### 🧩 Idea

1. Think “dry just in time”, not “dry everything now.”

2. Keep a Map → lastRain[lake] = last day it rained.

3. Maintain a sorted list of dry-day indices.

For each rain on lake `x`:
  - If it’s the first time → mark full.
  - Else → find the earliest dry day after its last rain (using binary search).
  - If found → use that dry day to dry lake `x`.
  - Else → no available dry day → flood → `[]`.

### 🧮 Complexity


| Metric | Value |
|---------|--------|
| Time |	O(N log N) (binary search per rain) |
| Space |	O(N) |

### 💻 Code

```Typescript []
function avoidFlood(rains: number[]): number[] {
    const days: number = rains.length;

    const ans: number[] = new Array(days).fill(1); // default 1 for unused dry days
    const lastRainyDay: Map<number, number> = new Map(); // Map<lake, rainyDay>
    let dryDays: number[] = []; // sorted indices of dry days

    // binery search dry day just after 'lastRainyDayIndex'
    function searchDryDay(lastRainyDayIndex: number): number{

        let dryDayIndex: number = -1;
        // edge case
        if(dryDays.length === 0) return dryDayIndex;

        let leftIndex: number = 0; 
        let rightIndex: number = dryDays.length - 1;
        while (leftIndex <= rightIndex) {
            const midIndex: number = Math.floor((leftIndex + rightIndex)/2);
            const _dryDayIndex: number = dryDays[midIndex];

            if (_dryDayIndex > lastRainyDayIndex) { 
                dryDayIndex = midIndex; 
                rightIndex = midIndex-1;
            }
            else leftIndex = midIndex+1;
        }

        return dryDayIndex;
    }

    for(let i=0; i<days; i++) {
        const lake: number = rains[i];

        // dry day
        if (lake === 0){
            if(lastRainyDay.size > 0) dryDays.push(i);
        } 
        else {
            ans[i] = -1; // rain day must be -1

            // flood condition
            if (lastRainyDay.has(lake)) {
                const lastRainyDayIndex: number = lastRainyDay.get(lake);
                const dryDayIndex: number = searchDryDay(lastRainyDayIndex);
                

                // no option city will be flooded
                if(dryDayIndex === -1) return [];
                
                const rightDryDayIndexToDry: number = dryDays[dryDayIndex];
                ans[rightDryDayIndexToDry] = lake; // dry the 'lake' by right dry day
                // remove used dry day from avaiable dry day list
                dryDays.splice(dryDayIndex, 1); // at worst case can go to O(n)
            }

            // handled flood condition
            lastRainyDay.set(lake, i);
        }
    }

    return ans;
}
```

---

## 🔍 Comparison of Both Approaches

| Feature |	Brute Force |	Optimized (Greedy + Binary Search) |
| --- | --- | --- |
| Logic |	Scan future to pick dry lake |	Use map + binary search just-in-time |
| Time Complexity |	O(N²) |	O(N log N) |
| Space Complexity |	O(N) |	O(N) |
| Readability |	Intuitive |	Slightly more technical |
| Passes Constraints |	❌ TLE | ✅ Accepted |

---

## 🏆 Final Notes

- The problem is a planning problem — you must “schedule” drying just before the next rain.
- Using a sorted list (or TreeSet / BST in other languages) ensures we always pick the optimal dry day.
- Avoid operations like `slice` or repeated array copies — use `splice()` for in-place removal.

> 💬 Greedy rule: “Always dry the lake that will flood first — just in time.”
