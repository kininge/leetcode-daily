# ðŸ§© 3027. Find the Number of Ways to Place People II

**Difficulty:** Hard  
**Tags:** Geometry, Sorting, Greedy

---

## ðŸ§  Intuition

Similar to 3025, but now:
- `n â‰¤ 1000`, coordinates up to `1e9`.
- A naive O(nÂ³) scan is impossible.
- Need a greedy sweep approach.

Key idea:

- Sort points by x ascending, and if tie, by y descending.
- For each Alice candidate (xi, yi), iterate Bobs (xj, yj) with j > i.
- Maintain a max value tracking the highest valid y so far.
- Only count (i, j) if yi >= yj && yj > max.

This ensures the rectangle (A, B) is empty.

---

## ðŸ’¡ Approach 1 â€” Sorting + Greedy O(nÂ²)

1. Sort points by (x asc, y desc).
2. For each Alice (xi, yi):
* * Set max = -âˆž.
* * For each Bob (xj, yj) with j > i:
* * * If yi >= yj && yj > max:
* * * * Count the pair.
* * * * Update max = yj.

```javascript []
var numberOfPairs = function(points) {
    let n = points.length;
    let ans = 0;

    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            if (points[i][0] < points[j][0] && points[i][1] < points[j][1]) {
                let valid = true;
                for (let k = 0; k < n; k++) {
                    if (k === i || k === j) continue;
                    let [x, y] = points[k];
                    if (points[i][0] <= x && x <= points[j][0] &&
                        points[i][1] <= y && y <= points[j][1]) {
                        valid = false;
                        break;
                    }
                }
                if (valid) ans++;
            }
        }
    }
    return ans;
};
```

### Complexity:

- Time = O(nÂ³), 
- Space = O(1).

---

## Approach 2 â€” Prefix Sum Grid O(nÂ²)

- 1. Build a `51Ã—51` binary grid where `grid[x][y] = 1` if point exists.
- 2. Precompute 2D prefix sums.
- 3. For each pair (A, B):
- - Query rectangle [xA, xB] Ã— [yA, yB] in O(1).
- - If total points = 2 â†’ valid. 

```javascript []
var numberOfPairs = function(points) {
    points.sort((a, b) => a[0] - b[0]); // sort by x
    let n = points.length, ans = 0;

    for (let i = 0; i < n; i++) {
        for (let j = i+1; j < n; j++) {
            if (points[i][0] < points[j][0] && points[i][1] < points[j][1]) {
                let valid = true;
                for (let k = i+1; k < j; k++) {
                    let [x, y] = points[k];
                    if (points[i][0] <= x && x <= points[j][0] &&
                        points[i][1] <= y && y <= points[j][1]) {
                        valid = false;
                        break;
                    }
                }
                if (valid) ans++;
            }
        }
    }
    return ans;
};
```
### Complexity:

- where C=50
- Time = O(nÂ² + CÂ²) ~= O(nÂ²)
- Space = O(CÂ²) ~= O(1)

---

### âœ… Approach 3 â€” Grid Sweep O(1)

- 1. Traverse the grid row by row.
- 2. Maintain horizontal depth counters (distance since last point).
- 3. When encountering a new point, check downward in column with pruning.
- 4. Because C=50 is fixed, this is constant time. 

```javascript []
var numberOfPairs = function(points) {
    const MAX = 51;
    let grid = Array.from({ length: MAX+1 }, () => new Array(MAX+1).fill(0));

    // mark points
    for (const [x, y] of points) grid[x][y] = 1;

    // build prefix sum
    for (let i = 0; i <= MAX; i++) {
        for (let j = 1; j <= MAX; j++) {
            grid[i][j] += grid[i][j-1];
        }
    }
    for (let j = 0; j <= MAX; j++) {
        for (let i = 1; i <= MAX; i++) {
            grid[i][j] += grid[i-1][j];
        }
    }

    let ans = 0;
    let n = points.length;

    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            let [x1, y1] = points[i];
            let [x2, y2] = points[j];
            if (x1 < x2 && y1 < y2) {
                // count points in rectangle [x1, x2] Ã— [y1, y2]
                let total = grid[x2][y2]
                          - grid[x1-1]?.[y2] ?? 0
                          - grid[x2][y1-1] ?? 0
                          + grid[x1-1]?.[y1-1] ?? 0;
                if (total === 2) ans++; // only A and B exist
            }
        }
    }
    return ans;
};
```

### Complexity:

- C = 50
- Time = O(CÂ³) ~= O(1) 
- Space = O(CÂ²) ~= O(1)

---

## ðŸ“Š Comparison  

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Brute Force | O(nÂ³) | O(1) | Simplest and direct |
| Strict Prefix Sum | O(nÂ²) | O(1) | Best mix of clarity + speed |
| Grid Sweep | O(1) | O(1) | Overkill but elegant, coordinate-bound |
