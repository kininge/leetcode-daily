# ðŸ§© Problem 611 - Valid Triangle Number

**Difficulty:** Medium
**Tags:** Two Pointers, Sorting, Binary Search, Combinatorics
**Link:** [LeetCode](https://leetcode.com/problems/valid-triangle-number/description/)    

---

## ðŸ§  Intuition

Sort the array. For any triple with indices `i < j < k` we get a = `nums[i] â‰¤ nums[j] â‰¤ nums[k]`.    
They form a valid triangle if `a + b > c`.    
Sorting makes sums monotonic so we can prune and count efficiently.   

---

## ðŸ’¡ Approach 1 - Brute-force (Triple loop) â€” O(nÂ³) worst

- Sort nums.
- Try every triple `(i, j, k)` with `i < j < k`.
- Count triples where `nums[i] + nums[j] > nums[k]`.
- Micro-optimization: for fixed `i`, `j`, once `nums[k]` is too large, further k are also too large â†’ break the innermost loop.

```typescript []
// Brute-force: check all triplets
function triangleNumberBrute(nums: number[]): number {
  const n = nums.length;
  if (n < 3) return 0;
  nums.sort((a, b) => a - b);

  let count = 0;
  for (let i = 0; i < n - 2; i++) {
    for (let j = i + 1; j < n - 1; j++) {
      for (let k = j + 1; k < n; k++) {
        if (nums[i] + nums[j] > nums[k]) count++;
        else break; // because array is sorted, further k will only get larger
      }
    }
  }
  return count;
}
```

## ðŸ’¡ Approach 2 - Binary-search per pair â€” O(nÂ² log n)

- Sort nums.
- For each pair `(i, j)` with `i <= j`, compute target = `nums[i] + nums[j]`.
- Binary-search the rightmost index `k > j` such that nums[k] < target.
- Add `(k - j)` to the answer `(if k >= j+1)`.

```typescript []
// For each pair (i, j), find the largest k with nums[k] < nums[i] + nums[j]
// and add (k - j)
function triangleNumberBinary(nums: number[]): number {
  const n = nums.length;
  if (n < 3) return 0;
  nums.sort((a, b) => a - b);

  let count = 0;

  // helper: returns largest index in [lo..hi] with nums[idx] < target
  function findLastLessThan(lo: number, hi: number, target: number): number {
    let left = lo, right = hi, ans = lo - 1;
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      if (nums[mid] < target) {
        ans = mid;
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    return ans;
  }

  for (let i = 0; i < n - 2; i++) {
    for (let j = i + 1; j < n - 1; j++) {
      const target = nums[i] + nums[j];
      const k = findLastLessThan(j + 1, n - 1, target);
      if (k >= j + 1) count += (k - j);
    }
  }

  return count;
}
```

## ðŸ’¡ Approach 3 â€” Two-pointer optimal

- Sort nums.
- Fix k from right to left as the largest side.
- Maintain `left = 0`, `right = k-1`.
  - If `nums[left] + nums[right] > nums[k]`, then all pairs `(left..right-1, right)` are valid â†’ add `(right - left)` to count and `right--`.
  - Else `left++`.

```typescript []
// Optimal two-pointer approach: fix largest side at k and count pairs (left, right)
function triangleNumberTwoPointer(nums: number[]): number {
  const n = nums.length;
  if (n < 3) return 0;
  nums.sort((a, b) => a - b);

  let count = 0;
  for (let k = n - 1; k >= 2; k--) {
    let left = 0;
    let right = k - 1;
    while (left < right) {
      if (nums[left] + nums[right] > nums[k]) {
        // all indices in [left, right-1] with this right are valid pairs
        count += (right - left);
        right--;
      } else {
        left++;
      }
    }
  }
  return count;
}
```
---

## ðŸ“Š Complexity
| Approach	| Time Complexity	| Space Complexity
| -------- | -------- | -------- |
| Brute-force (Triple loop) |	`O(nÂ³)` |	`O(1)` |
| Binary-search per pair |	`O(nÂ² log n)` |	`O(1)` |
| Two-pointer |	`O(nÂ²)` |	`O(1)` |

- All approaches pay `O(n log n)` for the initial sort.


