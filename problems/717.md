# ğŸ§© Problem #717 â€“ 1 bit and 2 bit Characters

**Difficulty:** Easy  
**Topics:** `Array`, `Bit Manipulation`  
**Link:** https://leetcode.com/problems/1-bit-and-2-bit-characters/

---

## ğŸ“ Problem Summary

We have two character encodings:

- A 1-bit character: `0`
- A 2-bit character: `10` or `11`

Given a binary array `bits` that **always ends with 0**, determine whether the final character is a 1-bit character.  
Return `true` if the last character must be a 1-bit character, otherwise return `false`.

---

## ğŸ’¡ Intuition

**Hint:** Count the number of consecutive `1`s immediately before the final `0`.  
- If that count is **even**, the final `0` stands alone â†’ **true**.  
- If the count is **odd**, the final `0` is part of a two-bit char â†’ **false**.

Why that works: two-bit chars start with `1`. Pairs of consecutive `1`s form complete 2-bit characters; an extra single `1` makes the final `0` get paired.

---

## ğŸƒ Approach 1 â€” Simulation (Cleaned)

### Idea
Simulate walking through the array:
- `0` â†’ move +1
- `1` â†’ move +2

If you land exactly on the last index, the final character is 1-bit.

### Complexity
- Time: `O(n)`  
- Space: `O(1)`

### Code (Typescript)
```ts
function isOneBitCharacter(bits: number[]): boolean {
    const n = bits.length;
    let index = 0;

    while (index < n) {
        if (index === n - 1) return true;
        index += bits[index] === 1 ? 2 : 1;
    }
    return false;
}
```

---

## ğŸ€ Approach 2 â€” Count Trailing 1s (Optimal)

### Idea
Only the run of `1`s immediately before the final `0` matters.  
Count them from the penultimate index leftwards; even â†’ true, odd â†’ false.

### Complexity
- Time: `O(n)`  
- Space: `O(1)`

### Code (Typescript)
```ts 
function isOneBitCharacter(bits: number[]): boolean {
    let i = bits.length - 2; // start before the guaranteed final 0
    let count = 0;

    while (i >= 0 && bits[i] === 1) {
        count++;
        i--;
    }

    return count % 2 === 0;
}
```

---

## ğŸ†š Comparison

| Feature | Simulation (Approach 1) | Count Trailing 1s (Approach 2) |
|--------|--------------------------|---------------------------------|
| Method | Walk through bytes | Inspect only trailing ones |
| Time | O(n) | O(n) |
| Space | O(1) | O(1) |
| Readability | Very explicit | Shorter, slightly trickier |

---
