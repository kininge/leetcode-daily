# 🧩 Problem #3289 – The Two Sneaky Numbers of Digitville

**Difficulty:** Easy  
**Topics:** `Array`, `Hash Map`, `Sorting`  
**Link:** [Leetcode](https://leetcode.com/problems/the-two-sneaky-numbers-of-digitville/description)

---

## 🧠 Problem Statement

In the town of Digitville, there was a list of numbers called `nums` containing integers from `0` to `n - 1`. Each number was supposed to appear exactly once in the list; however, two mischievous numbers sneaked in an additional time, making the list longer than usual.

Return an array of size two containing the two repeated numbers (in any order).

**Constraints:**
- `2 <= n <= 100`
- `nums.length == n + 2`
- `0 <= nums[i] < n`
- `nums` contains exactly two repeated elements.

---

## 🧠 Intuition

Because the values are in range `[0, n-1]` and the array length is `n+2`, exactly two values repeat.  
Common strategies:
- Brute-force check pairs.
- Sort and find adjacent equals.
- Use a hash set to detect duplicates in one pass.

The best practical approach here is the hash set — O(n) time, O(n) space — small `n` makes sorting also acceptable.

---

## ⚙️ Example

Input:  
`nums = [2, 1, 3, 0, 2, 3]`

Output:  
`[2, 3]` (order can be any)

Explanation: 2 and 3 appear twice.

---

## 🧩 Approach 1: Brute Force

### Idea
Check every pair — if equal, record the value. Stop when two repeats are found.

### Complexity
- **Time:** `O(n²)` 
- **Space:** `O(1)`

### Code (TypeScript)
```ts
function getSneakyNumbers(nums: number[]): number[] {
    const n: number = nums.length;
    const ans: number[] = [];
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            if (nums[i] === nums[j]) {
                ans.push(nums[i]);
                break;
            }
        }
        if (ans.length === 2) return ans;
    }
    return ans;
}
```

---

## 🧩 Approach 2: Sorting

### Idea
Sort the array and scan for adjacent equal elements — each adjacent equal is a repeat.

### Complexity
- **Time:** `O(n log n)` due to sort  
- **Space:** `O(1)` or `O(n)` depending on sort implementation (in-place JS sort mutates array)

### Code (TypeScript)
```ts
function getSneakyNumbers(nums: number[]): number[] {
    nums.sort((a, b) => a - b);
    const ans: number[] = [];
    for (let i = 1; i < nums.length; i++) {
        if (nums[i] === nums[i - 1]) ans.push(nums[i]);
        if (ans.length === 2) return ans;
    }
    return ans;
}
```

---

## ⚡ Approach 3: Hash Set (Recommended)

### Idea
Scan once, keep seen values in a `Set`. When a value is already in the set, it's one of the sneaky numbers.

### Complexity
- **Time:** `O(n)`  
- **Space:** `O(n)`

### Code (TypeScript)
```ts
function getSneakyNumbers(nums: number[]): number[] {
    const seen: Set<number> = new Set();
    const ans: number[] = [];

    for (const num of nums) {
        if (seen.has(num)) {
            ans.push(num);
            if (ans.length === 2) return ans;
        } else {
            seen.add(num);
        }
    }

    return ans;
}
```

---

## 🎯 Comparison

| Approach     | Time      | Space   | Notes                          |
|--------------|-----------|---------|--------------------------------|
| Brute Force  | O(n²)     | O(1)    | Simple, but slow               |
| Sorting      | O(n log n)| O(1)    | Fast enough for small n, mutates input |
| Hash Set     | O(n)      | O(n)    | Best practical choice here     |

---


