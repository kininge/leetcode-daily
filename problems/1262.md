# ğŸ§© Problem #1262 â€“ Greatest Sum Divisible by Three

**Difficulty:** Medium  
**Topics:** `Dynamic Programming`, `Greedy`, `Math`, `Array`  
**Link:** https://leetcode.com/problems/greatest-sum-divisible-by-three/

---

## ğŸ“ Problem Summary

You are given an integer array `nums`.

Your task is to select some (possibly all) elements of `nums` such that:

- The sum of the selected elements is **divisible by 3**
- The sum is **as large as possible**

Return that **maximum possible sum**.

Constraints:

- `1 <= nums.length <= 4 * 10^4`
- `1 <= nums[i] <= 10^4`

---

## ğŸ’¡ Intuition (Hint-first)

Think in terms of **sum modulo 3**.

1. Compute:
   ```text
   total = sum(nums)
   r = total % 3
   ```
2. If `r == 0`, we are already done: `total` is divisible by `3`.
3. If `r != 0`, we must remove some elements to adjust the sum:
  - Let removedSum be the sum of elements we remove.
  - We need:
  ```text
  (total - removedSum) % 3 == 0
  âŸº removedSum % 3 == total % 3
  ```
3. And we want (total-removedSum) as large as possible â†’
   i.e., `removedSum` as small as possible.

Because modulo is `3`, there are only 2 interesting nonzero remainders: `1` and `2`.

---

## Key observation

We never need to remove more than two numbers:

- If `total % 3 == 1`:
  - Remove one number with `num % 3 == 1`
    - (removedSum â‰¡ 1 mod 3), or
  - Remove two numbers with `num % 3 == 2`
    - (2 + 2 = 4 â‰¡ 1 mod 3)
- If `total % 3 == 2`:
  - Remove one number with `num % 3 == 2`, or
  - Remove two numbers with `num % 3 == 1`
    - (1 + 1 = 2 â‰¡ 2 mod 3)

So we just need to keep track of the smallest candidates with remainder 1 and 2.

---

## âš ï¸ What Went Wrong in My Initial Approaches

### Approach 1 â€“ DFS subset search with a hash map

I tried to:
- Compute total sum
- Then search for subsets whose sum has certain remainders using DFS.

Problems:

- `nums.length` can be up to `4 * 10^4` â†’ DFS over subsets is **exponential**.
- This will never scale; it's essentially solving full subset-sum for large `n`.

---

### Approach 2 â€“ Binary search over possible sums + DFS

I then tried:

- Binary searching on a target sum `S` (multiple of 3),
- For each `S`, using DFS to check if any subset sums to `S`.

Problems:

1. DFS is still exponential.
2. Binary search assumes a **monotone predicate** (if `S` is achievable, something about other sums must be monotone), which is **not true** for subset sums.
3. Adjusting `mid` to a nearby multiple of 3 and then using that in binary search can skip valid answers.

Conclusion: Both approaches are fundamentally too heavy and not using the structure of modulo 3.

---

## ğŸƒ Approach â€“ Remove Minimum Remainder Sum

### Steps

1. Compute the total sum:
   ```ts
   const sum = nums.reduce((acc, x) => acc + x, 0);
   const r = sum % 3;
   ```
2. If `r == 0`, return sum.
3. Partition numbers by their remainder mod 3:
  - r1 = [] all numbers where num % 3 == 1
  - r2 = [] all numbers where num % 3 == 2
4. Sort r1 and r2 in ascending order, or track the 1â€“2 smallest in each.
5. Depending on r:
  - If r == 1:
    - Option A: remove the smallest r1[0]
    - Option B: remove r2[0] + r2[1] (if there are at least 2 in r2)
    - Choose the minimum positive of these removal sums.
  - If r == 2:
    - Option A: remove the smallest r2[0]
    - Option B: remove r1[0] + r1[1] (if there are at least 2 in r1)
    - Choose the minimum.
6. Answer is:
  ```text
  sum - bestRemoval
  ```

---

## ğŸ§¾ Code (TypeScript â€“ Greedy)

```ts
function maxSumDivThree(nums: number[]): number {
    const r1: number[] = []; // nums % 3 == 1
    const r2: number[] = []; // nums % 3 == 2

    let sum = 0;
    for (const num of nums) {
        sum += num;
        const r = num % 3;
        if (r === 1) r1.push(num);
        else if (r === 2) r2.push(num);
    }

    const mod = sum % 3;
    if (mod === 0) return sum;

    r1.sort((a, b) => a - b);
    r2.sort((a, b) => a - b);

    let remove = Infinity;

    if (mod === 1) {
        // Option 1: remove the smallest num with remainder 1
        if (r1.length >= 1) {
            remove = Math.min(remove, r1[0]);
        }
        // Option 2: remove two smallest nums with remainder 2
        if (r2.length >= 2) {
            remove = Math.min(remove, r2[0] + r2[1]);
        }
    } else if (mod === 2) {
        // Option 1: remove the smallest num with remainder 2
        if (r2.length >= 1) {
            remove = Math.min(remove, r2[0]);
        }
        // Option 2: remove two smallest nums with remainder 1
        if (r1.length >= 2) {
            remove = Math.min(remove, r1[0] + r1[1]);
        }
    }

    if (remove === Infinity) return 0; // no valid way
    return sum - remove;
}
```

---

## ğŸ§® Alternative DP Approach (Optional)

We can also use DP over remainder states:

- `dp[r]` = **maximum sum** we can get with sum % 3 == `r`.

Initialize:

```text
dp[0] = 0
dp[1] = -âˆ
dp[2] = -âˆ
```

For each num:

```text
let ndp = dp.slice()
for each r in {0,1,2}:
    newR = (r + num % 3) % 3
    ndp[newR] = max(ndp[newR], dp[r] + num)

dp = ndp
```

Answer: `dp[0]`.

---

## â±ï¸ Complexity

For the greedy solution:

- One pass to compute `sum` and split remainders: `O(n)`
- Sorting up to `n` elements in `r1` and `r2`: `O(n log n)` in worst case

Given constraints (`n â‰¤ 4 * 10^4`), this is easily fast enough.

**Time:**  `O(n log n)`
**Space:** `O(n)` (r1 and r2 arrays)

We can also optimise to track only the 2 smallest in each remainder class to keep space O(1) and time O(n).

---

## ğŸ§  Takeaway

- Donâ€™t bring subset-sum DFS to a modulo-3 fight.  
- Once you see **â€œdivisible by 3â€**, always check:
  - What happens with `sum % 3`?
  - Can I fix the remainder by **removing a few minimal elements**?

The core trick:

> Adjust the total sumâ€™s remainder by removing **smallest-cost elements** with suitable remainders, instead of exploring all subsets.

---

