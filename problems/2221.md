# ðŸ§© 2221. Find Triangular Sum of an Array

**Difficulty**: Medium  
**Tags**: Array, Simulation, Math, Combinatorics, Pascal's Triangle, BigInt  
**Link**: [LeetCode](https://leetcode.com/problems/find-triangular-sum-of-an-array/description)  

---

## ðŸ“œ Problem Summary

Given a 0-indexed integer array `nums` of digits `0..9`. Repeatedly build `newNums` of length `n-1` with:

```plaintext
newNums[i] = (nums[i] + nums[i+1]) % 10
```

Replace `nums` with `newNums` and repeat until one number remains. Return that final number (the **triangular sum**).

Constraints: `1 â‰¤ nums.length â‰¤ 1000`, `0 â‰¤ nums[i] â‰¤ 9`.

---

## ðŸ’¡ Key Idea (hint)
This process is **Pascalâ€™s triangle** in action. The final answer is the dot product of `nums` with row `n-1` of binomial coefficients, taken modulo `10`:

\[
\text{result} \equiv \sum_{i=0}^{n-1} \binom{n-1}{i} \cdot nums[i] \pmod{10}
\]

---

## ðŸ§­ Approach A â€” Direct Simulation (In-place) â€” `O(n^2)`

**Idea:** Simulate the described process in-place. Each pass reduces the active length by 1; update only the active prefix.

### Why use this?
- Simple, direct, and fast enough for `n â‰¤ 1000`.
- No BigInt, no fancy math. Good for clarity and correctness.

### Implementation (TypeScript)
```ts
function triangularSum_simulation(nums: number[]): number {
  const n: number = nums.length;
  if (n === 1) return nums[0];

  // O(n^2)
  for(let i=0; i<(nums.length-1); i++){
      for(let j=1; j<(nums.length-i); j++) { 
        nums[j-1] = (nums[j-1]+nums[j])%10;
      }
  }

  return nums[0];
}
```

---

## ðŸ§  Approach B â€” Binomial Coefficients (BigInt) â€” O(n) iterations

Idea: Use the binomial identity:

answer
=
âˆ‘
ð‘–
=
0
ð‘›
âˆ’
1
(
ð‘›
âˆ’
1
ð‘–
)
â‹…
ð‘›
ð‘¢
ð‘š
ð‘ 
[
ð‘–
]
(
m
o
d
10
)
.
answer=
i=0
âˆ‘
nâˆ’1
	â€‹

(
i
nâˆ’1
	â€‹

)â‹…nums[i](mod10).

Compute C(n-1, i) iteratively using the multiplicative recurrence:

ð¶
(
ð‘›
âˆ’
1
,
0
)
=
1
,
ð¶
(
ð‘›
âˆ’
1
,
ð‘–
+
1
)
=
ð¶
(
ð‘›
âˆ’
1
,
ð‘–
)
â‹…
ð‘›
âˆ’
1
âˆ’
ð‘–
ð‘–
+
1
.
C(nâˆ’1,0)=1,C(nâˆ’1,i+1)=C(nâˆ’1,i)â‹…
i+1
nâˆ’1âˆ’i
	â€‹

.

Use BigInt for exact integer arithmetic and accumulate the sum modulo 10.

Why BigInt? Coefficients grow large (e.g. C(1000,500) ~ 10^299). JS BigInt handles arbitrary precision; we keep ans reduced mod 10 so it stays tiny.

Implementation (TypeScript)

```ts
// O(n) iterations, uses BigInt for exact coefficients
function triangularSum_binomial(nums: number[]): number {
  const n = nums.length;
  if (n === 1) return nums[0];

  let ans = 0n;
  let coeff = 1n;               // C(n-1, 0)
  const nMinus1 = BigInt(n - 1);

  for (let i = 0; i < n; i++) {
    ans = (ans + coeff * BigInt(nums[i])) % 10n;
    if (i < n - 1) {
      // coeff = coeff * (n-1 - i) / (i+1)
      coeff = (coeff * (nMinus1 - BigInt(i))) / BigInt(i + 1);
    }
  }

  return Number(ans); // returns 0..9
}
```

---

## ðŸ§¾ Final Comparison


| Approach	| Time	| Space	| When to use |
| :----| :----| :----| :---- |
| Simulation (in-place) |	O(nÂ²)	| O(1) |	Simplicity, no BigInt required |
| Binomial (BigInt)	| O(n) iterations (BigInt cost)	| O(1) |	Elegant, faster asymptotic; use when BigInt available |

