# 🧩 2221. Find Triangular Sum of an Array

**Difficulty**: Medium  
**Tags**: Array, Simulation, Math, Combinatorics, Pascal's Triangle, BigInt  
**Link**: [LeetCode](https://leetcode.com/problems/find-triangular-sum-of-an-array/description)  

---

## 📜 Problem Summary

Given a 0-indexed integer array `nums` of digits `0..9`. Repeatedly build `newNums` of length `n-1` with:

```plaintext
newNums[i] = (nums[i] + nums[i+1]) % 10
```

Replace `nums` with `newNums` and repeat until one number remains. Return that final number (the **triangular sum**).

Constraints: `1 ≤ nums.length ≤ 1000`, `0 ≤ nums[i] ≤ 9`.

---

## 💡 Key Idea (hint)
This process is **Pascal’s triangle** in action. The final answer is the dot product of `nums` with row `n-1` of binomial coefficients, taken modulo `10`:

\[
\text{result} \equiv \sum_{i=0}^{n-1} \binom{n-1}{i} \cdot nums[i] \pmod{10}
\]

---

## 🧭 Approach A — Direct Simulation (In-place) — `O(n^2)`

**Idea:** Simulate the described process in-place. Each pass reduces the active length by 1; update only the active prefix.

### Why use this?
- Simple, direct, and fast enough for `n ≤ 1000`.
- No BigInt, no fancy math. Good for clarity and correctness.

### Implementation (TypeScript)
```ts
function triangularSum_simulation(nums: number[]): number {
  const n: number = nums.length;
  if (n === 1) return nums[0];

  // O(n^2)
  for(let i=0; i<(nums.length-1); i++){
      for(let j=1; j<(nums.length-i); j++) { 
        nums[j-1] = (nums[j-1]+nums[j])%10;
      }
  }

  return nums[0];
}
```

---

## 🧠 Approach B — Binomial Coefficients (BigInt) — O(n) iterations

Idea: Use the binomial identity:

answer
=
∑
𝑖
=
0
𝑛
−
1
(
𝑛
−
1
𝑖
)
⋅
𝑛
𝑢
𝑚
𝑠
[
𝑖
]
(
m
o
d
10
)
.
answer=
i=0
∑
n−1
	​

(
i
n−1
	​

)⋅nums[i](mod10).

Compute C(n-1, i) iteratively using the multiplicative recurrence:

𝐶
(
𝑛
−
1
,
0
)
=
1
,
𝐶
(
𝑛
−
1
,
𝑖
+
1
)
=
𝐶
(
𝑛
−
1
,
𝑖
)
⋅
𝑛
−
1
−
𝑖
𝑖
+
1
.
C(n−1,0)=1,C(n−1,i+1)=C(n−1,i)⋅
i+1
n−1−i
	​

.

Use BigInt for exact integer arithmetic and accumulate the sum modulo 10.

Why BigInt? Coefficients grow large (e.g. C(1000,500) ~ 10^299). JS BigInt handles arbitrary precision; we keep ans reduced mod 10 so it stays tiny.

Implementation (TypeScript)

```ts
// O(n) iterations, uses BigInt for exact coefficients
function triangularSum_binomial(nums: number[]): number {
  const n = nums.length;
  if (n === 1) return nums[0];

  let ans = 0n;
  let coeff = 1n;               // C(n-1, 0)
  const nMinus1 = BigInt(n - 1);

  for (let i = 0; i < n; i++) {
    ans = (ans + coeff * BigInt(nums[i])) % 10n;
    if (i < n - 1) {
      // coeff = coeff * (n-1 - i) / (i+1)
      coeff = (coeff * (nMinus1 - BigInt(i))) / BigInt(i + 1);
    }
  }

  return Number(ans); // returns 0..9
}
```

---

## 🧾 Final Comparison


| Approach	| Time	| Space	| When to use |
| :----| :----| :----| :---- |
| Simulation (in-place) |	O(n²)	| O(1) |	Simplicity, no BigInt required |
| Binomial (BigInt)	| O(n) iterations (BigInt cost)	| O(1) |	Elegant, faster asymptotic; use when BigInt available |

