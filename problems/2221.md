# 🧩 2221. Find Triangular Sum of an Array

**Difficulty**: Medium  
**Tags**: Array, Simulation, Math, Combinatorics, Pascal's Triangle, BigInt  
**Link**: [LeetCode](https://leetcode.com/problems/find-triangular-sum-of-an-array/description)  

---

verify this --->

# Intuition
- The first natural thought is to **simulate the process step by step**. This works in $$O(n^2)$$ time since at each level we reduce the array by one.
- But then comes the **aha moment** ✨: each element contributes according to the **Pascal’s Triangle coefficients**. This insight turns a brute force problem into a neat math-based shortcut.

# Approach 1: Simulation
## 🔹 Why Simulation Works
- This method is straightforward. At each level, replace every element with the sum of itself and its adjacent element.
- Apply `%10` after every addition to keep only the unit digit.
- Continue until only one element remains.
## Example Walkthrough
For `nums = [1,2,3,4,5]`:
```plaintext
[1,2,3,4,5] → [3,5,7,9] → [8,2,6] → [0,8] → [8]
```
Answer = 8

# Code
```typescript []
function triangularSum(nums: number[]): number {
    for(let i=0; i<(nums.length-1); i++){
        for(let j=1; j<(nums.length-i); j++) { 
            nums[j-1] = (nums[j-1]+nums[j])%10;
        }
    }

    return nums[0];
}
```

# Complexity
- Time complexity: $$O(n^2)$$
- Space complexity: $$O(1)$$ beause updating input array only

---

# Approach 2: Pascal’s Triangle & Binomial Coefficients
## 🔹 The Aha Moment
- Each element’s contribution follows the coefficients from `Pascal’s Triangle`.
![Screenshot 2025-09-30 at 7.41.35 PM.png](https://assets.leetcode.com/users/images/e090b93e-7cfc-4b3a-b081-25d7cce121b0_1759285973.468474.png)
![Screenshot 2025-09-30 at 7.53.35 PM.png](https://assets.leetcode.com/users/images/6dcf62ec-d384-41b6-a336-9efdf5e77f8a_1759286031.6332667.png)

- For an array of length n, the contribution of nums[i] is weighted by $(n-1)C_r$.
![Screenshot 2025-09-30 at 8.21.53 PM.png](https://assets.leetcode.com/users/images/299775f4-5c7b-45c2-a4ff-c9b337723b64_1759286328.2723413.png)


- The final result is essentially:
$answer = ∑ [ (n-1)C_i * nums[i] ](mod10)$

## 🔹 Why This is Better
- Instead of reducing arrays repeatedly, we directly compute contributions.
- But we avoid factorials (**factorials are too slow**) by using the recurrence:
![Screenshot 2025-10-01 at 6.12.26 AM.png](https://assets.leetcode.com/users/images/c36ed1ac-3153-4a03-84f2-3e7a340fdfcb_1759286879.0736072.png)

```plaintext
nextCoeff = currentCoeff * (n-1 - i) / (i+1)
```
- This gives each binomial coefficient in constant time.

# ⚠️ Why This Works in JS But Not in C++ (or other languages)
- `long long` in C++ is **fixed-width integer** type (64 bits)
- Max value ≈ 9.22 × 10^18 (~19 digits)
- But **Binomial coefficients** grow extremely fast:
    - C(100,50) ≈ 1e29
    - C(1000,500) ≈ 1e299
- Once values exceed ~1e19, they wrap around (overflow). Even __int128 (≈38 digits) dies long before n=1000.
- `JavaScript` use `BigInt` which is arbitrary-precision.
- Internally, numbers are stored as **arrays of digits** in a fixed base (e.g., 2^32).
- Example (simplified):
    - C(1000,500) ≈ 2.7 × 10^299 (≈300 digits).
    - Stored as ~10 “chunks” of 32-bit words.
- Arithmetic (+, ×, ÷) is done in software by iterating over chunks — like long multiplication.
- Slower than `Number`, but never overflows.

# Complexity
- Time complexity: $$O(n)$$
- Space complexity: $$O(1)$$

# Code
```typescript []
function triangularSum(nums: number[]): number {
    const n: number = nums.length;
    if (n === 1) return nums[0];

    let ans: bigint = 0n;
    let pascaltriangleCoefficient: bigint = 1n;
    const RealN: bigint = BigInt(n - 1);

    for (let i = 0; i < n; i++) {
        ans = (ans + pascaltriangleCoefficient * BigInt(nums[i])) % 10n;

        if (i < n - 1) {
            // nextCoeff = currentCoeff * (n-1 - i) / (i+1)
            pascaltriangleCoefficient = (pascaltriangleCoefficient * (RealN - BigInt(i))) / BigInt(i + 1);
        }
    }
    return Number(ans);
};
```

---

# Key Takeaways

- The **simulation** method is simple and good for understanding.
- The **binomial coefficient** approach is elegant and runs in linear time.
- The real aha moment is realizing the connection to **Pascal’s Triangle** — a common hidden pattern in array transformations.

# Discussion
Would you prefer solving this problem with **simulation for clarity**, or with **binomial coefficients for elegance**? 🚀
