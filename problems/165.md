# ğŸ§© Problem #165 â€“ Compare Version Numbers

**Difficulty:** Medium  
**Tags:** String, Simulation  
**Link:** [LeetCode](https://leetcode.com/problems/compare-version-numbers/)

---

## ğŸ§  Intuition  
Version strings are dot-separated integer parts, e.g. `"1.0.3"` and `"1.0"`.  
Comparing parts as regular integers is fine most of the time, but if a part can be *very long* (beyond JS safe integer range), converting to `Number` is unsafe. Instead: strip leading zeros, compare lengths, then lexicographically when lengths match.

---

## ğŸ’¡ Approach â€” String-safe Comparison

1. Split both versions by `'.'`.  
2. For each pair of parts:
   - Strip leading zeros (treat empty as `"0"`).
   - If lengths differ â†’ longer (more digits) is larger.
   - If lengths equal â†’ lexicographic compare.  
3. If all paired parts equal, the longer list's remaining parts must all be `"0"` (after trimming) to be equal; otherwise the longer is greater.

This is `O(m)` in total characters and robust for arbitrarily large parts.

---

## âœ… Optimized TypeScript Implementation

```ts []
function compareVersion(version1: string, version2: string): number {
    const parts1: string[] = version1.split('.');
    const parts2: string[] = version2.split('.');
    const n: number = Math.max(parts1.length, parts2.length);

    for (let i = 0; i < n; i++) {
        const a: number = i < parts1.length ? parseInt(parts1[i], 10) || 0 : 0;
        const b: number = i < parts2.length ? parseInt(parts2[i], 10) || 0 : 0;

        if (a < b) return -1;
        if (a > b) return 1;
    }
    return 0;
};

```

## ğŸ“Š Complexity

- **Time**: `O(m)` where m = total number of characters in both version strings (each character processed a constant number of times).
- **Space**: `O(k)` for the split arrays (k = number of parts).

## ğŸ” Notes

- This handles "1.01" vs "1.001" correctly (they're equal).
- Handles arbitrarily long numeric parts without BigInt or unsafe casts.
- If you know parts are small (within JS safe integer), the simpler parseInt approach is fine; this version is the safest and still fast.


