
# üß© Problem #2106 - Maximum Fruits Harvested After at Most K Steps

**Difficulty:** Hard  
**Topics:**  `Array`, `Sliding Window`, `Prefix-Sum`, `Gready`  
**Link:** [Leetcode](https://leetcode.com/problems/maximum-fruits-harvested-after-at-most-k-steps/description/)

# Intuition

At first glance, the problem looks overwhelming due to its Hard label. But once we realize the only constraint is walking at most k steps and collecting fruits on the path ‚Äî it becomes clear:

- We're always starting at startPos.
- We can walk in either direction.
- We have 2 options 
- 1. We can go k steps in same direct
- 2. We can walk some x steps in 1 direction and k-2x in other direction. 
- - **Note:** To cross over and return, you must spend 2x steps. That means the side you go *first* should be within k / 2 steps, or you'll exceed the limit.

- This logic used to validate all k sized windows.


Once this is figured out, we can treat this as a classic sliding window problem ‚Äî with a custom constraint on valid window span.

# Approach

### üîç Observation:

- You can only visit fruit positions between startPos - k and startPos + k.
- If you go left then right, the smaller of the two directions is counted twice (go and return), and the larger only once.
- If you go only in one direction, then you will be collect fruits for k units.

### ‚úÖ Strategy:
![input.png](https://assets.leetcode.com/users/images/0734b772-28f1-434c-8425-33239738f7c3_1754482348.6180677.png)

1. **Filter** all fruits in the range [startPos - k, startPos + k] ‚Äî anything beyond this can‚Äôt be collected.
![step_1.png](https://assets.leetcode.com/users/images/bdf67038-44aa-42a8-bc16-6790e4da7022_1754482397.1214542.png)

2. **Use prefix sum** to quickly get sum of fruits in any window.
![Screenshot 2025-08-06 at 5.44.21‚ÄØPM.png](https://assets.leetcode.com/users/images/edd14bb6-9aa2-4ac6-9fc6-691de9521b64_1754482480.7589943.png)

4. **Sliding window**: move right pointer to expand the window, and left to shrink it only when total travel cost exceeds k.
![step_3.png](https://assets.leetcode.com/users/images/621bfc60-6005-4168-aa6e-4136e0864429_1754482503.438655.png)

5. **Custom window validator** checks whether a window [left, right] is reachable from startPos within k steps.

---

### üß† Trick for Window Validity:

For a window [a, b], where startPos is the origin:

- If both a and b are on **same side** of startPos, you only walk k units.
- If they are on **opposite sides**, then:

$$
\text{Walk} = 2 \cdot \min(\text{leftSpan}, \text{rightSpan}) + \max(\text{leftSpan}, \text{rightSpan})
$$


This formula handles the to-and-fro direction smartly.

---

# Complexity

- **Time complexity:**  
$$O(N)$$ ‚Äî each fruit position is visited once during sliding window and prefix sum construction.

- **Space complexity:**  
  $$O(N)$$ ‚Äî due to the filtered array and prefix sum.  

  **Note:** _You can optimize this to $$O(1)$$ by using the input fruits array directly and only operating on the subrange from startPos - k to startPos + k._

---

# Code
``` javascript []
var maxTotalFruits = function(fruits, startPos, k) {

  function isWindowSizeValid(startPosition, endPosition){
      let windowSize = 0;

      // different side of origin
      if ((startPosition < startPos) && (endPosition > startPos)) {
          const leftSpan = startPos - startPosition;
          const rightSpan = endPosition - startPos;
          windowSize = Math.min(leftSpan, rightSpan) * 2 + Math.max(leftSpan, rightSpan);
      } else {
          windowSize = Math.abs(endPosition - startPosition);
      }

      return windowSize <= k;
  }

  // edge case
  if (k === 0) {
      for (let i = 0; i < fruits.length; i++) {
          if (fruits[i][0] === startPos) return fruits[i][1];
      }
      return 0;
  }

  let maxFruitsCollected = 0;

  // filter fruits within [startPos - k, startPos + k]
  const calculatableSpan = fruits.filter(([pos]) =>
      pos >= (startPos - k) && pos <= (startPos + k)
  );

  if (calculatableSpan.length === 0) return 0;

  // edge case: whole span can be collected
  if (isWindowSizeValid(
      calculatableSpan[0][0],
      calculatableSpan[calculatableSpan.length - 1][0]
  )) {
      return calculatableSpan.reduce((acc, [_, val]) => acc + val, 0);
  }

  // prefix sum
  for (let i = 1; i < calculatableSpan.length; i++) {
      calculatableSpan[i][1] += calculatableSpan[i - 1][1];
  }

  let left = 0;
  let right = 0;

  while (right < calculatableSpan.length) {
      while (
          right + 1 < calculatableSpan.length &&
          isWindowSizeValid(calculatableSpan[left][0], calculatableSpan[right + 1][0])
      ) {
          right++;
      }

      let collected = calculatableSpan[right][1];
      if (left > 0) {
          collected -= calculatableSpan[left - 1][1];
      }

      maxFruitsCollected = Math.max(maxFruitsCollected, collected);

      if (right === calculatableSpan.length - 1) break;

      left++;
      if (right < left) right = left;
  }

  return maxFruitsCollected;
};
```
