# ‚ö° 2438. Range Product Queries of Powers

**Difficulty:** Medium  
**Tags:** Bit Manipulation, Prefix Product, Modular Arithmetic

---

## üß† Intuition

We are given `n` and queries asking for the product of certain consecutive elements from the **powers array** formed from `n`'s binary representation.

Key points:
- Since `1 <= n <= 10^9`, the binary form has at most 30 bits ‚Üí at most 30 powers of 2 in the array.
- This means all queries are over a **small array** ‚Üí preprocessing with **prefix product** is efficient.
- **Division** in modular arithmetic needs modular inverse, not plain `/`.

---

## üí° Approach 1 ‚Äî Prefix Product (using BigInt in JS)

1. **Generate powers array** from set bits of `n`.  
   Example: `n = 15 (1111b)` ‚Üí powers = `[1, 2, 4, 8]`.
2. Build **prefix products**.  
3. For each query `[l, r]`:
   - If `l = 0` ‚Üí answer = `prefix[r]`.
   - Else answer = `prefix[r] / prefix[l-1]`.
4. `% MOD` is applied at the end (JS handles big integers automatically).

**Time Complexity:**  
- Build powers: **O(30)**  
- Prefix: **O(30)**  
- Queries: **O(Q)**  
**Space:** **O(30)**

```javascript
var productQueries = function(n, queries) {
    const MOD = 1000000007;

    // Step 1: Extract powers
    const powers = [];
    for (let i = 0; i < 30; i++) {
        if ((n & (1 << i)) > 0) powers.push(1 << i);
    }

    // Step 2: Prefix product
    for (let i = 1; i < powers.length; i++) {
        powers[i] *= powers[i - 1];
    }

    // Step 3: Answer queries
    const ans = [];
    for (const [l, r] of queries) {
        let val = powers[r];
        if (l > 0) val /= powers[l - 1];
        ans.push(val % MOD);
    }
    return ans;
};
```

## üí° Approach 2 ‚Äî Modular Inverse (No BigInt)

If the language does not support big integers:

- Multiply with `% MOD` at each step to prevent overflow.
- Use Fermat‚Äôs Little Theorem for division:
```text
b^‚àí1 ‚â° (b^MOD‚àí2) (mod¬†MOD)
```
- Precompute `prefix[i]` as product mod MOD.
- Also precompute `invPrefix[i]` (inverse of prefix products) to answer queries in O(1).

Modular Exponentiation Helper:
```javascript []
function modPow(base, exp, mod) {
    let res = 1n;
    let b = BigInt(base), e = BigInt(exp), m = BigInt(mod);
    while (e > 0) {
        if (e & 1n) res = (res * b) % m;
        b = (b * b) % m;
        e >>= 1n;
    }
    return res;
}
```

Implementation:
```javascript []
var productQueries = function(n, queries) {
    const MOD = 1000000007n;
    const powers = [];

    // Step 1: Extract powers
    for (let i = 0; i < 30; i++) {
        if ((n & (1 << i)) > 0) powers.push(BigInt(1 << i));
    }

    // Step 2: Prefix mod products
    const prefix = [powers[0] % MOD];
    for (let i = 1; i < powers.length; i++) {
        prefix[i] = (prefix[i - 1] * powers[i]) % MOD;
    }

    // Step 3: Precompute inverses
    const invPrefix = [...prefix];
    for (let i = 0; i < invPrefix.length; i++) {
        invPrefix[i] = modPow(invPrefix[i], MOD - 2n, MOD);
    }

    // Step 4: Answer queries
    const ans = [];
    for (const [l, r] of queries) {
        let val = prefix[r];
        if (l > 0) val = (val * invPrefix[l - 1]) % MOD;
        ans.push(Number(val));
    }
    return ans;
};
```

## üìä Complexity
| Approach	| Time Complexity	| Space Complexity
| -------- | -------- | -------- |
| Prefix + BigInt |	O(Q + 30) |	O(30) |
| Prefix + Modular Inverse |	O(Q + 30 log MOD) |	O(30) |

## üîç Notes
- In JS, BigInt makes Approach 1 easier, but Approach 2 works everywhere.
- Modular inverse is only valid if MOD is prime (here 10^9 + 7 is prime).
