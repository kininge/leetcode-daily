# 🧩 Problem #3461 – Check If Digits Are Equal in String After Operations I

**Difficulty:** Easy  
**Topics:** `Array`, `Simulation` 
**Link:** [Leetcode](https://leetcode.com/problems/check-if-digits-are-equal-in-string-after-operations-i/)

---

## 🧠 Intuition

You repeatedly replace the string `s` by the sequence of pairwise sums modulo 10 of consecutive digits, until only two digits remain.  
Each round reduces the length by 1. The process is naturally simulated: on round `r` you compute `new[i] = (old[i] + old[i+1]) % 10` for all valid `i`. Repeat until the length is 2.

Because `s.length <= 100`, a direct simulation (two nested loops) is simple, correct, and fast enough.

---

## 🧩 Approach

1. Convert the string `s` to an array of integers `nums`.
2. While the array length is greater than 2:
   - For `j` from `1` to `len-1` (1-based in concept), set `nums[j-1] = (nums[j-1] + nums[j]) % 10`.
   - This reuses `nums` in-place, so we don't need extra arrays.
3. After the reductions, check if the first two entries `nums[0]` and `nums[1]` are equal.

This in-place simulation is `O(n^2)` time and `O(n)` space, which is perfectly fine for `n ≤ 100`.

---

## 💻 Code

```Typescript []
function hasSameDigits(s: string): boolean {
  const nums: number[] = [];
  for (const ch of s) nums.push(parseInt(ch, 10));

  // simulate rounds; each outer iteration reduces length by 1
  for (let round = 0; round < s.length - 2; round++) {
    // compute new values in-place: nums[i] becomes (nums[i] + nums[i+1]) % 10
    for (let j = 1; j < s.length - round; j++) {
      nums[j - 1] = (nums[j - 1] + nums[j]) % 10;
    }
    // after this, the effective length is reduced by 1
  }

  return nums[0] === nums[1];
}
```

---

## ⏱️ Complexity

**Time:** `O(n^2)` — each of about n rounds does up to `n` additions, with `n ≤ 100`.
**Space:** `O(n)` for the digit array (in-place updates).

---

## 🧩 Example

```text
s = "12345"
Step 1 (pairs): [ (1+2)%10=3, (2+3)=5, (3+4)=7, (4+5)=9 ] => "3579"
Step 2: [ (3+5)=8, (5+7)=2, (7+9)=6 ] => "826"
Step 3: [ (8+2)=0, (2+6)=8 ] => "08"
Final two digits: 0 and 8 -> not equal -> return false

```

---

## ✅ Takeaway

- Direct simulation with in-place pairwise sums modulo 10 is clean and efficient enough here.
- No need for fancy combinatorics or optimisation — keep it simple and readable for this constraint.


