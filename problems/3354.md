# 🧩 Problem #3354 – Make Array Elements Equal to Zero

**Difficulty:** Easy  
**Topics:** `Simulation`, `Prefix Sum`, `Math`  
**Link:** [Leetcode](https://leetcode.com/problems/make-array-elements-equal-to-zero/)

---

## 🧠 Intuition

We are given an array of non-negative integers.  
We start from a position `curr` where `nums[curr] == 0` and choose a direction (left or right).  
We repeatedly:
- Move if the current cell is `0`.
- Otherwise decrement it by `1`, flip direction, and move one step.

A valid starting position and direction must make **all elements zero** by the end of the process.

At first, this looks like a complicated simulation — but there’s a hidden symmetry.

---

## 🔍 Key Observation

Let’s define:
- `L = sum(nums[0 .. i-1])` → total "work" (positive counts) on the **left side** of the zero
- `R = sum(nums[i+1 .. n-1])` → total "work" on the **right side**

Each decrement consumes exactly one "unit of work" from whichever side you move to.

Now:
- If you start **left**, you’ll process left first, then flip to right when a nonzero is encountered, and so on.
- The total number of flips between sides equals `L + R`.

For the process to end with all zeros, you must “finish” one side exactly when you step out of bounds.  
That’s possible **only when the difference between L and R is small**.

Thus:
| Condition | Meaning | Valid directions |
|------------|----------|------------------|
| `L == R` | perfectly balanced sides | both left and right work → +2 |
| `|L - R| == 1` | one side has 1 extra element’s worth of work | only that side’s direction works → +1 |
| `|L - R| > 1` | imbalance too large | no valid start → +0 |


### 💻 Code (TypeScript)
```ts
function countValidSelections(nums: number[]): number {
  const totalSum = nums.reduce((s, x) => s + x, 0);

  let leftSum = 0;
  let ans = 0;

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] === 0) {
      const rightSum = totalSum - leftSum - nums[i]; // nums[i] is 0
      if (leftSum === rightSum) ans += 2;
      else if (Math.abs(leftSum - rightSum) === 1) ans += 1;
    }
    leftSum += nums[i];
  }

  return ans;
}
```

### ⏱️ Complexity
| Operation | Time | Space |
|------------|------|--------|
| Single pass through array | `O(n)` | `O(1)` |

Given constraints (`n ≤ 100`), this is extremely efficient.

---

## ✅ Takeaway
This "Easy" problem hides a clever balance condition.

Instead of simulating complex moves and direction flips,  
You only need to compare **left vs right work (sum)** around each zero.

When both sides are balanced → 2 options.  
When off by one → 1 option.  
Otherwise → no valid way.

---
