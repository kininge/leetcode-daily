# 🧠 Leetcode Daily — 2273. Find Resultant Array After Removing Anagrams  

> **Problem Link:** [LeetCode #2273](https://leetcode.com/problems/find-resultant-array-after-removing-anagrams)  
> **Difficulty:** Easy  
> **Topic:** Strings, Hashing  
> **Tags:** Frequency Map, Prime Hashing, Double Modulo Optimization  

---

## 🎯 Problem Summary  

You are given an array `words[]` containing lowercase strings.  
You must **remove any word** that is an **anagram of its previous word**, and return the resultant array.

> An **anagram** means two words have the same frequency of letters regardless of order.  
> Example: `"ab"` and `"ba"` are anagrams.

---

## 🧩 Example  

**Input:**  
```text
["abba","baba","bbaa","cd","cd"]
```

## Output:

```text
["abba","cd"]
```

--- 

## 🧠 Approach 1 — Brute Force (Frequency Count)

### 💡 Idea

- For every word, generate a frequency map (size 26).
- Compare it with the previous word’s map.
- If they differ → keep it. If same → skip.

### ⏱️ Complexity

- **Time**: `O(n × m)` — `n` words × `m` avg. characters per word
- **Space**: `O(26)` → `O(1)`

### ✅ Notes

- 100% deterministic — no collisions.
- Slightly more allocations (one frequency array per word).

```Typescript []
function removeAnagrams(words: string[]): string[] {
    // edge case
    if(words.length === 1) return words;
    
    // O(m) - number of charectors
    // generate frequency map of word
    function generateFrequency(word: string): number[]{
        const map = new Array(26).fill(0);
        for(const char of word) map[char.charCodeAt(0)-97] += 1;

        return map;
    }

    let map: number[] = generateFrequency(words[0]);

    let ans: string[] = [words[0]];
    // O(n*m) - number of words * avg charectors in each word
    for(let i=1; i<words.length; i++){
        const _map: number[] = generateFrequency(words[i]);

        // O(26) - check if word matches to previous word 
        let isMatch: boolean = true;
        for(let j=0; j<26; j++){
            if(map[j] !== _map[j]){
                isMatch = false;
                break;
            }
        }

        if(isMatch === false){
            ans.push(words[i]);
            map = _map;
        }
    }

    return ans;
};
```

---

## ⚡ Approach 2 — Rabin–Karp Style (Prime Product Hash)

### 💡 Idea

- Assign each letter `a–z` a unique prime number.
- The product of these primes forms a hash that uniquely represents the multiset of letters.
- If two consecutive hashes match → they’re anagrams → skip.

### ⚠️ Problem

- Products get huge `(101^100 ≈ 10²⁰⁰)`.
- You must use `BigInt` or `modulo` to keep numbers manageable.

### 🧮 Example

If `a=2, b=3, c=5`:
  - `"ab"` → 2×3 = 6
  - `"ba"` → 3×2 = 6 → same hash ✅

### ⚙️ Trade-offs

| Aspect |	Brute Force |	Prime Product |
| --- | --- | --- |
| Correctness |	✅ Always |	⚠️ Needs mod or BigInt |
| Space |	Slightly more |	O(1) |
| Collisions |	None |	Possible (rare) |
| Performance |	Stable |	Faster in practice |

---

```TypeScript []
function removeAnagrams(words: string[]): string[] { 
    // edge case
    if(words.length === 1) return words;

    // We are using prime numbers because if we use any 26 numbers to represent a-z
    // and generate the product of those that will not be unique. 
    // Only the product of prime numbers generates a unique number
    // top 26 prime numbers
    const primeNumbers: number[] = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 , 59 , 61 ,  67 , 71 , 73 ,  79 ,  83 ,  89 ,  97 , 101 ];

    // but here is 1 issue -- suppose word is 'zzzzz...' z, 100 times 
    // number will be 101^100 ~= 2.7 * 10^200 ---> 201 digit number
    // either we should use 'BigInt' or 'Modulo'
    const MOD = 1_000_000_007; // _ use for better to read

    // O(m) - number of charectors
    function generateUniqueNum(word: string): number{
        let num = 1;
        for(const char of word) num = (num * primeNumbers[char.charCodeAt(0)-97])%MOD;

        return num;
    }


    let lastNum: number = generateUniqueNum(words[0]);
    let ans: string[] = [words[0]];

    // O(n*m)
    for(let i=0; i<words.length; i++){
        const _num: number = generateUniqueNum(words[i]);

        if(lastNum !== _num){
            ans.push(words[i]);
            lastNum = _num;
        }
    }

    return ans;
}
```

---

## 🔐 Approach 3 — Enhanced Rabin–Karp with Double Modulo (Recommended)

### 💡 Idea

- Use two **large prime moduli** to make collisions practically impossible.
- Compute two hashes per word:

```text
h1 = product % MOD1
h2 = product % MOD2
```

- Compare `(h1,h2)` pair → same pair ⇒ anagrams.

### 🧩 Why it works

- For two numbers `A ≠ B` to collide, they must satisfy:
`A % MOD1 == B % MOD1` and `A % MOD2 == B % MOD2`.
- Probability ≈ `1 / (MOD1 × MOD2)` → basically zero.

### ⚙️ Suggested moduli

```ty
MOD1 = 1_000_000_007;
MOD2 = 1_000_000_009;
```

### ✅ Benefits

- Still O(n × m).
- No BigInt required.
- Ultra-low collision probability.
- Compact, fast, and robust.

```TypeScript []
```

### 🔬 Comparison Summary

| Variant |	Deterministic |	Collision Risk |	Extra Space |	Speed |
| --- | --- | --- | --- | --- |
| Brute Force (freq count) |	✅ |	❌ |	O(1) |	⚙️ Medium |
| Rabin–Karp (prime product) |	❌ |	⚠️ Low |	O(1) |	⚡ Fast |
| Rabin–Karp + Double Mod (final) |	✅ Practically |	🚫 |	O(1) |	🚀 Very Fast |

---

## 🧩 Key Takeaways

1. **Prime product hashing** uses *the Fundamental Theorem of Arithmetic* — unique factorisation.
2. **Modulo reduction** can cause collisions → use **double hashing** to eliminate risk.
3. Use integer literals for mod (`1_000_000_007`) instead of floating ones (`1e9+7`).

---

## 🏁 Final Thoughts

- For correctness-first code: ✅ use the **frequency map** method.
- For optimised, low-memory, production code: ⚡ use **Rabin–Karp + Double Modulo**.
- Both are `O(n × m)` and perfect for `n ≤ 100, m ≤ 10`.

---

## 🧠 Bonus Tip

Try extending this to handle:
  - Case-insensitive matches
  - Unicode strings
  - Multi-word anagrams
The same hashing logic scales cleanly.

---

> 💬 "A good engineer doesn’t just solve the problem — he builds the version that scales, explains it clearly, and ensures it never fails by accident." 😎
