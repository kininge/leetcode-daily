# ğŸ§  Leetcode Daily â€” 2273. Find Resultant Array After Removing Anagrams  

> **Problem Link:** [LeetCode #2273](https://leetcode.com/problems/find-resultant-array-after-removing-anagrams)  
> **Difficulty:** Easy  
> **Topic:** Strings, Hashing  
> **Tags:** Frequency Map, Prime Hashing, Double Modulo Optimization  

---

## ğŸ¯ Problem Summary  

You are given an array `words[]` containing lowercase strings.  
You must **remove any word** that is an **anagram of its previous word**, and return the resultant array.

> An **anagram** means two words have the same frequency of letters regardless of order.  
> Example: `"ab"` and `"ba"` are anagrams.

---

## ğŸ§© Example  

**Input:**  
```text
["abba","baba","bbaa","cd","cd"]
```

## Output:

```text
["abba","cd"]
```

--- 

## ğŸ§  Approach 1 â€” Brute Force (Frequency Count)

### ğŸ’¡ Idea

- For every word, generate a frequency map (size 26).
- Compare it with the previous wordâ€™s map.
- If they differ â†’ keep it. If same â†’ skip.

### â±ï¸ Complexity

- **Time**: `O(n Ã— m)` â€” `n` words Ã— `m` avg. characters per word
- **Space**: `O(26)` â†’ `O(1)`

### âœ… Notes

- 100% deterministic â€” no collisions.
- Slightly more allocations (one frequency array per word).

```Typescript []
function removeAnagrams(words: string[]): string[] {
    // edge case
    if(words.length === 1) return words;
    
    // O(m) - number of charectors
    // generate frequency map of word
    function generateFrequency(word: string): number[]{
        const map = new Array(26).fill(0);
        for(const char of word) map[char.charCodeAt(0)-97] += 1;

        return map;
    }

    let map: number[] = generateFrequency(words[0]);

    let ans: string[] = [words[0]];
    // O(n*m) - number of words * avg charectors in each word
    for(let i=1; i<words.length; i++){
        const _map: number[] = generateFrequency(words[i]);

        // O(26) - check if word matches to previous word 
        let isMatch: boolean = true;
        for(let j=0; j<26; j++){
            if(map[j] !== _map[j]){
                isMatch = false;
                break;
            }
        }

        if(isMatch === false){
            ans.push(words[i]);
            map = _map;
        }
    }

    return ans;
};
```

---

## âš¡ Approach 2 â€” Rabinâ€“Karp Style (Prime Product Hash)

### ğŸ’¡ Idea

- Assign each letter `aâ€“z` a unique prime number.
- The product of these primes forms a hash that uniquely represents the multiset of letters.
- If two consecutive hashes match â†’ theyâ€™re anagrams â†’ skip.

### âš ï¸ Problem

- Products get huge `(101^100 â‰ˆ 10Â²â°â°)`.
- You must use `BigInt` or `modulo` to keep numbers manageable.

### ğŸ§® Example

If `a=2, b=3, c=5`:
  - `"ab"` â†’ 2Ã—3 = 6
  - `"ba"` â†’ 3Ã—2 = 6 â†’ same hash âœ…

### âš™ï¸ Trade-offs

| Aspect |	Brute Force |	Prime Product |
| --- | --- | --- |
| Correctness |	âœ… Always |	âš ï¸ Needs mod or BigInt |
| Space |	Slightly more |	O(1) |
| Collisions |	None |	Possible (rare) |
| Performance |	Stable |	Faster in practice |

---

```TypeScript []
function removeAnagrams(words: string[]): string[] { 
    // edge case
    if(words.length === 1) return words;

    // We are using prime numbers because if we use any 26 numbers to represent a-z
    // and generate the product of those that will not be unique. 
    // Only the product of prime numbers generates a unique number
    // top 26 prime numbers
    const primeNumbers: number[] = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 , 59 , 61 ,  67 , 71 , 73 ,  79 ,  83 ,  89 ,  97 , 101 ];

    // but here is 1 issue -- suppose word is 'zzzzz...' z, 100 times 
    // number will be 101^100 ~= 2.7 * 10^200 ---> 201 digit number
    // either we should use 'BigInt' or 'Modulo'
    const MOD = 1_000_000_007; // _ use for better to read

    // O(m) - number of charectors
    function generateUniqueNum(word: string): number{
        let num = 1;
        for(const char of word) num = (num * primeNumbers[char.charCodeAt(0)-97])%MOD;

        return num;
    }


    let lastNum: number = generateUniqueNum(words[0]);
    let ans: string[] = [words[0]];

    // O(n*m)
    for(let i=0; i<words.length; i++){
        const _num: number = generateUniqueNum(words[i]);

        if(lastNum !== _num){
            ans.push(words[i]);
            lastNum = _num;
        }
    }

    return ans;
}
```

---

## ğŸ” Approach 3 â€” Enhanced Rabinâ€“Karp with Double Modulo (Recommended)

### ğŸ’¡ Idea

- Use two **large prime moduli** to make collisions practically impossible.
- Compute two hashes per word:

```text
h1 = product % MOD1
h2 = product % MOD2
```

- Compare `(h1,h2)` pair â†’ same pair â‡’ anagrams.

### ğŸ§© Why it works

- For two numbers `A â‰  B` to collide, they must satisfy:
`A % MOD1 == B % MOD1` and `A % MOD2 == B % MOD2`.
- Probability â‰ˆ `1 / (MOD1 Ã— MOD2)` â†’ basically zero.

### âš™ï¸ Suggested moduli

```ty
MOD1 = 1_000_000_007;
MOD2 = 1_000_000_009;
```

### âœ… Benefits

- Still O(n Ã— m).
- No BigInt required.
- Ultra-low collision probability.
- Compact, fast, and robust.

```TypeScript []
```

### ğŸ”¬ Comparison Summary

| Variant |	Deterministic |	Collision Risk |	Extra Space |	Speed |
| --- | --- | --- | --- | --- |
| Brute Force (freq count) |	âœ… |	âŒ |	O(1) |	âš™ï¸ Medium |
| Rabinâ€“Karp (prime product) |	âŒ |	âš ï¸ Low |	O(1) |	âš¡ Fast |
| Rabinâ€“Karp + Double Mod (final) |	âœ… Practically |	ğŸš« |	O(1) |	ğŸš€ Very Fast |

---

## ğŸ§© Key Takeaways

1. **Prime product hashing** uses *the Fundamental Theorem of Arithmetic* â€” unique factorisation.
2. **Modulo reduction** can cause collisions â†’ use **double hashing** to eliminate risk.
3. Use integer literals for mod (`1_000_000_007`) instead of floating ones (`1e9+7`).

---

## ğŸ Final Thoughts

- For correctness-first code: âœ… use the **frequency map** method.
- For optimised, low-memory, production code: âš¡ use **Rabinâ€“Karp + Double Modulo**.
- Both are `O(n Ã— m)` and perfect for `n â‰¤ 100, m â‰¤ 10`.

---

## ğŸ§  Bonus Tip

Try extending this to handle:
  - Case-insensitive matches
  - Unicode strings
  - Multi-word anagrams
The same hashing logic scales cleanly.

---

> ğŸ’¬ "A good engineer doesnâ€™t just solve the problem â€” he builds the version that scales, explains it clearly, and ensures it never fails by accident." ğŸ˜
