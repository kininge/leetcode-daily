# ğŸ§© Problem #3607 â€“ Power Grid Maintenance

**Difficulty:** Medium  
**Topics:** `Union Find`, `Heap`, `Graph`  
**Link:** https://leetcode.com/problems/power-grid-maintenance

---

## ğŸ§  Intuition

We are given `c` power stations connected by bidirectional cables.  
These connections form *power grids* â€” groups of stations directly or indirectly connected.

Each grid can be imagined as a **network cluster** where:
- Every station is a *node*.
- Each cable is an *edge*.
- If a station goes offline, it remains part of its grid but becomes *non-operational*.

We are asked to handle two types of queries:
1. `[1, x]` â†’ Find the smallest operational (online) station ID in the same grid as `x`.
2. `[2, x]` â†’ Mark station `x` as offline.

---

If we naÃ¯vely searched all connected stations for each `[1, x]` query using BFS/DFS,
it would be **O(N)** per query â€” far too slow for up to `2 Ã— 10âµ` queries.

So we need a structure that can:
- Quickly find which *grid* a station belongs to âœ…  
- Efficiently track the **smallest online ID** in that grid âœ…  
- Handle online/offline toggling dynamically âœ…  

This naturally leads us to combining:
1. **Disjoint Set Union (Union-Find)** â†’ To group connected stations into components (grids).  
2. **Min-Heap (Priority Queue)** â†’ To quickly fetch the smallest online station ID in each grid.  
3. **Lazy Deletion** â†’ To skip over offline stations efficiently without re-building the heap.

---

ğŸ“Š *Key idea*:  
Each connected grid = one DSU component.  
Each component maintains its own **Min-Heap** of all station IDs.  
When a station goes offline, we donâ€™t immediately remove it â€”  
we just â€œlazy deleteâ€ it when it reaches the top of the heap during a query.

---

## âš™ï¸ Approach Overview

We combine three structures/techniques to get fast answers:

1. **Disjoint Set Union (DSU / Union-Find)**  
   - Build connected components (power grids) once from `connections`.  
   - `find(x)` gives the representative (root) of `x`'s grid in ~O(Î±(c)) time.

2. **Per-component Min-Heap (priority queue)**  
   - For each DSU root, keep a min-heap of **all station IDs** in that component.  
   - The heap is keyed by station ID (smallest ID at top), so the top is always the candidate for smallest online station.

3. **Online set + Lazy Deletion**  
   - Maintain a `Set` (or boolean array) `online` containing currently online stations. Initially all stations are online.  
   - When a station goes offline (`[2, x]`), remove it from `online` only; **do not** remove it from the heap immediately.  
   - When answering `[1, x]`, use the heap for `find(x)`'s component:
     - While `heap.top()` is offline, `pop()` it (this is lazy deletion).
     - After cleaning, if heap is empty â†’ return `-1`; else `heap.top()` is the smallest online station.
    
### âš¡ Visual Intuition

Imagine there are 6 power stations with these connections:

```text
1 -- 2 -- 3      4 -- 5      6
â”‚                â”‚
â”‚                â””â”€â”€ forms another grid
â””â”€â”€ connected as a single grid
```

After building the graph, we identify **connected components (power grids)**:

Grid A â†’ [1, 2, 3]  
Grid B â†’ [4, 5]  
Grid C â†’ [6]

Now, DSU (Union-Find) compresses this structure as:

parent = [ , 1, 1, 1, 4, 4, 6]
(find(1)=find(2)=find(3)=1, find(4)=find(5)=4, find(6)=6)

Each component gets its own **Min-Heap** that keeps station IDs in ascending order:

Grid A â†’ Heap[1] = [1, 2, 3]â€ƒ(top = 1)  
Grid B â†’ Heap[4] = [4, 5]â€ƒâ€ƒ(top = 4)  
Grid C â†’ Heap[6] = [6]â€ƒâ€ƒâ€ƒ(top = 6)

Initially all stations are online:

online = {1, 2, 3, 4, 5, 6}


### Lazy deletion demo

If a station goes offline, we mark it offline but leave it in the heap:  

**Query 1:** [2, 2] â†’ station 2 offline
  - online = {1, 3, 4, 5, 6} <--- removed from 'online' hashmap
  - Heap[1] = [1, 2, 3] (no change yet)

**Query 2:** [2, 1] â†’ station 1 offline
  - online = {3, 4, 5, 6} <--- removed from 'online' hashmap
  - Heap[1] = [1, 2, 3] (no change yet) 

**Query 3:** [1, 2] â†’ get smallest online staion in same compoent ot of `2`
  - `find(2)` = 1;
  - Now Heap[1] = [1, 2, 3], online = {3, 4, 5, 6}.
  - top = 1 (offline) â†’ pop,  
  - top = 2 (offline) â†’ pop,  
  - top = 3 (online) â†’ answer = 3.

Lazy deletion ensures the heap self-cleans on demand â€”  
no rebuilding, just one-time pops of stale offline stations.

### Step-by-step workflow

1. **Preprocessing**
   - Build DSU from `connections` by calling `union(u, v)` for every edge.
   - Create an empty min-heap for each component root.
   - For every station `i` from `1..c`, push `i` into the heap of `find(i)`.

2. **Maintain online set**
   - Initialize `online = {1,2,...,c}`.

3. **Process queries**
   - For `[2, x]`: `online.delete(x)` (mark offline).
   - For `[1, x]`:
     - If `online.has(x)` â†’ answer `x` immediately.
     - Else:
       - Let `r = find(x)`.
       - Let `h = heap_of(r)`.
       - While `h` not empty and `!online.has(h.top())`: `h.pop()` (discard stale offline IDs).
       - If `h` empty â†’ answer `-1`.
       - Else â†’ answer `h.top()`.

### Correctness invariants

- DSU partitions nodes into static components; connectivity never changes (only online status changes).
- Each component heap always contains **all** node IDs initially; lazy deletions ensure the heapâ€™s top becomes the smallest *currently online* ID when queried.
- Each node is popped at most once from its component heap (amortized bound).

### Complexity (amortized)

- DSU build (union for each connection): ~O(n Â· Î±(c))  
- Heap construction: O(c Â· log c) total (each node pushed once)  
- Each query:
  - `[2, x]`: O(1) to mark offline.
  - `[1, x]`: O(Î±(c)) for `find` + amortized O(log c) per pop; each node can be popped at most once across all queries. So overall queries cost â‰ˆ O(q Â· Î±(c) + c Â· log c) amortized.

Memory:
- DSU arrays: O(c)
- Heaps combined: O(c)
- Online set: O(c)

---

## ğŸ§© Step-by-Step Code Explanation

We'll now walk through the full implementation that combines  
**Union-Find (DSU)** + **Per-Component Min-Heap** + **Lazy Deletion.**


### ğŸ—ï¸ 1. Build Connected Components (Unin-Find - DSU)

Each power grid is a connected component in the graph.

We use DSU to merge stations that share a cable connection:

```ts
class DSU {
  parent: number[];
  rank: number[];
  
  constructor(n: number) {
    this.parent = new Array(n + 1);
    this.rank = new Array(n + 1).fill(0);
    for (let i = 1; i <= n; i++) this.parent[i] = i;
  }

  find(a: number): number {
    if (this.parent[a] !== a) this.parent[a] = this.find(this.parent[a]); // path compression
    return this.parent[a];
  }

  union(a: number, b: number): void {
    let ra = this.find(a), rb = this.find(b);
    if (ra === rb) return;
    // union by rank
    if (this.rank[ra] < this.rank[rb]) this.parent[ra] = rb;
    else if (this.rank[rb] < this.rank[ra]) this.parent[rb] = ra;
    else {
      this.parent[rb] = ra;
      this.rank[ra]++;
    }
  }
}
```

#### ğŸ’¡ Key insight:

After processing all `connections`, each grid can be uniquely identified by its DSU root.
Any two stations `u` and `v` belong to the same grid iff `find(u) === find(v)`.

---

### ğŸ§º 2. Build Min-Heaps for Each Grid

For every grid (DSU root), we maintain a min-heap of all its stationsâ€™ IDs.
The top of the heap always holds the smallest station ID.

We use a generic heap (like `MyMinHeap` or LeetCodeâ€™s `MinHeap`).

```ts
const numCmp = (a: number, b: number) => a - b;
const compHeap = new Map<number, MyMinHeap<number>>(); // root â†’ heap

for (let node = 1; node <= c; node++) {
  const root = dsu.find(node);
  if (!compHeap.has(root)) compHeap.set(root, new MyMinHeap<number>(numCmp));
  compHeap.get(root)!.push(node);
}
```

ğŸ“˜ Each node is pushed exactly once,
so total heap building cost = `O(c log c)` (amortized).

---

### âš¡ 3. Track Online Stations

We use a simple `Set<number>` to track which stations are online.

Initially, all stations are online:

```ts
const online = new Set<number>();
for (let i = 1; i <= c; i++) online.add(i);
```

When a station goes offline (`[2, x]`),
we donâ€™t remove it from the heap â€” we simply remove it from `online`.
Offline stations remain in the heap until they reach the top,
at which point they are discarded lazily.

---

### ğŸ§¹ 4. Lazy Deletion Helper

Before reading the top of a heap, we `â€œcleanâ€` it â€”
popping all offline stations that have bubbled to the top.

```ts
function cleanTop(heap: MyMinHeap<number>) {
  while (!heap.isEmpty()) {
    const top = heap.top();
    if (top === null) break;
    if (online.has(top)) break;  // found online node
    heap.pop();  // stale offline node
  }
}
```
Each station can be popped at most once â†’ amortized `O(1)` per query.

---

### ğŸ§© 5. Process Queries

Now we handle the two query types:

```ts
const ans: number[] = [];

for (const [type, x] of queries) {
  if (type === 1) {
    if (online.has(x)) {
      ans.push(x);
    } else {
      const root = dsu.find(x);
      const heap = compHeap.get(root);
      if (!heap) { ans.push(-1); continue; }

      cleanTop(heap);
      ans.push(heap.isEmpty() ? -1 : heap.top()!);
    }
  } else {
    // type === 2
    online.delete(x);
  }
}
```

#### ğŸ’¡ Lazy Update Flow Diagram

```text
When station goes offline:       â†’  just remove from 'online'
When querying smallest online:   â†’  clean heap top lazily
                                   â†“
Heap[1] = [1, 2, 3]
offline = {2,3}
â†’ pop 1 â†’ still online âœ…
â†’ next time top=2 â†’ offline âŒ â†’ pop
â†’ next time top=3 â†’ offline âŒ â†’ pop
â†’ heap empty â†’ return -1
```
---

### ğŸ§® 6. Complexity Analysis

| Operation |	Complexity |	Notes |
| --------- | ---------- | ------ |
| DSU build |	O(n Â· Î±(c)) |	Î±(c) â‰ˆ constant |
| Heap build |	O(c log c) |	each node once |
| [1, x] query |	O(log c) amortized |	lazy pops only once per node |
| [2, x] query |	O(1) |	mark offline |
| --------- | ---------- | ------ |
| Total |	O((c + n + q) log c)** |	efficient for 10âµ constraints |

---

## ğŸ’» Section 5 â€” Full Code (TypeScript) + Comments

> Copy-paste this whole block into your solution. It is self-contained:
> - `MyMinHeap` (no collision with platform `MinHeap`)
> - `DSU` (Union-Find)
> - `processQueries` main function

```ts
// ---------- MyMinHeap (generic, stable, no platform dependency) ----------
class MyMinHeap<T> {
  private heap: T[] = [];
  private cmp: (a: T, b: T) => number;

  constructor(cmp?: (a: T, b: T) => number) {
    // default numeric comparator
    this.cmp = cmp ?? ((a: any, b: any) => (a < b ? -1 : a > b ? 1 : 0));
  }

  size(): number { return this.heap.length; }
  isEmpty(): boolean { return this.heap.length === 0; }
  top(): T | null { return this.heap.length ? this.heap[0] : null; }

  push(val: T): void {
    this.heap.push(val);
    this._siftUp(this.heap.length - 1);
  }

  pop(): T | null {
    const n = this.heap.length;
    if (n === 0) return null;
    if (n === 1) return this.heap.pop() as T;
    const top = this.heap[0];
    this.heap[0] = this.heap.pop() as T;
    this._siftDown(0);
    return top;
  }

  private _siftUp(idx: number) {
    const h = this.heap; const cmp = this.cmp;
    let i = idx;
    while (i > 0) {
      const p = Math.floor((i - 1) / 2);
      if (cmp(h[i], h[p]) < 0) { [h[i], h[p]] = [h[p], h[i]]; i = p; }
      else break;
    }
  }

  private _siftDown(idx: number) {
    const h = this.heap; const cmp = this.cmp;
    let i = idx;
    const n = h.length;
    while (true) {
      const l = 2 * i + 1, r = 2 * i + 2;
      let smallest = i;
      if (l < n && cmp(h[l], h[smallest]) < 0) smallest = l;
      if (r < n && cmp(h[r], h[smallest]) < 0) smallest = r;
      if (smallest === i) break;
      [h[i], h[smallest]] = [h[smallest], h[i]];
      i = smallest;
    }
  }
}

// ---------- DSU (Union-Find) ----------
class DSU {
  parent: number[];
  rank: number[];
  constructor(n: number) {
    this.parent = new Array(n + 1);
    this.rank = new Array(n + 1).fill(0);
    for (let i = 1; i <= n; i++) this.parent[i] = i;
  }
  find(a: number): number {
    if (this.parent[a] !== a) this.parent[a] = this.find(this.parent[a]);
    return this.parent[a];
  }
  union(a: number, b: number): void {
    let ra = this.find(a), rb = this.find(b);
    if (ra === rb) return;
    if (this.rank[ra] < this.rank[rb]) this.parent[ra] = rb;
    else if (this.rank[rb] < this.rank[ra]) this.parent[rb] = ra;
    else { this.parent[rb] = ra; this.rank[ra]++; }
  }
}

// ---------- Main function: processQueries ----------
function processQueries(c: number, connections: number[][], queries: number[][]): number[] {
  // 1) Build components with DSU
  const dsu = new DSU(c);
  for (const [u, v] of connections) dsu.union(u, v);

  // 2) Prepare per-component min-heaps (min station id on top)
  const compHeap = new Map<number, MyMinHeap<number>>();
  const numCmp = (a: number, b: number) => a - b;

  for (let node = 1; node <= c; node++) {
    const root = dsu.find(node);
    if (!compHeap.has(root)) compHeap.set(root, new MyMinHeap<number>(numCmp));
    compHeap.get(root)!.push(node);
  }

  // 3) Online set (initially all online)
  const online = new Set<number>();
  for (let i = 1; i <= c; i++) online.add(i);

  // Helper: lazy-clean the top of a heap so top() returns an online station or null
  function cleanTop(heap: MyMinHeap<number>) {
    while (!heap.isEmpty()) {
      const t = heap.top();
      if (t === null) break;
      if (online.has(t)) break;     // top is online â†’ done
      heap.pop();                   // stale (offline) â†’ remove and continue
    }
  }

  // 4) Process each query
  const ans: number[] = [];
  for (const [type, x] of queries) {
    if (type === 1) {
      // maintenance check
      if (online.has(x)) {
        // station itself is online -> resolves the check
        ans.push(x);
      } else {
        // station offline -> find smallest online in same component
        const root = dsu.find(x);
        const heap = compHeap.get(root);
        if (!heap) { ans.push(-1); continue; }  // should not happen but safe-guard

        cleanTop(heap);                         // lazy deletion of stale offline ids
        if (heap.isEmpty()) ans.push(-1);       // no online station found
        else ans.push(heap.top()!);             // smallest online station id
      }
    } else {
      // type === 2 -> take station x offline
      online.delete(x);
    }
  }

  return ans;
}
```

### Quick notes on the code block above

- `MyMinHeap` is small, fast, and generic â€” no reliance on platform-specific heap APIs.
- `DSU` uses path compression + union by rank for near-constant `find` times.
- `cleanTop` does lazy deletion: each offline station is popped from its component heap at most once overall, so the total cost of popping is amortized across queries.
- This code focuses on clarity and robustness â€” suitable for pasting into LeetCode or your blog.

---

## â± Section 6 â€” Complexity, Edge Cases & Proof

### 1) Time Complexity (precise)

Let:
- `c` = number of stations (nodes)
- `n` = number of connections (edges)
- `q` = number of queries
- `D` = distinct nodes popped across all heaps (â‰¤ c)

**Preprocessing**
- Building DSU by iterating `connections`: O(n Â· Î±(c)) where Î± is inverse Ackermann (practically constant).
- Building heaps: each node `1..c` is pushed once into its component heap â†’ total O(c Â· log c) in the worst case (amortized across heaps).

**Query processing**
- Type `[2, x]` (take offline): O(1) to remove from `online` set.
- Type `[1, x]` (maintenance check):
  - `find(x)`: O(Î±(c)) â‰ˆ constant.
  - `cleanTop(heap)`: pops stale offline nodes until a live one is found. Each pop costs O(log s) where `s` is heap size, but **each node can be popped at most once across the whole run**, so total cost of all pops across all queries is O(c Â· log c).
  - After cleaning, `top()` is O(1).

**Overall (amortized)**:
- Preprocessing: O(n Â· Î±(c) + c Â· log c)
- Queries: O(q Â· Î±(c) + c Â· log c) total (since popping is amortized once per node)
- Combined: **O((n + c + q) log c)** worst-case style bound, but more precisely:
  - O(n Â· Î±(c) + q Â· Î±(c) + c Â· log c + total_pops Â· log c)
  - total_pops â‰¤ c â†’ so amortized O((n + c + q) log c)

In practice Î±(c) â‰ˆ 1 and the dominating terms are the heap operations.

---

### 2) Space Complexity

- DSU arrays (`parent`, `rank`): O(c)
- Per-component heaps: each node lives in one heap â†’ O(c)
- `online` set: O(c)
- Minor overhead (maps, stack frames): O(c)

**Total:** **O(c)** (linear in number of stations)

---

### 3) Correctness â€” Why this always returns the smallest online station in the same grid

**Invariant 1 (DSU partition):**  
After processing all `connections` via `union`, DSU partitions nodes into connected components; `find(x)` uniquely identifies the grid containing `x`. Connectivity is static â€” taking nodes offline does not change DSU.

**Invariant 2 (heap contains all nodes of component):**  
Each component heap is initialized with all member node IDs. Heaps are only ever popped (to remove stale offline nodes). Therefore, at any time, the heap contains the subset of original nodes not yet popped (some may be offline but not yet popped).

**Query correctness:**
- If `x` is online â†’ clearly the answer is `x` by problem statement.
- If `x` is offline:
  - Let `r = find(x)` and let `H` be the heap for `r`.
  - We repeatedly pop top elements while they are offline. Because the heap is a min-heap of IDs, after removing all offline IDs that are â‰¤ current top, the new top (if any) is the smallest ID that is still present in the heap and online.
  - If `H` becomes empty â†’ there is no online station in the grid â†’ return `-1`.
  - Otherwise top(H) is the smallest online ID in the grid â†’ correct.

Thus the method meets the problem's rules.

---

### 4) Amortized reasoning for lazy deletion

- Each station is inserted once at preprocessing.
- When a station goes offline, we **do not** immediately remove it from its heap. We only remove it when it reaches the heap top during a subsequent `[1,x]` query for that component.
- Because a station can be popped at most once, the total number of `pop()` calls across all queries is â‰¤ `c`. Each `pop()` is O(log s). So amortized cost of lazy deletions is O((c Â· log c)/q) per query (spread across q queries).
- Therefore lazy deletion is efficient and avoids repeated costly removal operations.

---

### 5) Edge cases & handling

1. **No connections (`n = 0`)**  
   - Every station is its own component. Heaps contain singletons.
   - Queries behave correctly (smallest in same grid is itself or âˆ’1 if offline).

2. **All nodes go offline**  
   - Heaps get cleaned over time; queries return `-1` when no online node remains.

3. **Repeated `[2, x]` for same `x`**  
   - `online.delete(x)` is idempotent â€” repeated deletions do nothing.

4. **Query `[1, x]` for a node never connected in `connections` but offline**  
   - It still belongs to a singleton component; heap cleaning yields empty â†’ `-1`.

5. **Large components**  
   - Complexity remains amortized; heaps may be large but each node popped once.

6. **Memory and integer bounds**  
   - IDs range `1..c` and used only as keys; no overflow concerns.

---

### 6) Alternatives & trade-offs

- **Using ordered set / balanced BST (e.g., TreeSet)** per component:
  - Would support `erase(x)` in O(log s) when a node goes offline, avoiding lazy deletion.
  - Implementation in JS/TS requires a custom balanced tree (treap/red-black) â€” more code but deterministic removals.
  - Complexity: O(log s) per query for both types; no amortization needed.

- **Two-level global structure**:
  - Maintain a global ordered map `root -> ordered set of online nodes`.
  - On `[2, x]` remove `x` from its component's ordered set directly (O(log s)).
  - Similar complexity to above.

- **Your current design (DSU + per-component heap + lazy deletion)**:
  - Pros: simple, minimal code, amortized efficient.
  - Cons: occasional bursts of cleaning (multiple pops) during some queries, but amortized across run.

---

### 7) Quick sanity check (tiny test case)

Input:
c = 6
connections = [[1,2],[2,3],[4,5]]
queries = [[1,1],[2,1],[1,1],[1,4],[2,5],[1,4]]


Step-by-step:
- Initially online = {1,2,3,4,5,6}
- [1,1] => 1 (online)
- [2,1] => 1 offline
- [1,1] => find(1)=1, Heap[1] cleans 1, top becomes 2 => answer 2
- [1,4] => 4 (online)
- [2,5] => 5 offline
- [1,4] => find(4)=4, heap cleans  (5 popped if 5 had been smaller than 4) â€” top still 4 => answer 4

Matches expected behavior.

---

## âœ… Bottom line
- DSU gives constant-time component lookup; per-component min-heaps give fast smallest-ID retrieval; lazy deletion keeps operations amortized and simple.
- This approach is robust, memory-linear, and fits the problem constraints (`c, n, q <= 1e5`).






