# üß© Problem #1015 ‚Äì Smallest Integer Divisible by K

**Difficulty:** Medium  
**Topics:** `Math` 
**Link:** https://leetcode.com/problems/smallest-integer-divisible-by-k/

---

## üìù Problem Summary

You are given a positive integer `k`.

You must find the **length** of the smallest positive integer `n` such that:

1. `n` is divisible by `k`, and  
2. `n` consists of digits **only equal to `1`** (i.e., `1`, `11`, `111`, ...).

Return the **length** of such `n`.

If there is **no such `n`**, return `-1`.

Note:
- `n` itself may be extremely large and will not fit in any standard integer type, so we must avoid constructing it directly.
- Constraints: `1 <= k <= 10^5`.

---

## üí° Intuition

We are looking at numbers:

```text
1, 11, 111, 1111, ...
```

Let the i-th such number be `N_i`:

```text
N_1 = 1
N_2 = 11
N_3 = 111
...
```

We care about divisibility by `k`, not the actual big number.
Instead of storing `N_i` explicitly, we focus on the remainder:

```text
N_1      = 1
N_2      = N_1 * 10 + 1
N_3      = N_2 * 10 + 1
...
N_i      = N_{i-1} * 10 + 1

Let rem_i = N_i % k.

Then:
rem_1 = 1 % k
rem_i = (rem_{i-1} * 10 + 1) % k
```

We want the smallest i such that `rem_i == 0`.

Two key observations:

1. Any number made only of the digit `1` ends with `1`, so:
  - It can never be divisible by `2` or `5`.
  - So if k has factor `2` or `5` ‚Üí no solution ‚Üí answer `-1`.
  
2. There are only `k` possible remainders: `0, 1, ..., k-1`.
  - If we keep computing `rem_i`, then:
    - If we ever get `rem_i == 0`, we found the answer.
    - If after `k` steps we still haven‚Äôt seen `0`, some remainder has repeated ‚Üí the sequence of remainders cycles ‚Üí it will never hit `0` ‚Üí no solution.

---

## üçÉ Approach 1 ‚Äì Remainder Simulation

### Idea

1. Immediately handle impossible cases:
   - If `k` has factor `2` or `5`, no repunit (number with all 1s) is divisible by `k`:
     ```text
     if (k % 2 == 0 || k % 5 == 0) ‚Üí return -1
     ```

2. Otherwise, simulate building repunit remainders:

   ```text
   rem = 0
   for len in [1..k]:
       rem = (rem * 10 + 1) % k
       if rem == 0 ‚Üí answer = len
   If never saw 0 ‚Üí answer = -1
   ```
   
3. We only track `rem`, which is always in `[0, k-1]`. This avoids big integers and is mathematically correct.

### Why up to k iterations?

- There are only `k` different remainders mod k.
- If we never see `0` among `rem_1, rem_2, ..., rem_k`, then:
  - Either some remainder repeats, and from then on the sequence cycles.
  - If the cycle doesn‚Äôt include `0`, we will never get `0` later.
- So `k` is a safe upper bound on the length.

---

## üßæ Code ‚Äì Remainder Simulation (TypeScript)

```ts
function smallestRepunitDivByK(k: number): number {
    // If k has factor 2 or 5, no number of the form 111...1 is divisible by k
    if (k % 2 === 0 || k % 5 === 0) return -1;

    let rem = 0;

    // Try lengths from 1 up to k
    for (let len = 1; len <= k; len++) {
        rem = (rem * 10 + 1) % k;
        if (rem === 0) return len;
    }

    // If we never hit remainder 0, it's impossible
    return -1;
}
```

---

## üå± Approach 2 ‚Äì Remainder Cycle Perspective

This is conceptually the same as Approach 1, but phrased as a cycle detection:

### Idea

1. Maintain a `Set` of remainders seen so far.
2. Start with `rem = 0`, length `len = 0`.
3. In each step:
   - Compute:
     ```text
     rem = (rem * 10 + 1) % k
     len++
     ```
   - If `rem == 0`, return `len`.
   - If `rem` is already in the `Set`, we are in a cycle ‚Üí no solution ‚Üí return `-1`.
   - Else add `rem` to the `Set` and continue.

This directly uses the idea that if a remainder repeats, we‚Äôre stuck in a loop.

### Complexity

- Still `O(k)` time, `O(k)` space (for the `Set`).
- Less tight than Approach 1, but more explicit about cycle detection.

---

## üßæ Code ‚Äì Remainder Cycle with Set (TypeScript)

```ts
function smallestRepunitDivByK(k: number): number {
    if (k % 2 === 0 || k % 5 === 0) return -1;

    let rem = 0;
    let len = 0;
    const seen = new Set<number>();

    while (true) {
        rem = (rem * 10 + 1) % k;
        len++;

        if (rem === 0) return len;
        if (seen.has(rem)) return -1;

        seen.add(rem);
    }
}
```

---

## ‚è±Ô∏è Complexity

For Approach 1 (and effectively Approach 2 as well):

- In the worst case, we iterate at most `k` times.
- Each iteration does:
  - One multiplication
  - One addition
  - One modulo
- Extra memory is `O(1)` for Approach 1, `O(k)` for the Set-based cycle version.

So:

**Time:**  `O(k)`
**Space:** `O(1)`

---




    
