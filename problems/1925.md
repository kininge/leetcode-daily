# ğŸ§© Problem #1925 â€“ Count Square Sum Triples

**Difficulty:** Easy  
**Topics:** `Math`  
**Link:** https://leetcode.com/problems/count-square-sum-triples/

---

## ğŸ“ Problem Summary

A **square triple** is a triple of integers `(a, b, c)` such that:

```text
aÂ² + bÂ² = cÂ²
```
You are given an integer n.

You must return the number of square triples (a, b, c) such that:
```text
1 â‰¤ a, b, c â‰¤ n
```

Constraints:

1 â‰¤ n â‰¤ 250

---

## ğŸ’¡ Intuition

We are looking for all triples `(a, b, c)` with:
```text
aÂ² + bÂ² = cÂ²
1 â‰¤ a, b, c â‰¤ n
```


This is essentially counting **Pythagorean triples** bounded by `n`.

Since `n â‰¤ 250`, the range is small enough that:

- We can afford **nested loops** over `a` and `b`.
- For each pair `(a, b)` we can compute `aÂ² + bÂ²` and see if it is a **perfect square** `cÂ²` with `c â‰¤ n`.

Key ideas:

1. **Brute force is allowed**  
   - Maximum `n` is only 250 â†’ `a` and `b` loops give at most ~62,500 pairs.
   - This is perfectly fine for O(nÂ²) approaches.

2. **Fast perfect square check**  
   Instead of storing sums in a set and doing indirect matching, we can:
   - Precompute all `cÂ²` for `1 â‰¤ c â‰¤ n`.
   - Store them in:
     - a `Set<number>` for O(1) lookup, or
     - a boolean array `isSquare[s]` marking if `s` is some `cÂ²`.

3. **Ordered triples matter**  
   The problem counts `(a, b, c)` and `(b, a, c)` as **different** when `a â‰  b`.
   So the loops should consider all ordered pairs `(a, b)` (not just `a â‰¤ b`).

Your original idea tried to be clever with a `Set` of sums and deletion to avoid overcounting.  
However, we can make it much simpler:

- For each `(a, b)`, compute `s = aÂ² + bÂ²`.
- Check if `s` is in the precomputed square set.
- If yes, increment the answer.

This leads to a clean **O(nÂ²)** solution.

---

## ğŸƒ Approach 1 â€” Store `aÂ² + bÂ²` in a Set

### Idea

Your initial thought process (from comments):

```text
// a^2 + b^2 = x
// store x for further check
// if any number's square n^2 present in store --> ans += 2;
```
You tried to:

1. Generate values of aÂ² + bÂ² and store them in a Set.
2. When you later see a value that matches some cÂ², you count it as a valid triple.
3. Use ans += 2 to account for both (a, b, c) and (b, a, c).
5. Delete used sums from the set to avoid double-counting.

**Why this becomes messy**

- The set contains sums of the form aÂ² + bÂ², but you also check store.has(A) or store.has(B) where:
  - A = iÂ², B = jÂ²
  - This means youâ€™re checking whether some previous pair (p, q) had:
    ```text
    pÂ² + qÂ² = iÂ²   or   pÂ² + qÂ² = jÂ²
    ```
  - Deleting from the set (store.delete(A) / store.delete(B)) makes the logic hard to reason about:
    - You might accidentally remove a sum that could form another valid triple with different a, b, c.
  - The correctness becomes non-obvious and testing mentally is difficult.
  - Complexity is still O(nÂ²), but with a much higher brain cost.
 
**Takeaway**

Your idea to use a Set and avoid recomputation is good,
but for this problem we can simplify a lot by:

  - Precomputing all cÂ²,
  - Using a straightforward nested loop over (a, b),
  - Directly checking if aÂ² + bÂ² is one of those cÂ².

We keep the same time complexity, but the code becomes much easier to verify and reason about.

### ğŸ§¾ Code

```ts
function countTriples(n: number): number {
    const store = new Set();
    let ans:number = 0;
    
    // generate a^2
    for(let i=1; i<=n; i++){
        const A = Math.pow(i, 2);

        // check for answer 
        if(store.has(A)){
            ans += 2;

            store.delete(A)
        }
        // generate b^2
        for(let j=i; j<=n; j++){
            const B = Math.pow(j, 2);

            // check for answer 
            if(store.has(B)){
                ans += 2;
                
                store.delete(B)
            }
            
            store.add(A+B);
        }
    }

    return ans;
};
```

---

## ğŸŒ± Approach 2 â€” Precompute Squares and Check Sums

We want to count all ordered triples `(a, b, c)` such that:

```text
aÂ² + bÂ² = cÂ²
1 â‰¤ a, b, c â‰¤ n
```

Since n â‰¤ 250, we can afford an O(nÂ²) solution.

### Step 1 â€” Precompute all cÂ²

For every c in [1..n], compute cÂ² and store it:

  - Either in a Set<number>:
  ```text
  const squares = new Set<number>();
  for (let c = 1; c <= n; c++) {
      squares.add(c * c);
  }
  ```
  - This allows O(1) lookup:
  â€œIs `aÂ² + bÂ²` equal to some cÂ² within range?â€

### Step 2 â€” Try all ordered pairs (a, b)

Use two nested loops:
```text
for a = 1..n
  for b = 1..n
    s = aÂ² + bÂ²
    if s is in squares â†’ we found a valid (a, b, c)
```
We donâ€™t have to explicitly find c â€”
if s equals some `cÂ²` for `1 â‰¤ c â‰¤ n`, then a valid c exists.

### Step 3 â€” Ordered triples

The problem counts ordered triples:

- `(a, b, c)` and `(b, a, c)` are both valid and distinct when a â‰  b.
- Our double loop already handles that because:
  - `(a, b)` and `(b, a)` are visited separately.

So we just increment ans by `1` for each `(a, b)` whose sum is a square.

This gives:

- Clean logic
- Easy correctness reasoning
- Same `O(nÂ²)` time, `O(n)` space for the set

### ğŸ§¾ Code (Precompute Squares + Double Loop)

```ts
function countTriples(n: number): number {
    // Precompute all cÂ² for 1 â‰¤ c â‰¤ n
    const squares = new Set<number>();
    for (let c = 1; c <= n; c++) {
        squares.add(c * c);
    }

    let ans = 0;

    // Try all ordered pairs (a, b)
    for (let a = 1; a <= n; a++) {
        const aa = a * a; // precompute aÂ² once per a
        for (let b = 1; b <= n; b++) {
            const s = aa + b * b; // aÂ² + bÂ²
            if (squares.has(s)) {
                ans++; // (a, b, c) exists for some c
            }
        }
    }

    return ans;
}
```

---

## ğŸ“Š Complexity & Comparison

### Approach 1 â€” Your Set-Based Sum Storage

- **Idea:**  
  - Store values of `aÂ² + bÂ²` in a `Set`.
  - When a value matches some square, update the count and delete from the set.
- **Time Complexity:** O(nÂ²) (nested loops over `a` and `b`)
- **Space Complexity:** Up to O(nÂ²) in the worst case (many sums stored)
- **Issues:**
  - Logic becomes hard to reason about:
    - Deleting from the set can cause potential missed combinations.
    - Matching on `A`/`B` (iÂ²/jÂ²) and maintaining `ans += 2` is subtle.
  - Correctness is non-obvious without lots of testing.

---

### Approach 2 â€” Precompute Squares + Double Loop (Recommended)

- **Time Complexity:** O(nÂ²)
  - Two nested loops over `a` and `b` (each from 1 to n).
  - O(1) `Set` lookup for `aÂ² + bÂ²`.
- **Space Complexity:** O(n)
  - We only store `n` squares: `cÂ²` for `1 â‰¤ c â‰¤ n`.

- **Pros:**
  - Very easy to read and understand.
  - Directly models the math: for each `(a, b)`, check if `aÂ² + bÂ²` is a perfect square within bounds.
  - Naturally counts ordered triples `(a, b, c)`.

---

### Summary

Both approaches aim for O(nÂ²), but:

- Your original approach is **more complex** and harder to verify.
- The precomputed-square approach is:
  - cleaner,
  - safer,
  - and much more â€œinterview-friendlyâ€.

---


