# ğŸ§© Problem #3147 â€“ Taking Maximum Energy From the Mystic Dungeon

**Difficulty:** Medium  
**Topics:** `Dynamic Programming`, `Kadaneâ€™s Algorithm`, `Prefix Sum`  
**Link:** [LeetCode](https://leetcode.com/problems/taking-maximum-energy-from-the-mystic-dungeon/)

---

## ğŸ“œ Problem Summary
You are given:
- An integer array `energy`, where `energy[i]` is the energy (can be negative) from the `i-th` magician.
- An integer `k`, representing a teleport jump size.

After absorbing energy from magician `i`, you are instantly teleported to magician `(i + k)` until you can no longer move.  
You can **start at any magician**, and you must absorb all energies along your teleport path.

Return the **maximum total energy** you can gain.

---

## ğŸ’¡ Approach 1 â€“ Brute Force (O(NÂ²))

### ğŸ§© Idea
For each starting magician `i`, simulate the jumps:
- Keep adding `energy[i]` â†’ `energy[i + k]` â†’ `energy[i + 2k]` â†’ â€¦ until out of bounds.
- Record the total energy collected.

Take the maximum among all possible starting indices.

### ğŸ§® Complexity
| Metric | Value |
|---------|--------|
| Time | **O(NÂ²)** |
| Space | **O(1)** |

---

### ğŸ’» Code
```Typescript []
function maximumEnergy(energy: number[], k: number): number {
  const n: number = energy.length;
  let maxEnergy: number = Number.NEGATIVE_INFINITY;

  for (let i = 0; i < n; i++) {
    let total = 0;
    let idx = i;
    while (idx < n) {
      total += energy[idx];
      idx += k;
    }
    maxEnergy = Math.max(maxEnergy, total);
  }

  return maxEnergy;
}
```
---

## ğŸ’¡ Approach 2 â€“ Optimized DP (Kadane on K-Chains) â€” O(N)

### ğŸ§© Core Idea

The magicians form k independent chains:

```plaintext
Chain 0: 0, k, 2k, 3k, ...
Chain 1: 1, 1+k, 1+2k, ...
...
Chain (k-1): ...
```

- You can only move forward within a chain.
- For each chain, we can use Kadaneâ€™s algorithm to compute the maximum subarray sum (step size `k`).
- Every path ends at one of the last `k` indices, so we only check those for the result.

### ğŸ§  Intuition

We can carry over the best energy sum from `i-k` to `i` if they belong to the same chain.

```plaintext
energy[i] = max(energy[i], energy[i] + energy[i - k])
```

Thatâ€™s basically **Kadaneâ€™s algorithm**, but applied independently across `k` parallel sequences â€” one for each residue `mod k`.

ğŸ‘‰ **Hint**: Think of indices modulo `k` as independent chains â€” youâ€™re just running Kadane on each chain but rolling all chains in one pass. Thatâ€™s why this in-place trick works.

### ğŸ§® Complexity

| Metric |	Value |
| ---- | ---- |
| Time |	O(N) |
| Space |	O(1) (in-place) |

### ğŸ’» Final Code (Optimized O(N))

```Typescript []
function maximumEnergy(energy: number[], k: number): number {
  const n = energy.length;
  const NEG = Number.NEGATIVE_INFINITY;
  let maxEnergy = NEG;

  for (let i = 0; i < n; i++) {
    const carriedSum = (i < k) ? NEG : energy[i - k];
    energy[i] = Math.max(energy[i], energy[i] + carriedSum);

    if (i >= n - k) {
      maxEnergy = Math.max(maxEnergy, energy[i]);
    }
  }

  return maxEnergy;
}
```

### ğŸ§© Example Walkthrough

Input:

```plaintext
energy = [5, -10, 5, 2]
k = 2
```

Step-by-step:

| Index |	Energy[i] |	Carried From (i-k) |	Updated Value |	Explanation |
| ---- | ---- | ---- | ---- | ---- |
| 0 |	5 |	-âˆ |	5 |	Starting new chain |
| 1 |	-10 |	-âˆ |	-10 |	Starting new chain |
| 2 |	5 |	5 |	10 |	Extends from index 0 |
| 3 |	2 |	-10 |	2 |	Better to start fresh |

âœ… Last `k` elements: `[10, 2]` â†’ **maxEnergy = 10**

âœ… Output:

```plaintext
10
```

### ğŸ” Comparison of Approaches

| Feature |	Brute Force |	Kadane on K-Chains |
| ---- | ---- | ---- |
| Time |	O(NÂ²) |	O(N) |
| Space |	O(1) |	O(1) |
| Logic |	Simulate every path |	Reuse results along each chain |
| Practical Use |	For small N only |	âœ… Best for large constraints |

---

## ğŸ† Final Notes

- The DP version is effectively Kadaneâ€™s Algorithm stretched across `k` modular chains.
- Works in-place, no extra arrays required.
- Each index `i` reuses optimal energy from index `i - k` (same chain).
- The final answer always lies among the last `k` indices because teleportation ends there.

> ğŸ’¬ Hint Recap: â€œThink of indices modulo `k` as independent chains â€” youâ€™re just running Kadane on each chain but rolling all chains in one pass.â€
