# 🧩 Problem #3147 – Taking Maximum Energy From the Mystic Dungeon

**Difficulty:** Medium  
**Topics:** `Dynamic Programming`, `Kadane’s Algorithm`, `Prefix Sum`  
**Link:** [LeetCode](https://leetcode.com/problems/taking-maximum-energy-from-the-mystic-dungeon/)

---

## 📜 Problem Summary
You are given:
- An integer array `energy`, where `energy[i]` is the energy (can be negative) from the `i-th` magician.
- An integer `k`, representing a teleport jump size.

After absorbing energy from magician `i`, you are instantly teleported to magician `(i + k)` until you can no longer move.  
You can **start at any magician**, and you must absorb all energies along your teleport path.

Return the **maximum total energy** you can gain.

---

## 💡 Approach 1 – Brute Force (O(N²))

### 🧩 Idea
For each starting magician `i`, simulate the jumps:
- Keep adding `energy[i]` → `energy[i + k]` → `energy[i + 2k]` → … until out of bounds.
- Record the total energy collected.

Take the maximum among all possible starting indices.

### 🧮 Complexity
| Metric | Value |
|---------|--------|
| Time | **O(N²)** |
| Space | **O(1)** |

---

### 💻 Code
```Typescript []
function maximumEnergy(energy: number[], k: number): number {
  const n: number = energy.length;
  let maxEnergy: number = Number.NEGATIVE_INFINITY;

  for (let i = 0; i < n; i++) {
    let total = 0;
    let idx = i;
    while (idx < n) {
      total += energy[idx];
      idx += k;
    }
    maxEnergy = Math.max(maxEnergy, total);
  }

  return maxEnergy;
}
```
---

## 💡 Approach 2 – Optimized DP (Kadane on K-Chains) — O(N)

### 🧩 Core Idea

The magicians form k independent chains:

```plaintext
Chain 0: 0, k, 2k, 3k, ...
Chain 1: 1, 1+k, 1+2k, ...
...
Chain (k-1): ...
```

- You can only move forward within a chain.
- For each chain, we can use Kadane’s algorithm to compute the maximum subarray sum (step size `k`).
- Every path ends at one of the last `k` indices, so we only check those for the result.

### 🧠 Intuition

We can carry over the best energy sum from `i-k` to `i` if they belong to the same chain.

```plaintext
energy[i] = max(energy[i], energy[i] + energy[i - k])
```

That’s basically **Kadane’s algorithm**, but applied independently across `k` parallel sequences — one for each residue `mod k`.

👉 **Hint**: Think of indices modulo `k` as independent chains — you’re just running Kadane on each chain but rolling all chains in one pass. That’s why this in-place trick works.

### 🧮 Complexity

| Metric |	Value |
| ---- | ---- |
| Time |	O(N) |
| Space |	O(1) (in-place) |

### 💻 Final Code (Optimized O(N))

```Typescript []
function maximumEnergy(energy: number[], k: number): number {
  const n = energy.length;
  const NEG = Number.NEGATIVE_INFINITY;
  let maxEnergy = NEG;

  for (let i = 0; i < n; i++) {
    const carriedSum = (i < k) ? NEG : energy[i - k];
    energy[i] = Math.max(energy[i], energy[i] + carriedSum);

    if (i >= n - k) {
      maxEnergy = Math.max(maxEnergy, energy[i]);
    }
  }

  return maxEnergy;
}
```

### 🧩 Example Walkthrough

Input:

```plaintext
energy = [5, -10, 5, 2]
k = 2
```

Step-by-step:

| Index |	Energy[i] |	Carried From (i-k) |	Updated Value |	Explanation |
| ---- | ---- | ---- | ---- | ---- |
| 0 |	5 |	-∞ |	5 |	Starting new chain |
| 1 |	-10 |	-∞ |	-10 |	Starting new chain |
| 2 |	5 |	5 |	10 |	Extends from index 0 |
| 3 |	2 |	-10 |	2 |	Better to start fresh |

✅ Last `k` elements: `[10, 2]` → **maxEnergy = 10**

✅ Output:

```plaintext
10
```

### 🔍 Comparison of Approaches

| Feature |	Brute Force |	Kadane on K-Chains |
| ---- | ---- | ---- |
| Time |	O(N²) |	O(N) |
| Space |	O(1) |	O(1) |
| Logic |	Simulate every path |	Reuse results along each chain |
| Practical Use |	For small N only |	✅ Best for large constraints |

---

## 🏆 Final Notes

- The DP version is effectively Kadane’s Algorithm stretched across `k` modular chains.
- Works in-place, no extra arrays required.
- Each index `i` reuses optimal energy from index `i - k` (same chain).
- The final answer always lies among the last `k` indices because teleportation ends there.

> 💬 Hint Recap: “Think of indices modulo `k` as independent chains — you’re just running Kadane on each chain but rolling all chains in one pass.”
