# 🧩 Problem #3346 – Maximum Frequency of an Element After Performing Operations I

**Difficulty:** Medium  
**Topics:** `Sorting`, `Two Pointers`, `Greedy`, `Hash Map`  
**Link:** [Leetcode](https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-i/)

---

## 🧠 Intuition

We are allowed to pick `numOperations` elements and change each by adding any integer in the range `[-k, k]`.  
We want to maximise the **frequency of a single element** after all such operations.

Think of every element `nums[i]` as an **interval** `[nums[i] - k, nums[i] + k]` — meaning, this element can be changed to any value inside that range.  
If multiple intervals overlap at a point `x`, then those elements can all be converted into `x`.

So, our target is to find **the value `x` covered by the maximum number of intervals**, where at most `numOperations` new elements can be changed to match `x`.

---

## 💡 Brute Force Approach

### 🔍 Idea  
Try all possible target values between the minimum and maximum numbers in the array, and for each possible value, count:
1. How many numbers are already equal to it?  
2. How many can be changed to it within the range `[-k, k]`?  

If we can still perform operations (≤ `numOperations`), we increase their frequency accordingly.

### 💻 Code
```Typescript []
function maxFrequency(nums: number[], k: number, numOperations: number): number {
    let n:number = nums.length;
    nums.sort((a,b)=> a-b);

    let maxFrequencyCount:number = 0;

    // Try every possible value between min and max
    for(let i=nums[0]; i<=nums[n-1]; i++){
        let count:number = 0;
        let operation:number = 0;

        for(let j=0; j<n; j++){
            if(i === nums[j]) {
                count++;
            }
            else if(i > nums[j]) {
                // Can we increase nums[j] to reach i?
                if((i <= (nums[j]+k)) && (operation < numOperations)) {
                    count++;
                    operation++;
                }
            } else {
                // Can we decrease nums[j] to reach i?
                if((i >= (nums[j]-k)) && (operation < numOperations)) {
                    count++;
                    operation++;
                }
            }
        }

        maxFrequencyCount = Math.max(maxFrequencyCount, count);
    }

    return maxFrequencyCount;
};
```

### ⏱️ Complexity

**Time:** `O(n * range)` — not efficient for large input.
**Space:** `O(1)`

### ⚙️ Notes

- ✅ Works correctly for small constraints.
- ❌ But slow when nums[i] values are large (up to 1e5), since we iterate over every possible integer.

---

## ⚡ Optimized Approach – Sorting + Two Pointers + HashMap

### 💡 Idea

Instead of iterating through every integer, we can:

1. Sort the array.
2. Use two pointers to find which elements can reach a specific target value using the allowed `k`.
3. Use a HashMap to store the original frequency of each number.

For each possible target `num`, find all numbers that can be converted into it (`nums[j]` satisfying `num ∈ [nums[j]-k, nums[j]+k]`).

The frequency for that target = `sameElements + min(otherElements, numOperations)`

### 💻 Code

```Typescript []
function maxFrequency(nums: number[], k: number, numOperations: number): number {
    let n:number = nums.length;

    nums.sort((a,b)=> a-b);

    // store frequency of each number
    const store:Map<number, number> = new Map();
    for(const num of nums){
        store.set(num, (store.get(num) ?? 0) + 1);
    }

    let maxFrequencyCount:number = 0;
    let leftIndex:number = 0;
    let rightIndex:number = 0;

    for(let num=nums[0]; num<=nums[n-1]; num++){
        // expand right pointer
        while((rightIndex < n) && ((nums[rightIndex]-k) <= num)) rightIndex++;

        // contract left pointer
        while((leftIndex <= rightIndex) && ((nums[leftIndex]+k) < num)) leftIndex++;

        // number of elements whose range includes 'num'
        let possibleElements:number = rightIndex - leftIndex;
        const sameElements:number = store.get(num) ?? 0;

        // we can change up to numOperations of the remaining ones
        possibleElements = Math.min(possibleElements - sameElements, numOperations) + sameElements;

        maxFrequencyCount = Math.max(maxFrequencyCount, possibleElements);
    }

    return maxFrequencyCount;
};
```

### ⏱️ Complexity

**Time:** `O(n log n)` — sorting dominates, and each element is visited at most twice by two pointers.
**Space:** `O(n)` — for the frequency map.

---

## 🔬 Comparison Summary

| Approach |	Time |	Space |
| -------- | ----- | ------ |
| Brute Force |	`O(n * range)` |	`O(1)` |
| Sorting + 2 Pointers |	`O(n log n)` |	`O(n)` |

---

## 🧩 Takeaway

- Treating each number as an interval is the key insight.
- The brute force helps understand the logic.
- The sorted two-pointer + hashmap approach gives a clean `O(n log n)` solution.
- Always think in ranges when dealing with `±k` type problems.
