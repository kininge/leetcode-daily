# ðŸ§© Problem #3346 â€“ Maximum Frequency of an Element After Performing Operations I

**Difficulty:** Medium  
**Topics:** `Sorting`, `Two Pointers`, `Greedy`, `Hash Map`  
**Link:** [Leetcode](https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-i/)

---

## ðŸ§  Intuition

We are allowed to pick `numOperations` elements and change each by adding any integer in the range `[-k, k]`.  
We want to maximise the **frequency of a single element** after all such operations.

Think of every element `nums[i]` as an **interval** `[nums[i] - k, nums[i] + k]` â€” meaning, this element can be changed to any value inside that range.  
If multiple intervals overlap at a point `x`, then those elements can all be converted into `x`.

So, our target is to find **the value `x` covered by the maximum number of intervals**, where at most `numOperations` new elements can be changed to match `x`.

---

## ðŸ’¡ Brute Force Approach

### ðŸ” Idea  
Try all possible target values between the minimum and maximum numbers in the array, and for each possible value, count:
1. How many numbers are already equal to it?  
2. How many can be changed to it within the range `[-k, k]`?  

If we can still perform operations (â‰¤ `numOperations`), we increase their frequency accordingly.

### ðŸ’» Code
```Typescript []
function maxFrequency(nums: number[], k: number, numOperations: number): number {
    let n:number = nums.length;
    nums.sort((a,b)=> a-b);

    let maxFrequencyCount:number = 0;

    // Try every possible value between min and max
    for(let i=nums[0]; i<=nums[n-1]; i++){
        let count:number = 0;
        let operation:number = 0;

        for(let j=0; j<n; j++){
            if(i === nums[j]) {
                count++;
            }
            else if(i > nums[j]) {
                // Can we increase nums[j] to reach i?
                if((i <= (nums[j]+k)) && (operation < numOperations)) {
                    count++;
                    operation++;
                }
            } else {
                // Can we decrease nums[j] to reach i?
                if((i >= (nums[j]-k)) && (operation < numOperations)) {
                    count++;
                    operation++;
                }
            }
        }

        maxFrequencyCount = Math.max(maxFrequencyCount, count);
    }

    return maxFrequencyCount;
};
```

### â±ï¸ Complexity

**Time:** `O(n * range)` â€” not efficient for large input.
**Space:** `O(1)`

### âš™ï¸ Notes

- âœ… Works correctly for small constraints.
- âŒ But slow when nums[i] values are large (up to 1e5), since we iterate over every possible integer.

---

## âš¡ Optimized Approach â€“ Sorting + Two Pointers + HashMap

### ðŸ’¡ Idea

Instead of iterating through every integer, we can:

1. Sort the array.
2. Use two pointers to find which elements can reach a specific target value using the allowed `k`.
3. Use a HashMap to store the original frequency of each number.

For each possible target `num`, find all numbers that can be converted into it (`nums[j]` satisfying `num âˆˆ [nums[j]-k, nums[j]+k]`).

The frequency for that target = `sameElements + min(otherElements, numOperations)`

### ðŸ’» Code

```Typescript []
function maxFrequency(nums: number[], k: number, numOperations: number): number {
    let n:number = nums.length;

    nums.sort((a,b)=> a-b);

    // store frequency of each number
    const store:Map<number, number> = new Map();
    for(const num of nums){
        store.set(num, (store.get(num) ?? 0) + 1);
    }

    let maxFrequencyCount:number = 0;
    let leftIndex:number = 0;
    let rightIndex:number = 0;

    for(let num=nums[0]; num<=nums[n-1]; num++){
        // expand right pointer
        while((rightIndex < n) && ((nums[rightIndex]-k) <= num)) rightIndex++;

        // contract left pointer
        while((leftIndex <= rightIndex) && ((nums[leftIndex]+k) < num)) leftIndex++;

        // number of elements whose range includes 'num'
        let possibleElements:number = rightIndex - leftIndex;
        const sameElements:number = store.get(num) ?? 0;

        // we can change up to numOperations of the remaining ones
        possibleElements = Math.min(possibleElements - sameElements, numOperations) + sameElements;

        maxFrequencyCount = Math.max(maxFrequencyCount, possibleElements);
    }

    return maxFrequencyCount;
};
```

### â±ï¸ Complexity

**Time:** `O(n log n)` â€” sorting dominates, and each element is visited at most twice by two pointers.
**Space:** `O(n)` â€” for the frequency map.

---

## ðŸ”¬ Comparison Summary

| Approach |	Time |	Space |
| -------- | ----- | ------ |
| Brute Force |	`O(n * range)` |	`O(1)` |
| Sorting + 2 Pointers |	`O(n log n)` |	`O(n)` |

---

## ðŸ§© Takeaway

- Treating each number as an interval is the key insight.
- The brute force helps understand the logic.
- The sorted two-pointer + hashmap approach gives a clean `O(n log n)` solution.
- Always think in ranges when dealing with `Â±k` type problems.
