# ðŸ§© Problem 3025 - Find the Number of Ways to Place People I  

**Difficulty:** Medium  
**Tags:** Geometry, Prefix Sum  

---

## ðŸ§  Intuition  
We need to count pairs `(A, B)` such that:  
- `A` lies **top-left** of `B` (`xA < xB && yA < yB`),  
- No other point lies **inside or on** the rectangle formed by `(A, B)`.  

Key insights:  
- `n â‰¤ 50` and coordinates â‰¤ 50 â†’ very small search space.  
- Multiple strategies are possible:
  1. Brute force all pairs and scan â†’ O(nÂ³).  
  2. Use a **prefix sum grid** over 51Ã—51 space to check emptiness in O(1).  
  3. Coordinate-bound sweeps â†’ constant time since max grid is fixed.  

---

## ðŸ’¡ Approach 1 â€” Brute Force O(nÂ³)  
1. Pick all pairs `(A, B)` with `xA < xB && yA < yB`.  
2. Scan all other points â†’ check if any lie in rectangle `[xA, xB] Ã— [yA, yB]`.  
3. Count only if rectangle contains exactly A and B.  

```javascript []
var numberOfPairs = function(points) {
    let n = points.length;
    let ans = 0;

    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            if (points[i][0] < points[j][0] && points[i][1] < points[j][1]) {
                let valid = true;
                for (let k = 0; k < n; k++) {
                    if (k === i || k === j) continue;
                    let [x, y] = points[k];
                    if (points[i][0] <= x && x <= points[j][0] &&
                        points[i][1] <= y && y <= points[j][1]) {
                        valid = false;
                        break;
                    }
                }
                if (valid) ans++;
            }
        }
    }
    return ans;
};
```

### Complexity:

- Time = O(nÂ³), 
- Space = O(1).

---

## Approach 2 â€” Prefix Sum Grid O(nÂ²)

- 1. Build a `51Ã—51` binary grid where `grid[x][y] = 1` if point exists.
- 2. Precompute 2D prefix sums.
- 3. For each pair (A, B):
- - Query rectangle [xA, xB] Ã— [yA, yB] in O(1).
- - If total points = 2 â†’ valid. 

```javascript []
var numberOfPairs = function(points) {
    points.sort((a, b) => a[0] - b[0]); // sort by x
    let n = points.length, ans = 0;

    for (let i = 0; i < n; i++) {
        for (let j = i+1; j < n; j++) {
            if (points[i][0] < points[j][0] && points[i][1] < points[j][1]) {
                let valid = true;
                for (let k = i+1; k < j; k++) {
                    let [x, y] = points[k];
                    if (points[i][0] <= x && x <= points[j][0] &&
                        points[i][1] <= y && y <= points[j][1]) {
                        valid = false;
                        break;
                    }
                }
                if (valid) ans++;
            }
        }
    }
    return ans;
};
```
### Complexity:

- where C=50
- Time = O(nÂ² + CÂ²) ~= O(nÂ²)
- Space = O(CÂ²) ~= O(1)

---

### âœ… Approach 3 â€” Grid Sweep O(1)

- 1. Traverse the grid row by row.
- 2. Maintain horizontal depth counters (distance since last point).
- 3. When encountering a new point, check downward in column with pruning.
- 4. Because C=50 is fixed, this is constant time. 

```javascript []
var numberOfPairs = function(points) {
    const MAX = 51;
    let grid = Array.from({ length: MAX+1 }, () => new Array(MAX+1).fill(0));

    // mark points
    for (const [x, y] of points) grid[x][y] = 1;

    // build prefix sum
    for (let i = 0; i <= MAX; i++) {
        for (let j = 1; j <= MAX; j++) {
            grid[i][j] += grid[i][j-1];
        }
    }
    for (let j = 0; j <= MAX; j++) {
        for (let i = 1; i <= MAX; i++) {
            grid[i][j] += grid[i-1][j];
        }
    }

    let ans = 0;
    let n = points.length;

    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            let [x1, y1] = points[i];
            let [x2, y2] = points[j];
            if (x1 < x2 && y1 < y2) {
                // count points in rectangle [x1, x2] Ã— [y1, y2]
                let total = grid[x2][y2]
                          - grid[x1-1]?.[y2] ?? 0
                          - grid[x2][y1-1] ?? 0
                          + grid[x1-1]?.[y1-1] ?? 0;
                if (total === 2) ans++; // only A and B exist
            }
        }
    }
    return ans;
};
```

### Complexity:

- C = 50
- Time = O(CÂ³) ~= O(1) 
- Space = O(CÂ²) ~= O(1)

---

## ðŸ“Š Comparison  

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Brute Force | O(nÂ³) | O(1) | Simplest and direct |
| Strict Prefix Sum | O(nÂ²) | O(1) | Best mix of clarity + speed |
| Grid Sweep | O(1) | O(1) | Overkill but elegant, coordinate-bound |
