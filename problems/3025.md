# ðŸ§© Problem #3025 â€“ Find the Number of Ways to Place People I  

**Difficulty:** Medium  
**Topics:** `Geometry`, `Brute Force`, `Prefix Sum`  
**Link:** [Leetcode](https://leetcode.com/problems/find-the-number-of-ways-to-place-people-i/description/)  

---

## Problem Statement  

You are given a 2D array `points` of size `n Ã— 2` representing integer coordinates of some points on a 2D plane, where `points[i] = [xi, yi]`.  

Count the number of pairs of points `(A, B)` where:  
1. `A` is on the **upper left** side of `B`.  
2. The rectangle (or line) formed by `A` and `B` contains **no other point** (including borders).  

Return the count.  

---

## Constraints
- `2 <= n <= 50`  
- `0 <= xi, yi <= 50`  
- All `points[i]` are distinct  

---

## ðŸ”Ž Approaches  

### âœ… Approach 1: Brute Force â€“ O(nÂ³)  

**Logic:**  
- Iterate over every possible pair `(A, B)`.  
- Condition: `xA < xB && yA < yB`.  
- For each pair, scan through all other points.  
  - If any point lies inside the rectangle `[xA, xB] Ã— [yA, yB]`, mark it invalid.  
- Otherwise, count it as a valid pair.  

**Key points:**  
- Direct and easy to implement.  
- For each pair, checking all points gives the third loop â†’ O(nÂ³).  
- Since `n â‰¤ 50`, still runs within limits.  

```javascript []
var numberOfPairs = function(points) {
    let n = points.length;
    let ans = 0;

    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            if (points[i][0] < points[j][0] && points[i][1] < points[j][1]) {
                let valid = true;
                for (let k = 0; k < n; k++) {
                    if (k === i || k === j) continue;
                    let [x, y] = points[k];
                    if (points[i][0] <= x && x <= points[j][0] &&
                        points[i][1] <= y && y <= points[j][1]) {
                        valid = false;
                        break;
                    }
                }
                if (valid) ans++;
            }
        }
    }
    return ans;
};
```

---

### âœ… Approach 2: Strict O(nÂ²) with Prefix Sum Grid  

**Logic:**  
- Observing the constraints: all coordinates are between `0` and `50`.  
- Build a **binary grid (51Ã—51)** where `grid[x][y] = 1` if a point exists at `(x, y)`.  
- Precompute a **2D prefix sum**. Each cell `(i, j)` tells how many points are inside rectangle `(0,0) â†’ (i,j)`.  

**How to check rectangle emptiness:**  
- Suppose two points are `A(x1, y1)` and `B(x2, y2)` with `x1 < x2, y1 < y2`.  
- Using prefix sum, count how many points are inside rectangle `[x1, x2] Ã— [y1, y2]`.  
- If this count equals `2`, it means only `A` and `B` are inside â†’ valid pair.  

**Why O(nÂ²):**  
- Checking each pair takes O(1) (thanks to prefix sum).  
- There are O(nÂ²) pairs â†’ total O(nÂ²).  

**Key points:**  
- Very clean, always strictly O(nÂ²).  
- Uses only ~2500 extra memory (constant).  
- This is the best balance between readability and efficiency.  

```javascript []
var numberOfPairs = function(points) {
    points.sort((a, b) => a[0] - b[0]); // sort by x
    let n = points.length, ans = 0;

    for (let i = 0; i < n; i++) {
        for (let j = i+1; j < n; j++) {
            if (points[i][0] < points[j][0] && points[i][1] < points[j][1]) {
                let valid = true;
                for (let k = i+1; k < j; k++) {
                    let [x, y] = points[k];
                    if (points[i][0] <= x && x <= points[j][0] &&
                        points[i][1] <= y && y <= points[j][1]) {
                        valid = false;
                        break;
                    }
                }
                if (valid) ans++;
            }
        }
    }
    return ans;
};
```

---

### âœ… Approach 3: Coordinate-Bound Sweep â€“ O(1)  

**Logic:**  
- Build a 51Ã—51 grid again, but instead of prefix sums, we scan it row by row.  
- While traversing, maintain a **horizontal depth counter** (distance from last point in row).  
- When a new point is found, use this counter to prune searches quickly.  
- Then check vertical directions for possible pairs.  
- Because both dimensions are bounded by 50, the maximum operations are limited to about `50 Ã— 50 Ã— 50 = 125k`.  

**Why O(1):**  
- The runtime depends only on coordinate limit (50), not `n`.  
- Even if `n` were much larger, the scan doesnâ€™t grow.  
- Thus complexity is O(CÂ³) where `C=50`, which is effectively O(1).  

**Key points:**  
- Over-engineered for `n=50`.  
- Nice if this problem had `n` in thousands but still bounded coordinates.  
- Clever but harder to understand compared to prefix sum.  

```javascript []
var numberOfPairs = function(points) {
    const MAX = 51;
    let grid = Array.from({ length: MAX+1 }, () => new Array(MAX+1).fill(0));

    // mark points
    for (const [x, y] of points) grid[x][y] = 1;

    // build prefix sum
    for (let i = 0; i <= MAX; i++) {
        for (let j = 1; j <= MAX; j++) {
            grid[i][j] += grid[i][j-1];
        }
    }
    for (let j = 0; j <= MAX; j++) {
        for (let i = 1; i <= MAX; i++) {
            grid[i][j] += grid[i-1][j];
        }
    }

    let ans = 0;
    let n = points.length;

    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            let [x1, y1] = points[i];
            let [x2, y2] = points[j];
            if (x1 < x2 && y1 < y2) {
                // count points in rectangle [x1, x2] Ã— [y1, y2]
                let total = grid[x2][y2]
                          - grid[x1-1]?.[y2] ?? 0
                          - grid[x2][y1-1] ?? 0
                          + grid[x1-1]?.[y1-1] ?? 0;
                if (total === 2) ans++; // only A and B exist
            }
        }
    }
    return ans;
};
```

---

## ðŸ“Š Comparison  

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Brute Force | O(nÂ³) | O(1) | Simplest and direct |
| Strict Prefix Sum | O(nÂ²) | O(1) | Best mix of clarity + speed |
| Grid Sweep | O(1) | O(1) | Overkill but elegant, coordinate-bound |
