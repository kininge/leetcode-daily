# üß© Problem #3531 ‚Äì Count Covered Buildings

**Difficulty:** Medium  
**Topics:** `Hash Map`, `Matrix`    
**Link:** https://leetcode.com/problems/count-covered-buildings/

---

## üìù Problem Summary

You are given an integer `n` representing an `n x n` city and an array `buildings`, where each `buildings[i] = [x, y]` denotes a unique building at coordinates `(x, y)` (1-based).

A building is **covered** if there exists at least one building strictly to its:
- left (same `x`, smaller `y`),
- right (same `x`, larger `y`),
- above (same `y`, smaller `x`),
- below (same `y`, larger `x`).

Return the number of covered buildings.

**Constraints**
- `2 ‚â§ n ‚â§ 10^5`
- `1 ‚â§ buildings.length ‚â§ 10^5`
- `1 ‚â§ x, y ‚â§ n`
- All coordinates are unique.

---

## üí° Intuition

We need to know, for each building at (x, y), whether there exists at least one building:

- to the left  ‚Üí same row x, some column < y
- to the right ‚Üí same row x, some column > y
- above       ‚Üí same column y, some row < x
- below       ‚Üí same column y, some row > x

A simple observation:

- For a given row x, if you know the **minimum** and **maximum** column indices (minY and maxY) that contain buildings, then any building with y strictly between minY and maxY has at least one building left and one right.
- Similarly, for a given column y, if you know the **minimum** and **maximum** row indices (minX and maxX), then any building with x strictly between minX and maxX has at least one building above and one below.

So a building (x,y) is covered **iff**

```text
minY_in_row[x] < y < maxY_in_row[x] AND minX_in_col[y] < x < maxX_in_col[y]
```


Practical notes and trade-offs:

- Your array-based solution recorded min/max per row and column ‚Äî that's exactly the right idea and runs in O(m) time where m = buildings.length.
- **Memory nitpick**: using two arrays of length n+1 works fine (n ‚â§ 1e5), but when the grid is sparse (m ‚â™ n) you can reduce memory to O(m) by using maps (store entries only for rows/cols that actually appear).
- No need for complex data structures (segment tree, BIT, etc.). This is a counting/min-max problem, not a range-query problem.

---

## üçÉ Approach 1 ‚Äî Keep min/max for each row and column (Array-backed)

Idea:
- For each row `x`, track the minimum and maximum `y` that contain a building: `rowMin[x]`, `rowMax[x]`.
- For each column `y`, track the minimum and maximum `x` that contain a building: `colMin[y]`, `colMax[y]`.
- A building (x,y) is covered iff:

```text
rowMin[x] < y < rowMax[x] AND colMin[y] < x < colMax[y]
```


This exactly captures "exists at least one building left/right/above/below".

### Code (TypeScript)

```ts
function countCoveredBuildings(n: number, buildings: number[][]): number {
  // Arrays sized n+1 since coordinates are 1-based
  const rowMin = new Array<number>(n + 1).fill(Infinity);
  const rowMax = new Array<number>(n + 1).fill(-Infinity);
  const colMin = new Array<number>(n + 1).fill(Infinity);
  const colMax = new Array<number>(n + 1).fill(-Infinity);

  // Fill min/max for rows and columns
  for (const [x, y] of buildings) {
      rowMin[x] = Math.min(rowMin[x], y);
      rowMax[x] = Math.max(rowMax[x], y);
      colMin[y] = Math.min(colMin[y], x);
      colMax[y] = Math.max(colMax[y], x);
  }

  // Count covered buildings
  let covered = 0;
  for (const [x, y] of buildings) {
      if (rowMin[x] < y && y < rowMax[x] && colMin[y] < x && x < colMax[y]) {
          covered++;
      }
  }

  return covered;
}
```

### Complexity

**Time:** `O(m)` where `m = buildings.length` (one pass to build min/max, one pass to count).
**Space:** `O(n)` due to four arrays of length `n+1`. (With `n ‚â§ 1e5` this is fine.)

### Notes / Edge-cases

- Works when a row/column has only one building: min==max and no building in that row/column will be counted as covered (correct).
- Uses 1-based coordinates directly, matching input.
- Arrays give excellent locality and are slightly faster than maps, but waste space when the grid is very sparse.

---

## üçÉ Approach 2 ‚Äî Use Maps to store min/max per row & column (Sparse)

### Idea (same logic, sparse storage)
If `m = buildings.length` is much smaller than `n`, don't allocate arrays of size `n+1`.
Instead keep only rows and columns that actually appear using `Map<number, [min,max]>`.

- `rowMap.get(x) = [minY, maxY]` for rows that have at least one building.
- `colMap.get(y) = [minX, maxX]` for columns that have at least one building.

A building `(x,y)` is covered iff:

```text
rowMin < y < rowMax AND colMin < x < colMax
```

(using values from the maps).

### Code (TypeScript)

```ts
function countCoveredBuildings(n: number, buildings: number[][]): number {
    const rowMap = new Map<number, [number, number]>();
    const colMap = new Map<number, [number, number]>();

    // Build min/max only for rows/cols that exist
    for (const [x, y] of buildings) {
        if (!rowMap.has(x)) rowMap.set(x, [y, y]);
        else {
            const [mn, mx] = rowMap.get(x)!;
            rowMap.set(x, [Math.min(mn, y), Math.max(mx, y)]);
        }

        if (!colMap.has(y)) colMap.set(y, [x, x]);
        else {
            const [mn, mx] = colMap.get(y)!;
            colMap.set(y, [Math.min(mn, x), Math.max(mx, x)]);
        }
    }

    // Count covered buildings
    let covered = 0;
    for (const [x, y] of buildings) {
        const row = rowMap.get(x)!;
        const col = colMap.get(y)!;
        if (row[0] < y && y < row[1] && col[0] < x && x < col[1]) covered++;
    }

    return covered;
}
```

### Complexity & Tradeoffs

= **Time:** `O(m)` ‚Äî one pass to fill maps, one pass to count.
- **Space:** `O(m)` ‚Äî maps store at most one entry per unique row/column seen.
- **Pros:** Memory-efficient when `m ‚â™ n`. Clear and easy to reason about.
- **Cons:** Slightly higher constant factors than flat arrays (Map lookups), but negligible for `m ‚â§ 1e5`.

### When to use which

- Use array-backed approach when n is moderate and you prefer maximum speed and memory locality.
- Use map-backed approach when grid is sparse and you want to reduce memory from `O(n)` ‚Üí `O(m)`.

---

## üìä Complexity & Final Takeaways

### Complexity

- Let `m = buildings.length`, `n` = grid size.

**Approach 1 ‚Äî Array-backed min/max**
- Time: O(m) ‚Äî one pass to build row/col min-max, one pass to check.
- Space: O(n) ‚Äî four arrays of length `n+1` (rowMin/rowMax/colMin/colMax).
- Notes: Fast, cache-friendly. Use when `n` is not huge or when you prefer direct indexing.

**Approach 2 ‚Äî Map-backed (sparse)**
- Time: O(m)
- Space: O(m) ‚Äî maps store only rows/cols that actually have buildings.
- Notes: Slightly higher constant factors (map lookups) but vastly better when `m ‚â™ n`.

### Correctness & Edge Cases
- Both approaches implement the same correctness condition:
  ```text
  rowMin[x] < y < rowMax[x] AND colMin[y] < x < colMax[y]
  ```
which exactly captures "exists at least one building strictly left/right/above/below".
- Handles rows/columns with 0 or 1 building (they won't count as covered).
- Input coordinates are 1-based; code respects that.

### When to pick which approach
- Pick **array-backed** if:
- `n` is moderate (‚â§ 1e5 here) and you want the fastest constant-time operations.
- Memory usage of O(n) is acceptable.
- Pick **map-backed** if:
- The building set is sparse (`m` much smaller than `n`), and you want to reduce memory to O(m).

### Small implementation tips
- Initialize array min values to `Infinity` and max to `-Infinity` (or use `null` checks).
- When using maps, destructure `[min, max]` safely ‚Äî assume the row/col exists because you built maps from buildings list.
- Keep code simple: no need for segment trees, sorting, or complex sweeps.

### Final takeaway
- Your original idea (min/max per row & col) is already optimal in time (O(m)).  
- The only meaningful "improvement" is a space trade-off: use maps for sparsity.  
- Both implementations are clean, easy to reason about, and fast enough for the given constraints.

---
