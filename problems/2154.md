# ğŸ§© Problem #2154 â€“ Keep Multiplying Found Values by Two

**Difficulty:** Easy  
**Topics:** `Hash Map`, `Simulation`  
**Link:** https://leetcode.com/problems/keep-multiplying-found-values-by-two/

---

## ğŸ“ Problem Summary

You are given:
- An integer array `nums`
- An integer `original`

Process:
1. If `original` exists in `nums`, multiply it by 2.
2. Repeat until the new value no longer appears in `nums`.

Return the **final value** of `original` after this process.

---

## ğŸ’¡ Intuition

Hint: You will repeatedly check whether a number exists in the array.  
Instead of scanning the array every time, put all values into a **hash set**.  
This makes each lookup `O(1)`, and you just double the value until it stops appearing.

---

## âš ï¸ Pointed Mistake / Code Review

Your solution is already optimal.  
Just one note: using a `Set` is perfect here â€” clean and fastest possible.

No logical issues. No unnecessary checks.  
This is as good as it gets for this problem.

---

## ğŸƒ Approach 1 â€” Your Solution (Optimal Hash Set)

### Idea
- Insert all numbers from `nums` into a `Set`
- While the current number exists in the set, keep doubling it
- Return the final value

### Complexity
- Time: `O(n)` to build the set + `O(log(final))` lookups  
- Space: `O(n)`

### Code (TypeScript)
```ts
function findFinalValue(nums: number[], original: number): number {
    const store: Set<number> = new Set(nums);
    let searchNum = original;

    while (store.has(searchNum)) {
        searchNum *= 2;
    }

    return searchNum;
}
```
---

## ğŸ€ Approach 2 â€” Sorting (Slower Alternative)

### Idea
- Sort `nums`
- Walk through the array and double `original` whenever you encounter it

### Complexity
- Time: `O(n log n)`
- Space: `O(1)` or `O(n)` depending on sort

### Code (TypeScript)
```ts
function findFinalValue(nums: number[], original: number): number {
    nums.sort((a, b) => a - b);
    let x = original;

    for (const num of nums) {
        if (num === x) x *= 2;
    }

    return x;
}
```
---

## ğŸ†š Comparison

| Feature | Hash Set (Your Approach) | Sorting Approach |
|--------|---------------------------|------------------|
| Time | O(n) | O(n log n) |
| Space | O(n) | O(1)â€“O(n) |
| Cleanliness | Very clean | OK |
| Recommended | âœ… Yes | âŒ Only for interviews w/o sets |

---
