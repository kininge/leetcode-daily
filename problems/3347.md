# 🧩 Problem #3347 – Maximum Frequency of an Element After Performing Operations II

**Difficulty:** Hard  
**Topics:** `Sorting`, `Two Pointers`, `Binary Search`, `Greedy`, `Hash Map`  
**Link:** [Leetcode](https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-ii/)

---

## 🧠 Intuition

We are allowed to perform `numOperations` operations, where each operation lets us **adjust one number** by adding any integer in the range `[-k, k]`.

That means every element `nums[i]` can take any value within the **interval** `[nums[i] - k, nums[i] + k]`.

So, the core idea is:

👉 Each number defines a *range of possible values*.  
👉 If multiple ranges overlap at some integer `x`, then all those numbers can be converted to `x`.  
👉 We can perform at most `numOperations` extra modifications to make even more numbers equal to `x`.

Hence, for any target value `x`:

```text
achievableFrequency(x) = equal(x) + min(numOperations, cover(x) - equal(x))
```

Where:
- `equal(x)` = count of elements already equal to `x`
- `cover(x)` = count of elements whose range `[nums[i]-k, nums[i]+k]` contains `x`

Our task: **find the maximum achievable frequency over all possible x.**

The challenge?  
- Values can be huge (`nums[i]` up to `1e9`), so we can’t iterate over all integers.  
- We must rely on **sorting, binary search, or event-based sweeps** to efficiently calculate coverage.

---

## 💡 Brute Force Approach

### 🔍 Idea  
Try all possible target values between the minimum and maximum numbers in the array, and for each possible value, count:
1. How many numbers are already equal to it?  
2. How many can be changed to it within the range `[-k, k]`?  

If we can still perform operations (≤ `numOperations`), we increase their frequency accordingly.

### 💻 Code
```Typescript []
function maxFrequency(nums: number[], k: number, numOperations: number): number {
    let n:number = nums.length;
    nums.sort((a,b)=> a-b);

    let maxFrequencyCount:number = 0;

    // Try every possible value between min and max
    for(let i=nums[0]; i<=nums[n-1]; i++){
        let count:number = 0;
        let operation:number = 0;

        for(let j=0; j<n; j++){
            if(i === nums[j]) {
                count++;
            }
            else if(i > nums[j]) {
                // Can we increase nums[j] to reach i?
                if((i <= (nums[j]+k)) && (operation < numOperations)) {
                    count++;
                    operation++;
                }
            } else {
                // Can we decrease nums[j] to reach i?
                if((i >= (nums[j]-k)) && (operation < numOperations)) {
                    count++;
                    operation++;
                }
            }
        }

        maxFrequencyCount = Math.max(maxFrequencyCount, count);
    }

    return maxFrequencyCount;
};
```

### ⏱️ Complexity

**Time:** `O(n * range)` — not efficient for large input.
**Space:** `O(1)`

### ⚙️ Notes

- ✅ Works correctly for small constraints.
- ❌ But slow when nums[i] values are large (up to 1e5), since we iterate over every possible integer.

---

## ⚡ Optimized Approach – Sorting + Two Pointers + HashMap

### 💡 Idea

Instead of iterating through every integer, we can:

1. Sort the array.
2. Use two pointers to find which elements can reach a specific target value using the allowed `k`.
3. Use a HashMap to store the original frequency of each number.

For each possible target `num`, find all numbers that can be converted into it (`nums[j]` satisfying `num ∈ [nums[j]-k, nums[j]+k]`).

The frequency for that target = `sameElements + min(otherElements, numOperations)`

### 💻 Code

```Typescript []
function maxFrequency(nums: number[], k: number, numOperations: number): number {
    let n:number = nums.length;

    nums.sort((a,b)=> a-b);

    // store frequency of each number
    const store:Map<number, number> = new Map();
    for(const num of nums){
        store.set(num, (store.get(num) ?? 0) + 1);
    }

    let maxFrequencyCount:number = 0;
    let leftIndex:number = 0;
    let rightIndex:number = 0;

    for(let num=nums[0]; num<=nums[n-1]; num++){
        // expand right pointer
        while((rightIndex < n) && ((nums[rightIndex]-k) <= num)) rightIndex++;

        // contract left pointer
        while((leftIndex <= rightIndex) && ((nums[leftIndex]+k) < num)) leftIndex++;

        // number of elements whose range includes 'num'
        let possibleElements:number = rightIndex - leftIndex;
        const sameElements:number = store.get(num) ?? 0;

        // we can change up to numOperations of the remaining ones
        possibleElements = Math.min(possibleElements - sameElements, numOperations) + sameElements;

        maxFrequencyCount = Math.max(maxFrequencyCount, possibleElements);
    }

    return maxFrequencyCount;
};
```

### ⏱️ Complexity

**Time:** `O(n log n)` — sorting dominates, and each element is visited at most twice by two pointers.
**Space:** `O(n)` — for the frequency map.

---

## 🧩 Approach 3 — Sorting + Two Pointers (Improved candidate set)

### Idea
Instead of scanning every integer target, generate a small candidate set of *meaningful* targets derived from the array: for each value `x` consider `x - k`, `x`, `x + k`.  
Those coordinates cover every change in coverage because intervals are `[x-k, x+k]`.  
Sort candidates (dedupe them), then use two pointers on the sorted `nums` to compute how many intervals cover each candidate. Combine that with the exact-frequency map to get the best achievable frequency at that candidate.

This visits `O(1)` candidates per element (3), so total candidates is `O(n)`. Good for large values (up to `1e9`).


### Steps
1. Sort `nums`.
2. Build a frequency map `store` for exact counts of each `num`.
3. Build candidate list with `num - k`, `num`, `num + k` for each `num`. Dedupe and sort candidates.
4. Use two pointers `left` and `right` on `nums`:
   - advance `right` while `nums[right] - k <= candidate` (these elements can reach `candidate` by +).
   - advance `left` while `nums[left] + k < candidate` (these elements cannot reach `candidate` even after +k).
   - `cover = right - left` (number of elements whose interval contains `candidate`).
5. `same = store.get(candidate) ?? 0`.
6. Achievable at candidate = `same + min(numOperations, max(0, cover - same))`.
7. Track max across candidates.


### Code
```Typescript []
function maxFrequency_twoPointersImproved(nums: number[], k: number, numOperations: number): number {
  const n = nums.length;
  if (n === 0) return 0;

  nums.sort((a, b) => a - b);

  // frequency of exact values
  const store = new Map<number, number>();
  for (const x of nums) store.set(x, (store.get(x) ?? 0) + 1);

  // build candidate set (num-k, num, num+k) and dedupe
  const candSet = new Set<number>();
  for (const x of nums) {
    candSet.add(x - k);
    candSet.add(x);
    candSet.add(x + k);
  }
  const candidates = Array.from(candSet).sort((a, b) => a - b);

  let left = 0;
  let right = 0;
  let ans = 0;

  for (const target of candidates) {
    // expand right while this nums[right] can reach 'target'
    while (right < n && (nums[right] - k) <= target) right++;
    // move left while nums[left] cannot reach 'target'
    while (left < right && (nums[left] + k) < target) left++;

    const cover = right - left;
    const same = store.get(target) ?? 0;
    const canConvert = Math.max(0, cover - same);
    const possible = same + Math.min(canConvert, numOperations);

    if (possible > ans) ans = possible;
  }

  return ans;
}
```

### ⏱️ Complexity

**Time:** `O(n log n)` — dominated by sorting nums and sorting candidates (candidates ≤ 3n).
**Space:** `O(n)` — for the frequency map and candidates.

---

## 🧩 Approach 4 — Sorting + Binary Search (check targets `num`, `num-k`, `num+k`)

### Idea
For each meaningful target derived from the array (`x`, `x - k`, `x + k`), use binary search on the sorted `nums` to compute:

- how many elements are **already equal** to the target (`equal`),
- how many elements **can reach** that target (`cover`) — i.e. elements with `nums[j] ∈ [target - k, target + k]`.

Then:

```text
achievable = equal + min(numOperations, max(0, cover - equal))
```

We check at most `3` targets per array element, each check using `O(log n)` binary searches, keeping the solution `O(n log n)` overall.

### Steps
1. Sort `nums`.
2. Build a `Set` or `Map` of existing values (for quick membership / freq lookup).
3. Implement `lowerBound(target)` → first index `i` such that `nums[i] >= target` (return `n` if none).
4. Implement `upperBound(target)` → last index `i` such that `nums[i] <= target` (return `-1` if none).
5. For each `x` in `nums`, evaluate `findWindowSize(x)`, `findWindowSize(x - k)`, `findWindowSize(x + k)`:
   - `equal = (upperBound(x) - lowerBound(x) + 1)` if present, else `0`.
   - `lowIdx = lowerBound(target - k)`, `highIdx = upperBound(target + k)`.
   - `cover = (highIdx >= lowIdx) ? (highIdx - lowIdx + 1) : 0`.
   - `possible = equal + min(numOperations, max(0, cover - equal))`.
6. Track the maximum `possible`.

### Code (TypeScript — copy-paste ready)
```Typescript []
function maxFrequency_binarySearch(nums: number[], k: number, numOperations: number): number {
  const n = nums.length;
  if (n === 0) return 0;

  nums.sort((a, b) => a - b);
  const elements = new Set<number>(nums);

  // first index i such that nums[i] >= target; if none, return n
  function lowerBound(target: number): number {
    let l = 0, r = n - 1, ans = n;
    while (l <= r) {
      const mid = (l + r) >> 1;
      if (nums[mid] >= target) {
        ans = mid;
        r = mid - 1;
      } else {
        l = mid + 1;
      }
    }
    return ans;
  }

  // last index i such that nums[i] <= target; if none, return -1
  function upperBound(target: number): number {
    let l = 0, r = n - 1, ans = -1;
    while (l <= r) {
      const mid = (l + r) >> 1;
      if (nums[mid] <= target) {
        ans = mid;
        l = mid + 1;
      } else {
        r = mid - 1;
      }
    }
    return ans;
  }

  function findWindowSize(target: number): number {
    // equal count
    let equal = 0;
    if (elements.has(target)) {
      const lo = lowerBound(target);
      const hi = upperBound(target);
      if (hi >= lo) equal = hi - lo + 1;
    }

    // cover range [target-k, target+k]
    const loPossible = lowerBound(target - k);
    const hiPossible = upperBound(target + k);
    const cover = (hiPossible >= loPossible) ? (hiPossible - loPossible + 1) : 0;

    const extraNeeded = Math.max(0, cover - equal);
    return equal + Math.min(extraNeeded, numOperations);
  }

  let ans = 0;
  for (const x of nums) {
    ans = Math.max(ans, findWindowSize(x));
    ans = Math.max(ans, findWindowSize(x - k));
    ans = Math.max(ans, findWindowSize(x + k));
  }

  return ans;
}
```

### Complexity

**Time:** `O(n log n)` — sorting plus `O(3n)` binary-search checks (`O(log n)` each).
**Space: O(n)** — for the Set and sorts.

---

## 🧩 Approach 5 — Sweep-Line / Coordinate Compression (Pro-Level Optimisation)

### 💡 Core Idea

Think of every number `nums[i]` as an **interval** `[nums[i] - k, nums[i] + k]`.  
Now, you just want to know **how many of these intervals overlap at any point `x`** — that gives you `cover(x)`.

Then combine it with:

```text
achievable(x) = equal(x) + min(numOperations, cover(x) - equal(x))
```


Instead of checking every integer, we only check:
- the **start (`L`)** of each interval,
- the **end (`R + 1`)** of each interval (to make interval inclusive),
- and the **original numbers** (`nums[i]`) themselves.

That’s at most **3n unique coordinates** — not billions.

So we compress these coordinates into a smaller integer range (0 to m−1) and sweep through them efficiently.

---

### ⚙️ Step-by-Step

1. For each number `x`, mark:
   - Start event `+1` at `(x - k)`
   - End event `−1` at `(x + k + 1)`  
     (We use `+1` and `−1` to build prefix sums of coverage)
2. Also record the frequency of each original number (`equal(x)`).
3. Gather all event keys and numbers into a sorted list of **unique coordinates**.
4. Map each coordinate to its **compressed index** (0…m−1).
5. Build an array `diff[]` initialized with 0.
6. For each event:
   - `diff[L_idx] += 1`
   - `diff[R+1_idx] -= 1`
7. Build a prefix sum array `cover[]` to represent the current overlap count at each coordinate.
8. For each coordinate:
   - if it corresponds to a number:  
     `ans = max(ans, min(cover[i], equal[i] + numOps))`
   - for coordinates between two numbers (no exact `equal`):  
     `ans = max(ans, min(cover[i], numOps))`

✅ This efficiently finds the global maximum possible frequency.

---

### 💻 Code

```Typescript []
function maxFrequency(nums: number[], k: number, numOps: number): number {
  const n = nums.length;
  if (n === 0) return 0;

  // 1️⃣ Frequency of exact numbers
  const freq = new Map<number, number>();
  for (const x of nums) freq.set(x, (freq.get(x) ?? 0) + 1);

  // 2️⃣ Collect all important coordinates
  const coords = new Set<number>();
  for (const x of nums) {
    coords.add(x - k);
    coords.add(x);
    coords.add(x + k + 1); // inclusive interval ends
  }
  const sorted = Array.from(coords).sort((a, b) => a - b);
  const idxMap = new Map<number, number>();
  sorted.forEach((val, i) => idxMap.set(val, i));

  // 3️⃣ Build diff array for sweep
  const diff = new Array(sorted.length).fill(0);
  for (const x of nums) {
    const L = idxMap.get(x - k)!;
    const R = idxMap.get(x + k + 1)!;
    diff[L] += 1;
    diff[R] -= 1;
  }

  // 4️⃣ Prefix sum to get coverage
  const cover = new Array(sorted.length).fill(0);
  let active = 0;
  for (let i = 0; i < sorted.length; i++) {
    active += diff[i];
    cover[i] = active;
  }

  // 5️⃣ Map equal counts
  const equal = new Array(sorted.length).fill(0);
  for (const [num, count] of freq.entries()) {
    const idx = idxMap.get(num)!;
    equal[idx] = count;
  }

  // 6️⃣ Evaluate answer
  let ans = 0;
  for (let i = 0; i < sorted.length; i++) {
    const withEqual = Math.min(cover[i], equal[i] + numOps);
    const withoutEqual = Math.min(cover[i], numOps);
    ans = Math.max(ans, withEqual, withoutEqual);
  }

  return ans;
}
```

### Complexity

**Time:** `O(n log n)`
**Space: O(n)**

---

## ⚖️ Approach Comparison

| # | Approach | Handles 1e9 range? | Time | Space | Strength | Weakness |
|---|-----------|-------------------|-------|--------|-----------|-----------|
| 1 | Brute Force | ❌ | `O(n × range)` | `O(1)` | Conceptual clarity | Hopeless for large values |
| 2 | Sorting + Two Pointers + HashMap | ❌ | `O(n log n)` | `O(n)` | Simple logic, easy debug | Needs dedup / careful bounds |
| 3 | Sorting + Two Pointers (Improved Candidates) | ✅ | `O(n log n)` | `O(n)` | Fast and clean; best balance | Slightly more code |
| 4 | Sorting + Binary Search | ✅ | `O(n log n)` | `O(n)` | Deterministic bounds, scalable | Many binary calls |
| 5 | Sweep-Line / Coord Compression (alt) | ✅ | `O(n log n)` | `O(n)` | Fastest in practice | More setup work |

---

## 💡 Takeaway

- Each element forms a range `[x − k, x + k]`.  
- All we’re doing is finding the point where the most intervals overlap, then using up to `numOperations` to boost that frequency.  
- The hard part was **skipping the huge integer space** — sorting and window/binary logic fix that.  

💪 If you want clarity, start with brute force.  
⚙️ If you want performance: use Approach 3 or 4.  
🚀 If you want ultimate speed: move to a sweep-line / coordinate-compression version.

---

### 🧩 Final Words

> “Every interval wants to be heard — you just need to listen at the point where they all scream the same value.” 😎

