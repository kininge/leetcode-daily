# ðŸ§© Problem #2169 â€“ Count Operations to Obtain Zero

**Difficulty:** Easy  
**Topics:** `Math`, `Simulation`, `Greedy`  
**Link:** [Leetcode](https://leetcode.com/problems/count-operations-to-obtain-zero)

---

## âš™ï¸ Problem Intuition

You're given two numbers and repeatedly subtract the smaller one from the larger one until one of them becomes zero.

Essentially, each step behaves like the **Euclidean GCD algorithm**, except instead of finding the GCD, we **count the total number of subtractions** made.

For example:  
num1 = 5, num2 = 4  
â†’ (1,4) â†’ (1,3) â†’ (1,2) â†’ (1,1) â†’ (0,1)  
Total = 5 operations.

---

## ðŸ§  Approach 1: Recursive Simulation

A direct way to simulate the subtraction process is to recursively subtract the smaller from the larger until one becomes 0.

```ts
function countOperations(num1: number, num2: number): number {
  if (num1 === 0 || num2 === 0) return 0;

  let newNum1 = num1;
  let newNum2 = num2;

  if (num1 >= num2) newNum1 = num1 - num2;
  else newNum2 = num2 - num1;

  return 1 + countOperations(newNum1, newNum2);
}
```

### ðŸ” Notes:

Simple and intuitive.

- Each recursion represents one operation.
- Risk: Deep recursion â†’ stack overflow for large numbers (e.g., `num1 = 100000`, `num2 = 1`).
- **Time Complexity:** `O(ops)`, where `ops = number of subtractions`.
- **Space Complexity:** `O(ops)` (recursion stack).

---

## ðŸ” Approach 2: Iterative Simulation

Instead of recursion, simulate the same process with a loop.

```ts
function countOperationsIter(num1: number, num2: number): number {
  let a = num1, b = num2;
  let ops = 0;

  while (a > 0 && b > 0) {
    if (a >= b) a -= b;
    else b -= a;
    ops++;
  }
  return ops;
}
```

### âš¡ Why this works:

- Each iteration performs one subtraction.
- Stops when one of the numbers becomes 0.
- Avoids recursion depth issues.

### â± Complexity:

- **Time:** `O(ops)`
- **Space:** `O(1)`

---

## ðŸš€ Approach 3: Optimized Using Division (Euclidean Trick)

Instead of subtracting one-by-one, use integer division to count multiple subtractions at once.

```ts
function countOperationsFast(num1: number, num2: number): number {
  let a = num1, b = num2;
  let ops = 0;

  while (a > 0 && b > 0) {
    if (a >= b) {
      ops += Math.floor(a / b);
      a %= b;
    } else {
      ops += Math.floor(b / a);
      b %= a;
    }
  }
  return ops;
}
```

### ðŸ’¡ Explanation:

- If `a >= b`, you would normally do `a -= b` repeatedly until `a < b`.
- Instead, do all those subtractions at once:
  - Count how many times `b` fits in `a`: `Math.floor(a / b)`.
  - Add that to the total operations.
  - Update `a = a % b` (same remainder as repeated subtractions).

This mirrors the Euclidean GCD algorithm, but instead of returning GCD, we sum all the quotients.

### â± Complexity:

- **Time:** `O(log(min(a, b)))` (same as GCD)
- **Space:** `O(1)`

---

## ðŸ§® Example Run

Input: num1 = 5, num2 = 4  
- (5,4) â†’ (1,4) â†’ (1,3) â†’ (1,2) â†’ (1,1) â†’ (0,1)
- Total operations = 5

Input: num1 = 2, num2 = 3  
- (2,3) â†’ (2,1) â†’ (1,1) â†’ (0,1)
- Total = 3

Input: num1 = 10, num2 = 10  
- (10,10) â†’ (0,10)
- Total = 1

---

## ðŸ§© Complexity Summary

| Approach | Time Complexity | Space Complexity | Notes |
|-----------|-----------------|------------------|--------|
| Recursive | O(ops) | O(ops) | Simple but can overflow stack |
| Iterative | O(ops) | O(1) | Safe and straightforward |
| Division (Optimized) | O(log(min(a, b))) | O(1) | Fastest and cleanest |

---

## ðŸ Final Notes

- All approaches yield the same result; only performance differs.
- The division-based optimization (Approach 3) is mathematically identical to the subtraction rule â€” itâ€™s just **batching identical steps**.
- This pattern of optimization often appears in problems where â€œsubtract smaller from largerâ€ repeats â€” e.g., Euclidean algorithms, resource reduction simulations, or balance problems.

---
