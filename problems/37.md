# 🧩 Problem #37 – Sudoku Solver  

**Difficulty:** Hard  
**Topics:** `Backtracking`, `Matrix`, `Bitmask`  
**Link:** [Leetcode](https://leetcode.com/problems/sudoku-solver/description/)  

---

## 🔍 Problem Statement  

Write a program to solve a Sudoku puzzle by filling the empty cells.  

A sudoku solution must satisfy all of the following rules:  
1. Each digit **1–9** must occur exactly once in each row.  
2. Each digit **1–9** must occur exactly once in each column.  
3. Each of the nine **3 × 3 sub-boxes** must contain digits **1–9** without repetition.  

The `'.'` character indicates empty cells.  

> Guaranteed: there is only **one solution** for the given board.  

---

## 🧠 Observations  

- This is a **classic backtracking problem**.  
- Very similar to **#36 Valid Sudoku**, but here we must **fill in missing cells**.  
- At each empty cell → try all 1–9 → check validity → recurse → backtrack if wrong.  
- Constraint check is the heart of pruning.  

---

## 🔑 Approaches  

### ✅ Approach 1: Backtracking with Sets (Readable)  

- Maintain 3 arrays of Sets → `rows[9]`, `cols[9]`, `boxes[9]`.  
- For each empty cell `(i, j)`:
  - Try `1–9`.
  - If number not present in row/col/box → place it → recurse.  
  - If dead-end → undo (backtrack).  
- Stop once we reach `i == 9` → solved all rows.  

**Time Complexity:** Exponential worst-case, but heavily pruned → runs fast.  
**Space Complexity:** `O(81)` for Sets.  

#### Code (JavaScript)

```javascript
var solveSudoku = function(board) {
    const rows = Array.from({ length: 9 }, () => new Set());
    const cols = Array.from({ length: 9 }, () => new Set());
    const boxes = Array.from({ length: 9 }, () => new Set());

    // Fill sets with existing numbers
    for (let i = 0; i < 9; i++) {
        for (let j = 0; j < 9; j++) {
            const val = board[i][j];
            if (val !== ".") {
                const boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3);
                rows[i].add(val);
                cols[j].add(val);
                boxes[boxIndex].add(val);
            }
        }
    }

    function backtrack(i, j) {
        if (i === 9) return true; // solved board
        const [nextI, nextJ] = (j < 8) ? [i, j + 1] : [i + 1, 0];

        if (board[i][j] !== ".") return backtrack(nextI, nextJ);

        const boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3);

        for (let num = 1; num <= 9; num++) {
            const char = String(num);
            if (!rows[i].has(char) && !cols[j].has(char) && !boxes[boxIndex].has(char)) {
                board[i][j] = char;
                rows[i].add(char);
                cols[j].add(char);
                boxes[boxIndex].add(char);

                if (backtrack(nextI, nextJ)) return true;

                // backtrack
                board[i][j] = ".";
                rows[i].delete(char);
                cols[j].delete(char);
                boxes[boxIndex].delete(char);
            }
        }
        return false;
    }

    backtrack(0, 0);
    return board;
};
```
---

### ⚡️ Approach 2: Backtracking with Bitmasks (Optimized)  

- Instead of Sets, use **bitmasks**:  
  - Each row/col/box is a 9-bit integer (1 = digit present).  
- To check if number `k` is available:  
  ```js
  if (!(rows[i] & (1 << k))) ...
  ```
- To place/remove → use bit operations.
- Much faster (constant-time checks).


**Time Complexity**: Same theoretical exponential, but bit operations are faster.
**Space Complexity**: `O(27)` integers (3 arrays of 9 masks).

#### Code 

```javascript [] 
var solveSudoku = function(board) {
    const rows = new Array(9).fill(0);
    const cols = new Array(9).fill(0);
    const boxes = new Array(9).fill(0);

    // Fill bitmasks
    for (let i = 0; i < 9; i++) {
        for (let j = 0; j < 9; j++) {
            const val = board[i][j];
            if (val !== ".") {
                const num = parseInt(val) - 1;
                const mask = 1 << num;
                const boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3);
                rows[i] |= mask;
                cols[j] |= mask;
                boxes[boxIndex] |= mask;
            }
        }
    }

    function backtrack(i, j) {
        if (i === 9) return true;
        const [nextI, nextJ] = (j < 8) ? [i, j + 1] : [i + 1, 0];

        if (board[i][j] !== ".") return backtrack(nextI, nextJ);

        const boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3);

        for (let num = 0; num < 9; num++) {
            const mask = 1 << num;
            if (!(rows[i] & mask) && !(cols[j] & mask) && !(boxes[boxIndex] & mask)) {
                board[i][j] = String(num + 1);
                rows[i] |= mask;
                cols[j] |= mask;
                boxes[boxIndex] |= mask;

                if (backtrack(nextI, nextJ)) return true;

                // backtrack
                board[i][j] = ".";
                rows[i] ^= mask;
                cols[j] ^= mask;
                boxes[boxIndex] ^= mask;
            }
        }
        return false;
    }

    backtrack(0, 0);
    return board;
};
```
---

### 🏆 Takeaway

- Sudoku solver = constraint checking + backtracking.
- Sets = clean & beginner-friendly.
- Bitmasks = lean & much faster (competitive programming style).
- Both solve the guaranteed-unique solution efficiently.
