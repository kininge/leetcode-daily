# ðŸ§© Problem #3217 â€“ Delete Nodes From Linked List Present in Array

**Difficulty:** Medium  
**Topics:** `Linked List`, `Hash Map`  
**Link:** [Leetcode](https://leetcode.com/problems/delete-nodes-from-linked-list-present-in-array/description)

---

## ðŸ§  Problem Statement

You are given an array of integers `nums` and the `head` of a linked list. Return the head of the modified linked list after removing all nodes from the linked list that have a value that exists in `nums`.

**Constraints:**
- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^5`
- All elements in `nums` are unique.
- Number of nodes in the list is in `[1, 10^5]`.
- `1 <= Node.val <= 10^5`
- There is at least one node in the list whose value is not present in `nums`.

---

## âš ï¸ Quick Notes on Your Submitted Solutions

1. **Old solution (object map)** â€” works logically, but using an object with undefined checks is clumsier than `Set`. Also, remember to return `head` for all paths (you did).

2. **Today's solution (Set)** â€” logic is okay but:
   - **Type bug:** You declared `currentNode: ListNode = head;` while `head` can be `null`. Use `ListNode | null`.
   - Slightly brittle: prefer a **dummy head** to simplify head-removal cases and avoid extra `newHead` logic.
   - Edge-safety: always handle `head === null` early (though constraints guarantee â‰¥1 node).

---

## âš¡ Approach A (Recommended): In-place removal using a Dummy Head + Set

### Idea
Use a `Set` for O(1) membership. Use a dummy head so removing head nodes is simple and you can mutate pointers in one pass.

### Complexity
- Time: O(L + m) where L = number of list nodes, m = nums.length  
- Space: O(m) for the set

### Code (TypeScript)
```ts
function modifiedList(nums: number[], head: ListNode | null): ListNode | null {
    let newHead: ListNode|null = null;
    let previousNode: ListNode|null = null;
    let currentNode: ListNode = head;

    // O(n)
    const store:Set<number> = new Set(nums);

    // O(n)
    while(currentNode){
        if(store.has(currentNode.val)){
            // no previous node = no head
            if(previousNode === null){
                // do nothing
            }else{
                // deleted node
                previousNode.next = currentNode.next;
            }
        } else {
            // no previous node = no head
            if(previousNode === null){
                newHead = currentNode;
            }

            previousNode = currentNode;
        }

        // increment
        currentNode = currentNode.next; 
    }
    return newHead;
};
```

---

## ðŸ§© Approach B: Rebuild a new list (functional, avoids mutating original)

### Idea
Create a fresh linked list by appending only allowed nodes. Simpler semantics; avoids pointer juggling in source list.

### Complexity
- Time: O(L + m)
- Space: O(m) extra for Set + O(k) for newly created nodes (k = kept nodes)

### Code (TypeScript)
```ts
function modifiedList_Rebuild(nums: number[], head: ListNode | null): ListNode | null {
    const toRemove = new Set<number>(nums);
    const dummy = new ListNode(0, null);
    let tail: ListNode = dummy;
    let cur: ListNode | null = head;

    while (cur !== null) {
        if (!toRemove.has(cur.val)) {
            // create new node to avoid mutating the old list
            tail.next = new ListNode(cur.val);
            tail = tail.next;
        }
        cur = cur.next;
    }
    return dummy.next;
}
```

---

## ðŸ§© Approach C: Use a boolean presence array (fastest lookups if value range small / dense)

### Idea
Because `nums[i]` and `Node.val` â‰¤ 1e5, you can allocate a boolean array `present[0..MAX]` and mark deletions in O(m). This uses contiguous memory and slightly faster than Set lookups in practice.

### Complexity
- Time: O(L + m + V?) where V is max value size you allocate (here ~1e5)
- Space: O(V) (here `~10^5` booleans)

### Code (TypeScript)
```ts
function modifiedList_Bitmap(nums: number[], head: ListNode | null): ListNode | null {
    if (head === null) return null;

    const MAXV = 100000; // per constraints
    const present = new Uint8Array(MAXV + 1); // efficient boolean array
    for (const v of nums) present[v] = 1;

    const dummy = new ListNode(0, head);
    let prev: ListNode = dummy;
    let cur: ListNode | null = head;

    while (cur !== null) {
        if (present[cur.val]) {
            prev.next = cur.next;
        } else {
            prev = cur;
        }
        cur = cur.next;
    }

    return dummy.next;
}
```

---

## ðŸŽ¯ Complexity Comparison

| Approach           | Time        | Space            | Notes |
|--------------------|-------------|------------------|-------|
| Dummy + Set        | O(L + m)    | O(m)             | Recommended; in-place |
| Rebuild new list   | O(L + m)    | O(m + k)         | Safer if you must not mutate original |
| Boolean bitmap     | O(L + m)    | O(V) (~1e5)      | Very fast lookups, uses fixed extra memory |


---


