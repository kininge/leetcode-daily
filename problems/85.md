
# 🧩 Problem #85 – Maximal Rectangle

**Difficulty:** Hard  
**Topics:**  `Matrix`, `Dynamic Programming`, `Stack`  
**Link:** [Leetcode](https://leetcode.com/problems/maximal-rectangle)

---

## 🎯 Problem Summary

Given a binary matrix filled with `'0'` and `'1'`, find the **largest rectangle** containing only `1`s and return its area.

**Constraints**

- `1 <= rows, cols <= 200`
- Each `matrix[i][j]` is `'0'` or `'1'`.

---

## 🧩 Example  

**Input:**  

```text
matrix = [
  ["1","0","1","0","0"],
  ["1","0","1","1","1"],
  ["1","1","1","1","1"],
  ["1","0","0","1","0"]
]
```

**Output:**

```text
6
```

**Explanation:**
The maximal rectangle of ones has area 6 — spanning 3 rows and 2 columns in the center.

---

## 🧠 Approach — Brute Force with Bounded Width (Your Solution)

### 💡 Idea

- Treat each `'1'` cell as a potential top-left corner of a rectangle.
- From that cell, expand downward row by row, and for each new row:
  - Count how many continuous '1's exist to the right (width).
  - Track the minimum width so far across all rows considered (since any shorter row limits the rectangle width).
  - Update the maximal area as minWidth × height.
  - Essentially, we are bounding width as we expand height downward.

### ✅ Your Implementation

```Typescript []
var maximalRectangle = function(matrix) {
    const N = matrix.length;
    const M = matrix[0].length;

    let ans = 0;

    const checkSqure = (i, j) => {
        let maxWidth = Infinity;
        let maxHeight = i;

        while (maxHeight < N && matrix[maxHeight][j] === '1') {
            let width = 0;
            for (let c = j; c < M; c++) {
                if (matrix[maxHeight][c] === '1') {
                    width++;
                    if (width === maxWidth) break;
                } else break;
            }
            maxWidth = Math.min(width, maxWidth);
            maxHeight++;
            ans = Math.max(ans, maxWidth * (maxHeight - i));
            if (maxHeight === N) break;
        }
    };

    for (let i = 0; i < N; i++) {
        for (let j = 0; j < M; j++) {
            if (matrix[i][j] === '1') checkSqure(i, j);
        }
    }

    return ans;
};
```

## ⚙️ Complexity Analysis

| Type | Complexity |
| Time | O(m² × n) in the worst case (each cell may explore downward and right) |
| Space | O(1) — in-place calculation |

## 🧩 Why It Works

- Every cell `(i, j) `acts as a potential top-left corner.
- The inner loop finds the widest possible extension to the right for each downward expansion.
- Tracking minimum width ensures all rectangles considered contain only 1s.
- The algorithm checks all possible rectangles that can exist in the grid.

## ⚡ Optimization Idea

- This approach can be improved using the “Largest Rectangle in Histogram” trick:
  1. Build histogram heights row by row (count consecutive 1s vertically).
  2. For each row, apply the stack-based rectangle-in-histogram algorithm in O(n).
  3. Overall O(m × n) — much faster and scalable.

## 🏁 Final Thoughts

- Your solution is clear and correct, perfect for conceptual understanding.
- For large matrices, switching to the histogram-based DP will significantly boost performance.
- Still, this brute-force expansion method demonstrates a solid geometric intuition — and works fine for small constraints.

> 💬 "Every rectangle starts with a single '1' — it’s all about how far you can stretch it!" 😎
