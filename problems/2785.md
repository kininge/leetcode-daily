# 🧩 2785. Sort Vowels in a String

**Difficulty:** Medium  
**Tags:** String, Sorting, Counting / Bucket, Two-pass  
**Link:** [LeetCode](https://leetcode.com/problems/sort-vowels-in-a-string/)

---

## 💡 Hint (tiny nudge)
Collect all vowels, sort them by **ASCII** (remember: uppercase letters have smaller ASCII values than lowercase), then put them back into the vowel positions. Watch your comparator — it must return negative/zero/positive, and `charCodeAt()` is your friend.

---

## 🧠 Intuition
Consonants must stay exactly where they are. Only the vowels move — and they must appear in nondecreasing ASCII order in the final string. So we can:

1. Scan and collect vowels in an array.
2. Sort that array by ASCII.
3. Re-scan the original string and replace vowels with sorted vowels in order.

Because the alphabet of vowels is small (5 lowercase + 5 uppercase), we can also use a counting/bucket approach to avoid an explicit sort.

---

## ✅ Simple (clean) solution — O(n log k) where k = #vowels
```javascript
// solution.js
function sortVowels(s) {
  const isVowel = ch => 'aeiouAEIOU'.includes(ch);
  const vowels = [];

  // collect vowels
  for (const ch of s) {
    if (isVowel(ch)) vowels.push(ch);
  }

  // sort by ASCII ascending (correct comparator)
  vowels.sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0));

  // rebuild string, replacing vowels from sorted list
  const out = [];
  let idx = 0;
  for (const ch of s) {
    if (isVowel(ch)) out.push(vowels[idx++]);
    else out.push(ch);
  }
  return out.join('');
}
```
---

## ⚡ Better (O(n)) — counting / bucket approach

- Because there are only up to 10 vowel characters (A,E,I,O,U,a,e,i,o,u), we can count them and then emit in ASCII order without an actual sort. This gives linear time and constant extra space (bounded by vowel types).

```javascript
function sortVowelsLinear(s) {
  const vowelChars = 'AEIOUaeiou';
  // count occurrences of each vowel char present
  const counts = Object.create(null);
  for (const ch of s) {
    if (vowelChars.includes(ch)) counts[ch] = (counts[ch] || 0) + 1;
  }

  // build sorted vowels list by ASCII order (uppercase before lowercase)
  const sortedVowels = [];
  for (let code = 65; code <= 122; code++) {
    const ch = String.fromCharCode(code);
    const c = counts[ch] || 0;
    for (let k = 0; k < c; k++) sortedVowels.push(ch);
  }

  // reinsert
  const out = [];
  let idx = 0;
  for (const ch of s) {
    if (vowelChars.includes(ch)) out.push(sortedVowels[idx++]);
    else out.push(ch);
  }
  return out.join('');
}
```
---

## 📊 Complexity

- Simple sort approach:

- - Time: `O(n + k log k)` where k is number of vowels (worst-case k = n) ⇒ worst `O(n log n)`.
- - Space: `O(n)` for output and vowel storage.

- Counting/bucket approach:

- Time: `O(n)` (plus small fixed ASCII scan).
- Space: `O(1)` extra (counts limited to 10 vowel keys) + `O(n)` for output.

---

## 🔍 Notes & Gotchas

- ASCII ordering matters: all uppercase vowels come before lowercase when sorted by charCodeAt. The problem requires sorting by ASCII, so that's intended.
- Don’t use a broken comparator like vowels.sort((a,b)=> (b <= a)? 1 : -1); — that’s wrong and unstable. Return a.charCodeAt(0) - b.charCodeAt(0).
- Avoid ans += char in long loops if you care about micro-performance in JS — building an array and join('') is better.
- Edge cases: string with no vowels (return original), all vowels (just sorted string), single-character strings.
