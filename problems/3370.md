# 🧩 Problem #3370 – Smallest Number With All Set Bits

**Difficulty:** Easy  
**Topics:** `Bit Manipulation`, `Math`, `Greedy`  
**Link:** [Leetcode](https://leetcode.com/problems/smallest-number-with-all-set-bits)

---

## 🧠 Intuition

We want the smallest integer `x >= n` whose binary representation is **all 1s** (i.e. `x` looks like `1`, `11`, `111`, `1111`, ... in binary).  
Numbers of that form are `2^k - 1` for some positive integer `k`. So the task reduces to:

> find the smallest `k` such that `2^k - 1 >= n`, and return `2^k - 1`.

Because `n ≤ 1000` (small), we can do this by simple bit-building loops; for larger `n`, we still only need `O(log n)` steps.

---

## 🧩 Approaches

### Approach A — Find highest set bit, return `(1 << (k+1)) - 1`
Find the index `k` of the most significant set bit of `n` (0-based). The smallest all-ones number ≥ `n` has `k+1` ones, i.e. `2^(k+1) - 1`.

```TypeScript[]
// Approach A — highest set bit then fill below
function smallestNumber(n: number): number {
  let largestSetBitIndex = 0;
  // dynamic bound — safe for any n up to 2^30-ish in JS
  for (let i = 0; i < 31; i++) {
    if ((n & (1 << i)) !== 0) largestSetBitIndex = i;
  }
  // set bits 0..largestSetBitIndex inclusive
  let ans = 0;
  for (let i = 0; i <= largestSetBitIndex; i++) ans |= (1 << i);
  // If n is exactly all ones up to largestSetBitIndex, ans == n.
  // Otherwise ans = 2^(largestSetBitIndex+1)-1 which is >= n.
  return ans;
}
```


### Approach B — Build all-ones progressively until >= n (simple loop)

Start with `x = 1` (binary `1`) and repeat `x = (x << 1) | 1` (which produces `1, 3, 7, 15, ...`) until `x >= n`.

```Typescript[]
// Approach B — progressive all-ones builder
function smallestNumber(n: number): number {
  let x = 1;
  while (x < n) {
    x = (x << 1) | 1; // append a 1 bit on the left: 1 -> 3 -> 7 -> 15 ...
  }
  return x;
}
```

**Why it's nice:** Simple, readable, no math mistakes, each iteration adds one `1` bit. Runs in `O(k)` where `k = number of bits` (~`log2 n`).


### Approach C — Compute k by `Math.floor(Math.log2(n))` then return `(1 << (k+1)) - 1`

Find the highest bit index `k = floor(log2(n))`, then return `2^(k+1)-1`. For safety with floating point, this is fine for `n ≤ 1000`.

```Typescript[]
// Approach C — log2 then math formula
function smallestNumber(n: number): number {
  const k = Math.floor(Math.log2(n));      // largest set bit index
  return (1 << (k + 1)) - 1;               // 2^(k+1)-1
}
```

**Caveat:** `Math.log2` uses floating point — safe here, but be wary for huge `n` due to rounding.


### Approach D — Bit-twiddling one-liner idea (shift until >= n)

Same as B but written succinctly.

```Typescript[]
function smallestNumber_D(n: number): number {
  let ans = 1;
  while (ans < n) ans = (ans << 1) | 1;
  return ans;
}
```

---

## ✅ Correctness & Edge Cases

- If `n` is already all ones (e.g., `n = 3 (11₂)`, `7 (111₂)`), the algorithm returns `n` itself.
- If `n` is a power of two (e.g., `n = 8`), the result is the next `2^k - 1`, e.g. `15`.
- Works for `n = 1` → returns `1`.
- For given constraints `1 ≤ n ≤ 1000`, all above approaches are safe and fast.

---

## ⏱ Complexity

- All approaches run in `O(k)` time where k = number of bits needed ≈ floor(log2 n) + 1. For the constraints this is effectively constant.
  - **Time:** `O(log n)` (practically tiny)
  - **Space:** `O(1)`

---

## 🔬 Examples

```text
n = 1  => 1   (1)
n = 2  => 3   (11)
n = 3  => 3   (11)
n = 4  => 7   (111)
n = 6  => 7   (111)
n = 8  => 15  (1111)
n = 15 => 15  (1111)
n = 16 => 31  (11111)
n = 1000 => 1023 (1111111111₂)
```

## 🧾 Final takeaway

1. The numbers with all set bits are exactly `2^k - 1`.
2. The task is to find the smallest k with `2^k - 1 >= n`.
3. The progressive builder while `(x < n) x = (x << 1) | 1` is the simplest, robust, and readable solution — ideal for contests and production.
