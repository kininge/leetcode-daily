# ðŸ§© Problem #3408 - Design Task Manager

**Difficulty:** Medium  
**Tags:** Design, Heap, Hash Map  
**Link:** [Leetcode](https://leetcode.com/problems/design-task-manager/)  

---

## ðŸ§  Intuition  
We need a data structure that supports:
- Add a task,
- Edit a task's priority,
- Remove a specific task,
- Execute (pop) the highest-priority task (tie-break by larger taskId).

A binary heap gives `O(log n)` push/pop. To support removal/edit of arbitrary taskId in `O(log n)`, keep a `Map<taskId, index>` to locate nodes inside the heap quickly. After swapping/removing a node, update the map indices.

---

## ðŸ’¡ Approach â€” Heap + Index Map

1. Maintain a max-heap of task objects sorted by `(priority, taskId)`.
   - Higher `priority` is more important.
   - If `priority` ties, higher `taskId` is preferred.
2. Maintain a map from `taskId` â†’ current index in the heap array.
3. `append` (add) â€” push to heap, update map, upward-heapify.
4. `pop` (execTop) â€” swap root with last, pop, update map, downward-heapify.
5. `removeTask(taskId)` â€” find index from map, swap with last, pop, update map, then both downward and upward heapify at that index.
6. `edit` â€” remove the old node, change priority, append as new node (or directly update and re-heapify; both OK).
7. Guard against edge cases: adding duplicate `taskId`, editing/removing non-existent `taskId`.

---

## âœ… Cleaned JavaScript Implementation (fixed issues)

**What I fixed / improved over your code**
- Bound comparator correctly so it is safe when passed to `CHeap`.
- Simplified comparator logic and removed unnecessary default booleans.
- `add` checks for existing `taskId` (choose to update priority instead of creating duplicate).
- `edit` handles missing task (no crash).
- `removeTask` returns `null` if task not found (your version did but callers lacked checks).
- Clearer variable names and small optimizations.
- Comments kept short and relevant.

```javascript []
class TaskManager {
    _taskHeap = null;

    constructor(tasks){
        this._taskHeap = new CHeap(this._compareTasks);

        for(const [userId, taskId, priority] of tasks){
            this._taskHeap.append({userId, taskId, priority});
        }
    }

    _compareTasks(childTask, parentTask){
        let childtaskIsMorePrior = true;

        if(childTask.priority > parentTask.priority) childtaskIsMorePrior = true;
        else if((childTask.priority === parentTask.priority) && (childTask.taskId > parentTask.taskId)) childtaskIsMorePrior =  true;
        else childtaskIsMorePrior = false;

        return childtaskIsMorePrior;
    }

    add(userId, taskId, priority) {
        this._taskHeap.append({userId, taskId, priority});
    }

    edit(taskId, newPriority) {
        this._taskHeap.updatePriority(taskId, newPriority);
    }

    rmv(taskId) {
        this._taskHeap.removeTask(taskId);
    }

    execTop() {
        const rootTask = this._taskHeap.pop();
        return rootTask ? rootTask.userId : -1;
    }
}

class CHeap{
    _taskIdStore = new Map(); // taskId : index of node in heap
    _heap = []; // heap is complete-binery-tree - We can represent this as array

    // This function 'True' if argument1 more prior than argument2 node
    _check = null; // comparator function => f(childNode, parentNode) -> boolean

    // get comparator function as setter initially
    constructor(comparatorFunction){
        if(typeof(comparatorFunction) === "function"){
            this._check = comparatorFunction;
        }
    }

    _swap(index1, index2){
        const temp = this._heap[index1];
        this._heap[index1] = this._heap[index2];
        this._heap[index2] = temp;

        this._updateIndex(this._heap[index1], index1);
        this._updateIndex(this._heap[index2], index2);
    }

    _updateIndex(node, index){
        this._taskIdStore.set(node.taskId, index);
    }

    // upward heapification - low end added node push up to check it's right position
    _upwardHeapification(_childNodeIndex){
        let childIndex = _childNodeIndex;

        while(childIndex > 0){ 
            const parentIndex = Math.floor((childIndex-1)/2);

            const shouldChildNodeGoUp = this._check(this._heap[childIndex], this._heap[parentIndex]);
            if(shouldChildNodeGoUp) { 
                this._swap(childIndex, parentIndex);
                childIndex = parentIndex;
            } else break;
        }
    }

    // downward heapification - upper end node pushing down to check it's right position
    _downwardHeapification(_parentNodeIndex){
        let parentIndex = _parentNodeIndex;
        // heap is representation of binery tree --> each parent will have 0, 1, 2 nodes as a child/children
        // childIndex1 = parentIndex*2+1;
        // childIndex2 = parentIndex*2+2;

        // there at least 1 child node should have to compare
        while((parentIndex*2+1) < this._heap.length){ 
            const childIndex1 = parentIndex*2+1;
            const childIndex2 = parentIndex*2+2;

            // now we need to check among 2 children - from which child parent should compare?
            // We will compare parent to most prior child among 2 children
            let mostPriorChildIndex = childIndex1;
            const child2Exist = (childIndex2 < this._heap.length);
            if(child2Exist && this._check(this._heap[childIndex2], this._heap[childIndex1])){
                mostPriorChildIndex = childIndex2;
            }

            const shouldChildNodeGoUp = this._check(this._heap[mostPriorChildIndex], this._heap[parentIndex]);
            if(shouldChildNodeGoUp) {
                this._swap(mostPriorChildIndex, parentIndex);
                parentIndex = mostPriorChildIndex;
            } else break;
        }
    }

    // add new node to heap
    append(node){
        this._heap.push(node);                  // new node added at leaf
        let childIndex = this._heap.length-1;   // new added node's current position
        this._updateIndex(node, childIndex);
        this._upwardHeapification(childIndex);  // this will push this child node upward in heap to it's right position in O(LogN)
    }

    // remove root node from heap
    pop(){
        if(this.isEmpty()) return null;
        if(this._heap.length === 1) { 
            const root = this._heap.pop();
            // remove mapping for the popped node
            this._taskIdStore.delete(root.taskId);
            return root;
        }
       
        this._swap(0, this._heap.length-1); // replace root node with leaf node
        const rootNode = this._heap.pop(); // root node (which right now at leaf) pop and store
        this._downwardHeapification(0); // that leaf node (which right now at root) push downward in heap to it's right position in O(LogN)

        this._taskIdStore.delete(rootNode.taskId);
        return rootNode;
    }

    // remove spesefic index node from heap
    removeTask(taskId){
        const index = this._taskIdStore.get(taskId);
        // if task dose not exist in heap
        if(typeof index !== 'number' || index < 0 || index >= this._heap.length) return null;

        // simmiler to pop but for specific indexed node 
        this._swap(index, this._heap.length-1); // replace root node with leaf node
        const removedNode = this._heap.pop(); // index node (which right now at leaf) pop and store

        // remove mapping for the popped node
        this._taskIdStore.delete(taskId);

        // the node swapped into `index` may need to move down or up
        if(index < this._heap.length) {
            this._downwardHeapification(index);
            this._upwardHeapification(index);
        }

        return removedNode;
    }

    // update priority of any node 
    updatePriority(taskId, newPriority){
        const index = this._taskIdStore.get(taskId);
        if((typeof index === 'number') && (index >= 0) && (index < this._heap.length)){
            const oldPriority = this._heap[index].priority;
            this._heap[index].priority = newPriority;

            if(oldPriority < newPriority)  this._upwardHeapification(index);
            else this._downwardHeapification(index);
        }
    }

    // check is heap empty
    isEmpty(){
        return this._heap.length === 0;
    }
}
```

## ðŸ“Š Complexity

- **Add**: `O(log n)` (heap push + heapify)
- **Edit**: `O(log n)` (remove by index + push)
- **Remove (rmv)**: `O(log n)` (swap + pop + heapify)
- **ExecTop**: `O(log n)` (pop root)
- **Space**: `O(n)` for heap + map
