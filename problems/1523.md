# ðŸ§© Problem #1523 â€“ Count Odd Numbers in an Interval Range

**Difficulty:** Easy  
**Topics:** `Math`  
**Link:** https://leetcode.com/problems/count-odd-numbers-in-an-interval-range/

---

## ðŸ“ Problem Summary

You are given two non-negative integers `low` and `high`.

Your task is to return the **count of odd numbers** between `low` and `high` (inclusive).

**Constraints:**
- 0 â‰¤ low â‰¤ high â‰¤ 1e9

---

## ðŸ’¡ Intuition

Instead of checking every number in the range, think mathematically:

If we can compute how many **odd numbers exist from 1 to x**,  
then odds in any interval [low, high] can be calculated using:

```text
odds(low..high) = f(high) âˆ’ f(low âˆ’ 1)
```


Where f(x) gives the number of odd integers in [1, x].

Now observe the pattern:

1 â†’ 1 odd  
2 â†’ 1 odd  
3 â†’ 2 odds  
4 â†’ 2 odds  
5 â†’ 3 odds  

This leads to a simple formula:

```text
f(x) = floor((x + 1) / 2)
```

This avoids loops entirely and gives an **O(1)** solution.

---

## ðŸƒ Approach 1 â€” Adjust Range to Nearest Odds

Idea:

1. Start with the original range `[low, high]`.
2. If `low` is even, move it to the **next odd**: `low + 1`.
3. If `high` is even, move it to the **previous odd**: `high âˆ’ 1`.
4. Now the new range `[l, h]` (after adjustment) has:
   - Both ends odd (if any odds exist at all),
   - All odd numbers spaced by 2.

Example:

- low = 3, high = 9  
  - `l = 3` (already odd)  
  - `h = 9` (already odd)  
  - Odds: 3, 5, 7, 9 â†’ count = `(9 âˆ’ 3) / 2 + 1 = 4`

- low = 2, high = 8  
  - `l = 3` (next odd after 2)  
  - `h = 7` (previous odd before 8)  
  - Odds: 3, 5, 7 â†’ count = `(7 âˆ’ 3) / 2 + 1 = 3`

If after adjustment `l > h`, it means there are **no odd numbers** in the range,  
and the formula naturally gives 0.

### ðŸ§¾ Code â€” Approach 1 (Range Adjustment)

```ts
function countOdds(low: number, high: number): number {
    let l = low;
    let h = high;

    if (l % 2 === 0) l++;  // move low to next odd if needed
    if (h % 2 === 0) h--;  // move high to previous odd if needed

    // If no odds in range, return 0
    if (l > h) return 0;

    // Both l and h are odd here, odds are spaced every 2
    return (h - l) / 2 + 1;
}
```

### ðŸ“Š Complexity Analysis

- **Time:** O(1)
- **Space:** O(1)
- Simple arithmetic after adjusting `low` and `high`.

---

## ðŸŒ± Approach 2 â€” Pure Math (Optimal)

We use a direct formula to count how many odd numbers exist from 1 to x:

```text
f(x) = floor((x + 1) / 2)
```
This gives the number of odd integers in `[1, x]`.

So the count of odd numbers in `[low, high]` is:

```ts
f(high) âˆ’ f(low âˆ’ 1)
```

This avoids:
- No loops  
- No range adjustments  
- No condition checks  

Just pure O(1) arithmetic.

### ðŸ§¾ Code â€” Approach 2 (Optimal Math Formula)

```ts
function countOdds(low: number, high: number): number {
    const f = (x: number): number => {
        if (x < 0) return 0;               // handle low = 0 â†’ low - 1 = -1
        return Math.floor((x + 1) / 2);    // number of odds in [1, x]
    };

    return f(high) - f(low - 1);
}
```

### ðŸ“Š Complexity Analysis

- **Time:** O(1)
- **Space:** O(1)
- Uses direct mathematical computation with no conditionals or loops.

---
