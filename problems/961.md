# üß© Problem #961 ‚Äì N Repeated Element in Size 2N Array

**Difficulty:** Easy  
**Topics:** `Hashing`, `Math`, `Array`  
**Link:** https://leetcode.com/problems/n-repeated-element-in-size-2n-array/

---

## üìù Problem Summary

You are given an integer array `nums` with the following properties:

- `nums.length = 2 * n`
- `nums` contains exactly `n + 1` **distinct** elements
- **One element is repeated exactly `n` times**
- All other elements appear **once**

Your task is to **return the element that is repeated `n` times**.

### Constraints
- `2 ‚â§ n ‚â§ 5000`
- `0 ‚â§ nums[i] ‚â§ 10^4`
- Exactly one element occurs `n` times

---

## üí° Intuition

We are given a very special constraint:

- Array size = `2n`
- Total unique elements = `n + 1`
- Exactly **one element appears `n` times**
- All other elements appear **once**

This creates a strong imbalance:
> One value dominates **half of the array**.

Key insight:
- The repeated element is **guaranteed** to appear very frequently.
- We do **not** need full frequency counting to identify it.

This allows multiple strategies:

1. **Counting-based approach**  
   - Count occurrences using a Map.
   - Return the element whose frequency is `n`.

2. **Early detection approach**  
   - As soon as we see a number twice, we can return it.
   - Because all other numbers appear only once.

3. **Mathematical / probability observation**  
   - In any window of size 4, the repeated element must appear.
   - Checking small neighborhoods is enough.

These constraints make this problem much easier than it looks at first glance.

---

## üõ† Approaches

This problem has multiple valid approaches because of its **strong constraints**:

- Array size = `2n`
- Exactly **one element appears `n` times**
- All other elements appear **once**

We can exploit this structure in different ways.

---

### üîπ Approach 1 ‚Äî Frequency Map (Your Solution)

**Idea**

- Count the frequency of each number.
- The element with frequency `n` is the answer.

**Why it works**

- Only one element is repeated `n` times.
- Others appear once, so the frequency check is unambiguous.

**Trade-offs**

- Simple and very safe.
- Uses extra space for the map.

---

### üîπ Approach 2 ‚Äî Early Exit Using Set (Optimized)

**Idea**

- Traverse the array.
- The first element that appears **twice** must be the one repeated `n` times.

**Why this works**

Because:
- One element is repeated `n` times.
- All others appear exactly once.
- By the pigeonhole principle, the repeated element will collide quickly.

**Key Insight**

You **don‚Äôt need to count up to `n`** ‚Äî  
the **first duplicate is guaranteed to be the answer**.

---

### Summary

| Approach | Time | Space | Notes |
|--------|------|-------|------|
| Frequency Map | O(n) | O(n) | Safest & clearest |
| Set + Early Exit | O(n) | O(n) | Faster in practice |

---

## üçÉ Approach 2 ‚Äî Early Exit Using HashSet

### Idea

Instead of counting frequencies fully, we can stop as soon as we see a number **for the second time**.

Why this works:
- Exactly **one number is repeated `n` times**
- All other numbers appear **exactly once**
- So the **first duplicate we encounter must be the answer**

### Algorithm
1. Create an empty `Set`
2. Traverse the array:
   - If the number already exists in the set ‚Üí return it immediately
   - Otherwise, add it to the set

### Code (TypeScript)

```ts
function repeatedNTimes(nums: number[]): number {
    const seen = new Set<number>();

    for (const num of nums) {
        if (seen.has(num)) return num;
        seen.add(num);
    }

    return -1; // unreachable due to problem constraints
}
```

### Complexity

- **Time:** `O(n)`
- **Space:** `O(1)`

### Notes

- No extra memory
- Relies on problem guarantees
- Slightly non-intuitive, but elegant once understood

---


