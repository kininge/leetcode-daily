# 🧩 Problem #1277 – Count Square Submatrices with All Ones  

**Difficulty:** Medium  
**Topics:** `Dynamic Programming`, `Matrix`  
**Link:** [Leetcode 1277](https://leetcode.com/problems/count-square-submatrices-with-all-ones/)  

---

## 💡 Intuition  

This problem feels like an extension of **subarray counting (1D)** into **2D**.  

- In 1D (like `Zero-filled Subarrays`), we used *arithmetic series* to count streaks.  
- In 2D, instead of streaks → we care about **squares of 1s**.  

Key observation:  
👉 For each cell `(i, j)`, if it is `1`, it can potentially be the **bottom-right corner** of a square.  
The size of that square depends on its neighbors:  
- top `(i-1, j)`  
- left `(i, j-1)`  
- top-left `(i-1, j-1)`  
![Screenshot 2025-08-20 at 6.47.45 PM.png](https://assets.leetcode.com/users/images/ef0eda64-4d6d-46b1-b3ba-ed1bbce9face_1755696873.184733.png)


If all three support a smaller square, then we can extend it.  

---

## 🛠 Approach  

We use **Dynamic Programming (DP)**:  

1. If `matrix[i][j] == 0` → no square ends here.  
2. Otherwise:  
   $$dp[i][j] = \min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1$$
   (with boundaries treated as `0`).  

This formula works because:  
- A new square can only form if top, left, and top-left cells also had squares.  
- Taking the `min` ensures we only extend as far as the smallest neighbor allows.  

👉 Each cell’s `dp[i][j]` tells us: *“How many different square sizes end at this cell”*.  
So we just sum them all up.  

![Screenshot 2025-08-20 at 7.01.42 PM.png](https://assets.leetcode.com/users/images/070802e1-8e1a-4bad-a95a-d3094d66adb6_1755696966.8094165.png)


We can even do this `in-place` by updating `matrix[i][j]` itself.  

---

## 📊 Complexity  

- **Time:** $$O(m * n)$$ → visit each cell once.  
- **Space:** $$O(1)$$ if updating in-place, else $$O(m * n)$$.  

---

## ✍️ Code  

```javascript []
var countSquares = function(matrix) {
    let total = 0;

    for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < matrix[0].length; j++) {
            if (matrix[i][j] === 1 && i > 0 && j > 0) {
                matrix[i][j] = Math.min(
                    matrix[i - 1][j], 
                    matrix[i][j - 1], 
                    matrix[i - 1][j - 1]
                ) + 1;
            }
            total += matrix[i][j];
        }
    }
    return total;
};
```
---

## 📚 Extra Insight

This problem is a 2D generalization of counting subarrays:

- Zero-filled subarrays → 1D streaks → triangular numbers. [![2348](https://img.shields.io/badge/2348-Number_of_Zero_Filled_Subarrays-yellow)](https://github.com/kininge/leetcode-daily/blob/main/problems/2348.md) 
- Count square submatrices (Leetcode 1277) → 2D streaks → DP squares.

Every time you extend a square by +1 size, you’re stacking smaller squares inside it.
That’s why the DP sum works directly: each `dp[i][j]` already counts all squares ending at `(i, j)`.

