# 🧩 Problem #2043 – Simple Bank System

**Difficulty:** Medium  
**Topics:** `Design`
**Link:** [Leetcode](https://leetcode.com/problems/simple-bank-system/)

---

## 🧠 Intuition

We need to simulate a **bank system** supporting three operations:

1. **deposit(account, money)** → add `money` to `account`
2. **withdraw(account, money)** → remove `money` if enough balance
3. **transfer(account1, account2, money)** → move money between two valid accounts

The catch:  
All operations must be **validated** before updating any balance:
- Accounts must exist (`1 <= account <= n`)
- No overdrawing (balance must be ≥ money)

The problem is pure **OOP design** — correctness, validation, and efficiency matter more than complex algorithms.

--- 

## 🧩 Approach — Array-backed Bank (Clean & Efficient)

### 💡 Idea
Each account is identified by an index `1..n`.  
We can store all balances in an array `balances[]`, where:

```text
balances[i] = current balance of account (i+1)
```

All operations become simple and constant-time lookups:
- **Validation:** `account` must be within `[1, n]`
- **Deposit:** `balances[account - 1] += money`
- **Withdraw:** check then subtract
- **Transfer:** check both accounts + sufficient balance, then subtract and add

### 💻 Code (TypeScript)
```Typescript
class Bank {
  private balances: number[];

  constructor(balance: number[]) {
    //Initialise all account balances
    this.balances = balance.slice();
  }

  private valid(account: number): boolean {
    return account >= 1 && account <= this.balances.length;
  }

  deposit(account: number, money: number): boolean {
    if (!this.valid(account)) return false;
    this.balances[account - 1] += money;
    return true;
  }

  withdraw(account: number, money: number): boolean {
    if (!this.valid(account)) return false;
    const i = account - 1;
    if (this.balances[i] < money) return false;
    this.balances[i] -= money;
    return true;
  }

  transfer(account1: number, account2: number, money: number): boolean {
    if (!this.valid(account1) || !this.valid(account2)) return false;
    const i = account1 - 1;
    const j = account2 - 1;
    if (this.balances[i] < money) return false;
    this.balances[i] -= money;
    this.balances[j] += money;
    return true;
  }
}
```

### ⏱️ Complexity
| Operation | Time | Space |
|------------|------|--------|
| Initial account load | `O(n)` | `O(n)` |
| deposit | `O(1)` | `O(1)` |
| withdraw | `O(1)` | `O(1)` |
| transfer | `O(1)` | `O(1)` |

All operations run in constant time — efficient even for 10⁴ calls per method.

---

## 🧩 Example

```text
const bank = new Bank([10, 100, 20, 50, 30]);

console.log(bank.withdraw(3, 10)); // true → account 3 now 10
console.log(bank.transfer(5, 1, 20)); // true → a5:10, a1:30
console.log(bank.deposit(5, 20)); // true → a5:30
console.log(bank.transfer(1, 3, 40)); // false → a1 has only 30
```

---

## ⚙️ Key Design Notes

- Using an **array** instead of a `Map` keeps memory lower and operations faster.
- The main pitfalls are:
  - Forgetting to validate both accounts in `transfer`
  - Using commas instead of logical `&&` in checks (common bug!)
- Use clear helper methods like `valid()` for readability and safety.

---

## ✅ Takeaway

This problem is not about algorithms — it’s about **clean, safe OOP design**.

Focus on:
- Validation before mutation ✅  
- Minimal lookups ✅  
- Constant-time updates ✅  

If your `transfer`, `withdraw`, and `deposit` all handle checks gracefully,  
Your solution will pass every test without breaking a sweat 💸

---
