# üß© Problem #944 ‚Äì Delete Columns to Make Sorted

**Difficulty:** Easy  
**Topics:** `String`, `Matrix`  
**Link:** https://leetcode.com/problems/delete-columns-to-make-sorted/

---

## üìä Complexity Analysis

Let:
- `n = strs.length` (number of rows)
- `m = strs[0].length` (number of columns)

### Time Complexity
- We iterate column by column ‚Üí `m`
- For each column, we scan all rows ‚Üí `n`
  ```text
  Time = O(n √ó m)
  ```
  
This is optimal because:
- Every character must be checked at least once to verify column order.

### Space Complexity
- Only a few variables are used (`previousCharCode`, counters).
- No extra data structures proportional to input size.
  ```text
  Space = O(1)
  ```

The solution is both **time-optimal and space-optimal**.

---

## üí° Intuition

Each string has the same length, so the input can be visualized as a grid:

- Rows ‚Üí strings
- Columns ‚Üí characters at the same index across all strings

A column is **sorted** if its characters are in **non-decreasing lexicographical order** from top to bottom.

So the task reduces to:

- Iterate **column by column**
- For each column, check whether:
  ```text
  strs[0][j] ‚â§ strs[1][j] ‚â§ ... ‚â§ strs[n-1][j]
  ```
- If **any violation** occurs in a column, that column must be deleted.

Key observation:
- The moment we find one decreasing pair in a column, we can stop checking that column and count it as invalid.

---

## üõ† Approach

We treat the input as a grid and scan it **column by column**.

Steps:

1. Let `n` be the number of strings (rows) and `m` be the length of each string (columns).
2. For each column `j` from `0` to `m - 1`:
   - Compare characters from top to bottom:
     ```
     strs[0][j], strs[1][j], ..., strs[n-1][j]
     ```
   - If at any row `i`:
     ```
     strs[i-1][j] > strs[i][j]
     ```
     then the column is **not sorted**.
3. As soon as a column is detected as not sorted:
   - Increment the deletion count.
   - Stop checking further rows for that column (early exit).
4. Return the total number of such columns.

This avoids unnecessary comparisons and keeps the logic simple.

### üßæ Code

```ts
function minDeletionSize(strs: string[]): number {
    const n = strs.length;
    const m = strs[0].length;

    let notSorted = 0;

    // Traverse column by column
    for (let j = 0; j < m; j++) {
        let prevCharCode = strs[0].charCodeAt(j);

        for (let i = 1; i < n; i++) {
            const currCharCode = strs[i].charCodeAt(j);

            if (prevCharCode > currCharCode) {
                notSorted++;
                break; // no need to check further rows in this column
            }

            prevCharCode = currCharCode;
        }
    }

    return notSorted;
}
```

### ‚è±Ô∏è Complexity Analysis

- Time Complexity: `O(n √ó m)`
  where:
    n = number of strings
    m = length of each string
    In the worst case, every column is fully scanned.

- Space Complexity: `O(1)`
  Only constant extra variables are used.

---

