# üß© Problem #3606 ‚Äì Coupon Code Validator

**Difficulty:** Easy  
**Topics:** `String`, `Sorting`     
**Link:** https://leetcode.com/problems/coupon-code-validator/

---

## üìù Problem Summary

You are given three arrays of equal length `n`:

- `code[i]`: string representing the coupon identifier
- `businessLine[i]`: string representing the business category
- `isActive[i]`: boolean indicating whether the coupon is active

A coupon is considered **valid** if all of the following hold:

1. `code[i]` is **non-empty** and contains only:
   - lowercase letters `a‚Äìz`
   - uppercase letters `A‚ÄìZ`
   - digits `0‚Äì9`
   - underscore `_`
2. `businessLine[i]` is one of:
   - `"electronics"`, `"grocery"`, `"pharmacy"`, `"restaurant"`
3. `isActive[i]` is `true`

### Output requirement

- Return the list of **valid coupon codes**
- Sorted by:
  1. `businessLine` in this exact order:
     ```
     electronics ‚Üí grocery ‚Üí pharmacy ‚Üí restaurant
     ```
  2. Lexicographical (ASCII) order of `code` within each category

---

## üí° Intuition

This is a classic **filter + group + sort** problem.

Observations:

- The number of business categories is **fixed (4)** and their order is predefined.
- Each coupon can be validated independently:
  - check `isActive`
  - validate `code` with a regex
  - verify `businessLine` is one of the allowed categories
- Once validated, coupons should be:
  1. grouped by `businessLine` **in fixed order**
  2. sorted **lexicographically (ASCII)** within each group
  3. concatenated in category order

So the plan is:

1. Map each `businessLine` to an index `0..3`
2. Use 4 buckets (arrays) ‚Äî one per category
3. One pass to filter and push codes into the right bucket
4. Sort each bucket
5. Merge all buckets into the final result

This keeps the logic simple, fast, and easy to reason about.

---

## üõ† Approach

We apply a single-pass filtering and grouping strategy with minimal overhead.

### Key design decisions

1. **Fixed category order mapping**
   - Since the businessLine order is fixed, map each category to an index once.
   - This avoids using a `Set` and eliminates a `switch` statement.

2. **Single regex instance**
   - Compile the coupon-code regex once and reuse it for all checks.

3. **ASCII-safe sorting**
   - Use direct string comparison (`<`, `>`) to ensure strict lexicographical (ASCII) order.
   - This avoids locale-dependent behavior that can break test cases.

### Steps

1. Create a mapping:
  ```text
  electronics ‚Üí 0
  grocery ‚Üí 1
  pharmacy ‚Üí 2
  restaurant ‚Üí 3
  ```
2. Create 4 buckets (arrays), one per category.
3. Iterate once over the input arrays:
  - Validate coupon
  - Push valid codes into the correct bucket
4. Sort each bucket lexicographically.
5. Concatenate buckets in order to form the final result.

### Code (TypeScript)

```ts
function validateCoupons(
    code: string[],
    businessLine: string[],
    isActive: boolean[]
): string[] {

    // Fixed category order
    const order: Record<string, number> = {
        electronics: 0,
        grocery: 1,
        pharmacy: 2,
        restaurant: 3
    };

    // Regex created once
    const validPattern = /^[a-zA-Z0-9_]+$/;

    const buckets: string[][] = [[], [], [], []];

    // O(n) filtering and grouping
    for (let i = 0; i < code.length; i++) {
        const c = code[i];
        const b = businessLine[i];

        if (
            isActive[i] &&
            c.length > 0 &&
            validPattern.test(c) &&
            order[b] !== undefined
        ) {
            buckets[order[b]].push(c);
        }
    }

    // ASCII-safe lexicographical sorting
    for (const bucket of buckets) {
        bucket.sort((a, b) => {
            if (a > b) return 1;
            if (a < b) return -1;
            return 0;
        });
    }

    // Merge in category order
    return buckets.flat();
}
```

### üìä Complexity Analysis

Let `n` be the number of coupons.

- **Filtering & grouping:** `O(n)`
- **Sorting:**  
  - Each coupon is sorted once within its category  
  - Overall: `O(n log n)`
- **Total time complexity:** `O(n log n)`
- **Space complexity:** `O(n)`
  - Four buckets together store at most `n` coupon codes

---

## üìå Key Takeaways

- Your original logic was **correct** and already optimal.
- The improvements focused only on **code quality and correctness**, not changing the algorithm:
  1. Removed unnecessary `Set` usage
  2. Avoided recreating the regex in every iteration
  3. Preserved **ASCII-based** lexicographical sorting (important ‚Äî `localeCompare` would fail some cases)
- When problem statements say ‚Äúlexicographical order‚Äù without specifying locale, **assume ASCII order** in LeetCode.
- Fixed-category problems are ideal for **bucket-based grouping** ‚Äî clean, fast, and easy to extend.

This final solution is concise, efficient, and robust against tricky edge cases.

---
