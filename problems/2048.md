# üß© Problem #2048 ‚Äì Next Greater Numerically Balanced Number

**Difficulty:** Medium  
**Topics:** `Math`, `Precomputation`, `Binary Search`  
**Link:** [Leetcode](https://leetcode.com/problems/next-greater-numerically-balanced-number/)

---

## üß† Intuition

A number is **numerically balanced** if for every digit `d` in it,  
the count of `d` in the number equals `d` itself.  

For example:
- `22` ‚Üí digit `2` occurs twice ‚úÖ  
- `1333` ‚Üí digit `1` occurs once and `3` occurs three times ‚úÖ  
- `122` ‚Üí digit `1` occurs once but `2` occurs twice ‚úÖ  
- `123` ‚ùå (digits `1`, `2`, `3` all appear once)

---

Our goal:  
> Find the **smallest numerically balanced number** strictly **greater than `n`**.

### Key Insight
There are **very few numerically balanced numbers** in existence.  
Each digit `d` contributes exactly `d` occurrences ‚Äî  
so the total number of digits = sum of selected digits.

Example:
- `{2}` ‚Üí "22" (length 2)  
- `{1,2}` ‚Üí permutations of [1] + [2,2] ‚Üí "122", "212", "221"  
- `{3}` ‚Üí "333" (length 3)

Even if we include all digits 1‚Äì6, the longest possible is `1224444` (7 digits).  
So, there are **only 110 valid numbers** ‚Äî a tiny, fixed set.  

Hence:
- We can **check each number** (brute force).
- Or **precompute** all valid numerically balanced numbers.
- Or **binary search** in the precomputed sorted list to get the next one.

All of these yield the same answer ‚Äî the choice is just about performance and elegance.

---

## üß© Approach 1 ‚Äî Brute Force

### üí° Idea
Start from `n + 1` and check every number until you find one that is numerically balanced.  
Since `n ‚â§ 10^6`, the loop range is small enough to work,  
though not the most efficient way.

### Steps
1. Increment from `n + 1` upward.
2. For each number:
   - Count occurrences of each digit.
   - Skip if it contains `0` (not valid).
   - Check if each digit `d` appears exactly `d` times.
3. The first number that passes the test is your answer.


### üíª Code (TypeScript)

```TypeScript []
function nextBeautifulNumber(n: number): number {
  const MAX_LIMIT = 1224444; // largest numerically balanced number

  function isBalanced(num: number): boolean {
    const count= new Map<number, number>();
    let tmp:number = num;

    while (tmp > 0) {
      const d = tmp % 10;
      tmp = Math.floor(tmp / 10);

      if (d === 0) return false; // cannot have 0
      count.set(d, (count.get(d) ?? 0) + 1);
      if (count.get(d)! > d) return false; // too many occurrences
    }

    for (const [digit, freq] of count.entries()) {
      if (digit !== freq) return false;
    }

    return true;
  }

  for (let num = n + 1; num <= MAX_LIMIT; num++) {
    if (isBalanced(num)) return num;
  }

  return -1;
}
```

### ‚è±Ô∏è Complexity

- **Time:** `O(R √ó D)`
  - `R` = range between `n` and the next balanced number (small)
  - `D` = number of digits per number (‚â§ 7)
- **Space:** `O(1)`

---

## üß© Approach 2 ‚Äî Precomputed Numerically Balanced Numbers

### üí° Idea
Since there are **only 110 numerically balanced numbers** in total (for digits 1‚Äì6),  
we can simply **precompute** them once and store them in an array.

Then, for any input `n`, just find the first number in the list that is greater than `n`.


### üßÆ Why this works
- Every numerically balanced number follows the rule:  
  each digit `d` appears exactly `d` times.  
- These combinations are finite and can be enumerated manually or programmatically.  
- Once stored, finding the next number becomes a constant-time operation.


### üíª Code (TypeScript)
```Typescript []
function nextBeautifulNumber(n: number): number {
  // Total 110 numerically balanced numbers
  const beautifulNumbers: number[] = [
    1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444,
    22333, 23233, 23323, 23332, 32233, 32323, 32332, 33223, 33232,
    33322, 41444, 44144, 44414, 44441, 55555, 122333, 123233, 123323,
    123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555,
    212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331,
    224444, 231233, 231323, 231332, 232133, 232313, 232331, 233123,
    233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424,
    244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233,
    321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213,
    323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132,
    332213, 332231, 332312, 332321, 333122, 333212, 333221, 422444,
    424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242,
    444422, 515555, 551555, 555155, 555515, 555551, 666666, 1224444
  ];

  // O(110) ~ O(1)
  for (const num of beautifulNumbers) {
    if (num > n) return num;
  }

  return -1;
}
```

### ‚è±Ô∏è Complexity

- **Time:** `O(110)` ‚Üí effectively `O(1)`
- **Space:** `O(110)` ‚Üí constant memory

---

## üß© Approach 3 ‚Äî Precomputed List + Binary Search (robust, production-ready)

### üí° Idea (short)
Keep the same precomputed sorted list of numerically balanced numbers, but use binary search to find the **first element > n**.  
This avoids a tiny linear scan and is defensive (no hard-coded indices).

### üíª Code (TypeScript)
```Typescript []
function nextBeautifulNumber(n: number): number {
    // total possible 110 numerically beautiful numbers
    const beautifulNumbers:number[] = [1,     22,    122,    212,    221,    333,   1333,
    3133,   3313,   3331,   4444,  14444,  22333,  23233,
   23323,  23332,  32233,  32323,  32332,  33223,  33232,
   33322,  41444,  44144,  44414,  44441,  55555, 122333,
  123233, 123323, 123332, 132233, 132323, 132332, 133223,
  133232, 133322, 155555, 212333, 213233, 213323, 213332,
  221333, 223133, 223313, 223331, 224444, 231233, 231323,
  231332, 232133, 232313, 232331, 233123, 233132, 233213,
  233231, 233312, 233321, 242444, 244244, 244424, 244442,
  312233, 312323, 312332, 313223, 313232, 313322, 321233,
  321323, 321332, 322133, 322313, 322331, 323123, 323132,
  323213, 323231, 323312, 323321, 331223, 331232, 331322,
  332123, 332132, 332213, 332231, 332312, 332321, 333122,
  333212, 333221, 422444, 424244, 424424, 424442,  442244, 442424,
  442442,  444224, 444242,
  444422,  515555, 551555,
  555155,  555515, 555551,
  666666, 1224444];

    let leftIndex:number = 0;
    let rightIndex:number = 109;
    let ansIndex: number = 109;

    //O(log(110)) ~ O(1) - in 2 iteration is will find the solution
    while(leftIndex <= rightIndex){
        const midIndex:number = (leftIndex+rightIndex)>>1; // floor division by 2

        if(beautifulNumbers[midIndex] > n){
            ansIndex = midIndex;
            // check further left - immediate greater number
            rightIndex = midIndex-1;
        } else leftIndex = midIndex+1;
    }

    return beautifulNumbers[ansIndex];
}
```

### ‚è±Ô∏è Complexity

- **Time:** `O(log 110)` ‚Üí effectively `O(1)`
- **Space:** `O(110)` ‚Üí constant memory

---

## ‚öñÔ∏è Comparison ‚Äî Three Approaches

| # | Approach | Time | Space | Practicality / Notes |
|---:|---|---:|---:|---|
| 1 | **Brute Force** (check `n+1`, `n+2`, ...) | `O(R √ó D)` where `R` = distance to next balanced number (worst-case small), `D ‚â§ 7` | `O(1)` | Simple and obvious. Works fine for single occasional calls and small gaps. Repeated queries or worst-case long gaps are wasteful. |
| 2 | **Precomputed List (linear scan)** | `O(110)` ‚Üí effectively `O(1)` | `O(110)` ‚Üí `O(1)` | Extremely simple and blazing fast. Minimal code. Keep the list sorted. Best practical approach for this problem. |
| 3 | **Precomputed List + Binary Search** | `O(log 110)` ‚Üí effectively `O(1)` | `O(110)` ‚Üí `O(1)` | Same benefits as #2 but more defensive and production-ready. No linear scan; robust to list changes. Slightly more code but negligible cost. Recommended for production. |

### When to pick which
- **If you want the simplest implementation for a quick solve or to debug ideas:** use **Approach 1 (Brute Force)**.  
- **If you want the clearest, simplest, fastest solution that‚Äôs easy to reason about:** use **Approach 2 (Precomputed list)**.  
- **If you want a robust, production-ready implementation with no reliance on scanning and with safe lookup semantics:** use **Approach 3 (Precomputed + binary search)** (my recommended default).

### Extra practical notes
- The whole problem is dominated by the fact that the set of valid numbers is tiny (‚âà110). That makes precomputation the obvious engineering win ‚Äî no need to overengineer.
- Keep the precomputed array **sorted** and unit-tested. That removes almost all failure modes.
- If you want absolute zero runtime work (e.g., micro-optimising a hot loop), inline the single next-number lookup as a `switch` or small `Map` literal ‚Äî but that‚Äôs unnecessary here.

---

## ‚úÖ Final Recommendation (short)
Use **Approach 3** (precomputed sorted list + binary search) in production.  
Use **Approach 2** for quick scripts and contests.  
Use **Approach 1** only for learning or tiny inputs.

