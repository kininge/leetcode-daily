# üß© Problem #1578 ‚Äì Minimum Time to Make Rope Colorful

**Difficulty:** Medium  
**Topics:** `Greedy`, `String`, `Two Pointers`, `Stack`  
**Link:** [Leetcode](https://leetcode.com/problems/minimum-time-to-make-rope-colorful)

---

## üß† Problem Intuition

We have a rope of `n` balloons, each balloon having:
- a **color** (`colors[i]`),
- a **removal time** (`neededTime[i]`).

We must remove balloons so that no two consecutive balloons have the same colour.  
The goal is to minimise the total removal time.

**Observation:**  
For each group of consecutive balloons with the same color ‚Äî we must **keep exactly one**, and remove the rest.  
To minimise total removal time, we should **keep the one with the largest `neededTime`**, removing all others.

---

## ‚öôÔ∏è Example

Input:  
`colors = "abaac"`  
`neededTime = [1,2,3,4,5]`

Output:  
`3`

Explanation:  
Consecutive "aa" ‚Üí remove the cheaper one (`3`), keep `4`.  
So total = `3`.

---

## ü™ì Approach 1 ‚Äì Brute Force (Conceptual)

### üí° Idea
Check every possible subset of removals that leaves no two same-colour balloons adjacent.  
Pick the one with the minimum total removal time.

### üíª Code (Typescript)
```ts
// Exponential brute-force - not practical
function bruteForce(colors, neededTime) {
    // recursively remove each balloon or skip
    // if final rope has no consecutive same colors, track total time
}
```

### üßÆ Complexity

- **Time:** `O(2‚Åø)` ‚Äî not feasible for n up to 1e5
- **Space:** `O(n)` recursion depth

---

## üß© Approach 2 ‚Äì Two Pointer / Group Sum

### üí° Idea
Group consecutive balloons of the same colour.
- Calculate the total removal time in that group.
- Subtract the maximum removal time in that group (since that balloon is kept).
- Add the result to the total answer.

### üíª Code (Typescript)
```ts
function minCost(colors: string, neededTime: number[]): number {
    let totalTimeToRemove:number = 0;

    let leftIndex:number = 0; // is like starting point for 
    let rightIndex:number = 1; // leftIndex+1 is checking point (we check all consecutive same colour balloons)

    while(leftIndex < colors.length){
        
        //consecutive same colour balloons analysis
        let totalTime:number = neededTime[leftIndex];
        let maxTime:number = neededTime[leftIndex];
        // console.log(`====> L: ${leftIndex} --> totalTime: ${totalTime} maxTime: ${maxTime}`);
        // expand window until same colour balloons are found
        while((rightIndex < colors.length) && (colors[leftIndex] === colors[rightIndex])){
            maxTime = Math.max(maxTime, neededTime[rightIndex]);
            totalTime += neededTime[rightIndex];
            // console.log(`R: ${rightIndex-1} --> totalTime: ${totalTime} maxTime: ${maxTime}`);
            rightIndex++;
        }

        

        // there must be more than 1 same colour balloon in series
        if((rightIndex-leftIndex) > 1) totalTimeToRemove += (totalTime-maxTime);
        // console.log(`totalTimeToRemove: ${totalTimeToRemove}`);

        leftIndex = rightIndex;
        rightIndex = leftIndex+1;
    }

    return totalTimeToRemove;
};
```

### üßÆ Complexity

- **Time:** `O(n)`
- **Space:** `O(1)`

---

## ‚ö° Approach 3 ‚Äì Greedy (Single Pass)

### üí° Idea
Walk once through the rope:
- If two consecutive balloons have the same colour, remove the one with the smaller removal time.
- Keep track of the larger removal time to compare with future balloons in the same colour streak.

### üíª Code (Typescript)
```ts
function minCost_greedy(colors: string, neededTime: number[]): number {
    let ans = 0;
    let prevMax = neededTime[0];

    for (let i = 1; i < colors.length; i++) {
        if (colors[i] === colors[i - 1]) {
            ans += Math.min(prevMax, neededTime[i]);
            prevMax = Math.max(prevMax, neededTime[i]);
        } else {
            prevMax = neededTime[i];
        }
    }

    return ans;
}
```

### üßÆ Complexity

- **Time:** `O(n)`
- **Space:** `O(1)`

---

## üß± Approach 4 ‚Äì Stack-Based Simulation

### üí° Idea
Use a stack to simulate the rope:
- For each balloon:
  - If the stack top has the same colour, remove the one withthe  smaller `neededTime`.
  - Otherwise, push it.
- Stack stores only the balloons that remain after each step.

### üíª Code (Typescript)
```ts
function minCost_stack(colors: string, neededTime: number[]): number {
    const stack: { color: string, time: number }[] = [];
    let total = 0;

    for (let i = 0; i < colors.length; i++) {
        const c = colors[i];
        const t = neededTime[i];

        if (stack.length && stack[stack.length - 1].color === c) {
            const top = stack[stack.length - 1];
            if (top.time < t) {
                total += top.time;
                stack.pop();
                stack.push({ color: c, time: t });
            } else {
                total += t;
            }
        } else {
            stack.push({ color: c, time: t });
        }
    }

    return total;
}
```

### üßÆ Complexity

- **Time:** `O(n)`
- **Space:** `O(n)` - due to stack

---

## üéØ Comparison

| Approach | Description | Time | Space | Notes |
|-----------|-------------|------|--------|--------|
| Brute Force | Try all removal subsets | O(2‚Åø) | O(n) | Only theoretical |
| Two-Pointer | Group same-color balloons | O(n) | O(1) | Clean and explicit |
| Greedy | Keep larger removal each step | O(n) | O(1) | Simplest optimal form |
| Stack | Simulate rope behavior | O(n) | O(n) | Alternative, intuitive |

---

