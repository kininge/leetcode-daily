# 🧩 Problem #679 – 24 Game  

**Difficulty:** Hard  
**Topics:**  `Recursion`, `Backtracking`, `Math`  
**Link:** [Leetcode](https://leetcode.com/problems/24-game/description/)  

---

## 💡 Problem Understanding
We are given 4 integers (`cards`), each between `1–9`.  
We can apply arithmetic operations (`+`, `-`, `*`, `/`) and use parentheses in any order.  

**Goal:** Check if it’s possible to form an expression that evaluates to **exactly 24**.  

**Constraints:**  
- Division is real division (not integer).  
- Every operation uses two numbers (no unary `-`).  
- No concatenation (e.g., `12` from `1` and `2` not allowed).  

**Key Insight:**  
Instead of manually handling parentheses, recursion itself enforces the grouping. At each step, combine two numbers with all operators, reduce the list, and recurse.  

---

## 🔍 Approach — Recursive Backtracking  

**Idea:**  
Try all possible pairings and operations recursively until only one number remains.  
- If that number is ~24 → success.  
- Else → backtrack and try other combinations.  

**Steps:**  
1. **Base Case:**  
   - If only one number remains, check if it is approximately 24 (`abs(num - 24) < 1e-6`). Because we are doing division so we can get ---> 24.00000001 

2. **Recursive Step:**  
   - Pick any 2 numbers `a` and `b`.  
   - Compute all possible results:  
     - `a + b`  
     - `a - b`, `b - a`  
     - `a * b`  
     - `a / b`, `b / a` (skip if denominator = 0).  
   - Replace `a` and `b` with the result and recurse.  

3. **Termination:**  
   - If any path yields 24 → return true.  
   - If all fail → return false.  

---

### Complexity Analysis
- Input size is fixed at 4 numbers → recursion depth is small.  
- Each step considers ≤ 6 operations for every pair.  
- Total states are bounded → brute force is feasible.  

- **Time Complexity:** `O(1)` beause `O(4!)` but we can say `O(N!)` also if N=4.  
- **Space Complexity:** `O(1)` (recursion stack only).  

---

## code 

```javascript []
var judgePoint24 = function(cards) {
    const EPS = 1e-6;

    const dfs = (nums) => {
        // Base case
        if (nums.length === 1) {
            return Math.abs(nums[0] - 24) < EPS;
        }

        // Try all pairs
        for (let i = 0; i < nums.length; i++) {
            for (let j = i + 1; j < nums.length; j++) {
                const rest = [];
                for (let k = 0; k < nums.length; k++) {
                    if (k !== i && k !== j) rest.push(nums[k]);
                }

                const a = nums[i], b = nums[j];
                const candidates = [a + b, a - b, b - a, a * b];
                if (Math.abs(b) > EPS) candidates.push(a / b);
                if (Math.abs(a) > EPS) candidates.push(b / a);

                for (const val of candidates) {
                    if (dfs([...rest, val])) return true;
                }
            }
        }

        return false;
    };

    return dfs(cards.map(x => x * 1.0));
};
```

---

## 🏆 Key Takeaways
- Parentheses don’t need explicit handling — recursion already enforces grouping.  
- Always test both orders for `-` and `/`.  
- Floating-point comparisons need tolerance (`1e-6`).  
- Despite being tagged “Hard,” the bounded input size makes backtracking the clean and natural solution.  
