# üß© Problem #1161 ‚Äì Maximum Level Sum of a Binary Tree

**Difficulty:** Medium  
**Topics:** `Tree`, `Breadth Frist Search`, `Depth First Search`  
**Link:** https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/

---

## üìù Problem Summary

You are given the root of a binary tree.

- The root node is at **level 1**
- Its children are at **level 2**, and so on

For each level, compute the **sum of node values** at that level.

### Goal
Return the **smallest level index** `x` such that the **sum of values at level `x` is maximum**.

### Constraints
- Number of nodes: `1 ‚â§ N ‚â§ 10^4`
- Node values: `-10^5 ‚â§ val ‚â§ 10^5`

If multiple levels have the same maximum sum, return the **smallest level number**.

---

## üí° Intuition ‚Äî BFS vs DFS

This problem is fundamentally **level-based**:  
we must compute the **sum of values at each level** and return the level with the maximum sum.

There are **two valid traversal strategies**:

---

### üîπ Option 1 ‚Äî BFS (Level-order traversal)

**Why BFS fits naturally**
- BFS processes nodes **level by level**
- Each iteration of the queue corresponds to exactly one level
- Computing level sums is direct and intuitive

**What BFS guarantees**
- Clear mapping between queue size and current level
- No recursion depth issues (safe for skewed trees)
- Easy to track the smallest level when sums tie

This makes BFS the **most straightforward and interview-friendly choice** for level-based problems.

---

### üîπ Option 2 ‚Äî DFS (Depth-first traversal)

**How DFS can also work**
- Traverse the tree recursively
- Pass the current level index down the recursion
- Accumulate sums in an array where `levels[i]` stores the sum of level `i`

**Trade-offs**
- Slightly more compact code
- Requires careful handling of recursion depth
- Uses extra space to store level sums before deciding the answer

DFS is perfectly valid here, but the **level-based nature** of the problem makes BFS conceptually cleaner.

---

### ‚úÖ Decision

Both BFS and DFS solve the problem in **O(n) time**.

- Choose **BFS** when:
  - The problem explicitly talks about levels
  - You want safer execution for deep trees

- Choose **DFS** when:
  - You‚Äôre comfortable with recursion
  - Tree depth is unlikely to cause stack overflow

In interviews (especially Google L4), explicitly stating **both approaches and the reason for choosing one** is more important than the choice itself.

---

## üõ† Approach 1 ‚Äî BFS (Level-Order Traversal)

Since the problem is explicitly **level-based**, BFS is the most natural approach.

### Idea

- Traverse the tree level by level using a queue.
- For each level:
  - Compute the sum of all node values.
  - Track the maximum sum seen so far.
  - Record the corresponding level number.
- If multiple levels have the same sum, keep the **smallest level index**.

### Steps

1. Initialize a queue with the root node.
2. Set `level = 1`.
3. While the queue is not empty:
   - Let `size = queue.length` (number of nodes at current level).
   - Pop `size` nodes, sum their values, and push their children.
   - Compare the current level sum with the maximum.
4. Return the level with the maximum sum.

### Code (TypeScript)

```ts
function maxLevelSum(root: TreeNode | null): number {
    if (!root) return 0;

    const queue: TreeNode[] = [root];
    let level = 1;
    let bestLevel = 1;
    let maxSum = -Infinity;

    while (queue.length > 0) {
        const size = queue.length;
        let sum = 0;

        for (let i = 0; i < size; i++) {
            const node = queue.shift()!;
            sum += node.val;

            if (node.left) queue.push(node.left);
            if (node.right) queue.push(node.right);
        }

        if (sum > maxSum) {
            maxSum = sum;
            bestLevel = level;
        }

        level++;
    }

    return bestLevel;
}
```

### Why BFS is a great fit

- Directly matches the concept of levels
- No recursion ‚Üí no stack overflow risk
- Clean and easy to explain in interviews

---

## üõ† Approach 2 ‚Äî DFS (Depth-First Traversal)

Although BFS maps more naturally to level-based problems, **DFS can also solve this problem correctly**.

### Idea

- Traverse the tree recursively.
- Pass the current `level` during recursion.
- Maintain an array `levels[]` where: `levels[i] = sum of values at level i`
- After traversal, find the index of the maximum value in `levels`.

### Steps

1. Initialize an empty array `levels`.
2. Start DFS from the root at level `0`.
3. For each node:
 - Add its value to `levels[level]`.
 - Recursively process left and right children with `level + 1`.
4. After DFS completes, scan `levels` to find the level with the maximum sum.
5. Return the level index + 1 (since levels are 1-based).

### Code (TypeScript)

```ts
function maxLevelSum(root: TreeNode | null): number {
  const levels: number[] = [];

  function dfs(node: TreeNode | null, level: number): void {
      if (!node) return;

      if (level === levels.length) {
          levels.push(node.val);
      } else {
          levels[level] += node.val;
      }

      dfs(node.left, level + 1);
      dfs(node.right, level + 1);
  }

  dfs(root, 0);

  let bestLevel = 0;
  for (let i = 1; i < levels.length; i++) {
      if (levels[i] > levels[bestLevel]) {
          bestLevel = i;
      }
  }

  return bestLevel + 1;
}
```

### Trade-offs Compared to BFS

| Aspect |	BFS |	DFS |
| ------ | ---- | --- |
| Traversal |	Level-order |	Depth-first |
| Stack safety |	Safe |	Risky for deep trees |
| Mapping to problem |	Direct |	Indirect |
| Code style |	Iterative | Recursive |

### When DFS is acceptable

- Tree depth is reasonable
- You prefer concise recursive code
- Interviewer is okay with recursion

In interviews, explicitly stating why BFS might be preferred even though DFS works demonstrates strong decision-making.

---

## ‚è± Complexity Analysis

Let `n` be the number of nodes in the tree.

### BFS Approach
- **Time Complexity:** `O(n)`
  - Each node is visited exactly once.
- **Space Complexity:** `O(n)`
  - Queue may hold up to one full level of the tree.

### DFS Approach
- **Time Complexity:** `O(n)`
  - Each node is visited exactly once.
- **Space Complexity:** `O(n)`
  - Recursion stack in the worst case (skewed tree).
  - Additional array to store level sums.

Both approaches are optimal in time complexity.

---

## üìå Final Takeaways (What Interviewers Look For)

- This problem can be solved using **both BFS and DFS**.
- **BFS is conceptually cleaner** for level-based problems:
  - Direct mapping between traversal and requirement.
  - No recursion depth issues.
- **DFS is also valid**, but requires:
  - Passing level information.
  - Extra care with recursion depth.

### Interview-Ready Explanation

> ‚ÄúThis problem is level-based, so BFS is the most natural choice.
> DFS also works by accumulating sums per level, but BFS avoids recursion depth issues and matches the problem structure more directly.‚Äù

Being able to **explain why you chose BFS over DFS**, even when both work, is a key signal for **Google L4-level decision making**.

---


