# ðŸ§© Problem #2257 â€“ Count Unguarded Cells in the Grid

**Difficulty:** Medium  
**Topics:** `Simulation`, `Matrix`  
**Link:** [Leetcode](https://leetcode.com/problems/count-unguarded-cells-in-the-grid)

---

## ðŸ§  Problem Intuition

We are given an `m Ã— n` grid containing guards and walls.  
Each guard watches continuously in all four directions until blocked by either another guard or a wall.  
We must count **how many unoccupied cells are not guarded**.

Key insight:  
A cell becomes guarded if at least one guard can "see" it horizontally or vertically without interruption by a wall or another guard.

---

## âš™ï¸ Example

Input:  
`m = 4, n = 6`  
`guards = [[0,0],[1,1],[2,3]]`  
`walls  = [[0,1],[2,2],[1,4]]`

Visualized grid (G=Guard, W=Wall, .=Empty):  

```text
G W * * * *
* G * * W *
* * W G * *
* * * * * *
```

Output:  `7`

Explanation:  7 cells remain unguarded after marking all visible cells in four directions from every guard.

---

## ðŸ§© Approach 1 â€“ Per-Guard Outward Scan (Your Old Logic)

### ðŸ’¡ Idea
For each guard, extend its line of sight in all four directions (top, bottom, left, right) until hitting a wall or another guard.  
Mark any cell along the path as guarded.

### ðŸ§¾ Steps
1. Create a grid filled with `'F'` (free cells).  
2. Mark guards as `'G'` and walls as `'W'`.  
3. For each guard:
   - Move outward in each direction, marking `'R'` (guarded) until blocked.  
4. Count remaining `'F'` cells.

### ðŸ’» Code (JavaScript)
```js
const createGround = (m, n) => Array.from({length: m}, () => Array(n).fill('F'));
const check = (cell) => cell === 'R' || cell === 'F';

var countUnguarded = function(m, n, guards, walls) {
    const ground = createGround(m, n);

    for (const [x, y] of walls) ground[x][y] = 'W';
    for (const [x, y] of guards) ground[x][y] = 'G';

    for (const [x, y] of guards) {
        // top
        for (let i = x - 1; i >= 0 && check(ground[i][y]); i--) ground[i][y] = 'R';
        // bottom
        for (let i = x + 1; i < m && check(ground[i][y]); i++) ground[i][y] = 'R';
        // left
        for (let j = y - 1; j >= 0 && check(ground[x][j]); j--) ground[x][j] = 'R';
        // right
        for (let j = y + 1; j < n && check(ground[x][j]); j++) ground[x][j] = 'R';
    }

    let blind = 0;
    for (let i = 0; i < m; i++)
        for (let j = 0; j < n; j++)
            if (ground[i][j] === 'F') blind++;
    return blind;
};
```

### ðŸ§® Complexity

- **Time:** `O(G Ã— (m+n))` â€” each guard may scan up to grid edges
- **Space:** `O(mÂ·n)`

### âš ï¸ Drawbacks

- Revisits cells when multiple guards share a row or column.
- Slightly slower for dense grids.

---

## âš¡ Approach 2 â€“ Full 4-Sweep DP Grid

### ðŸ’¡ Idea
Rather than scanning outward from each guard, perform four linear sweeps over the entire grid:
1. Leftâ†’Right  
2. Rightâ†’Left  
3. Topâ†’Bottom  
4. Bottomâ†’Top  

Mark guarded cells during sweeps; stop when a wall or guard blocks the view.

### ðŸ’» Code (TypeScript)
```ts
function countUnguarded(m: number, n: number, guards: number[][], walls: number[][]): number {
    // 0 = free, 1 = guard, 2 = wall, 3 = guarded
    const grid = Array.from({ length: m }, () => new Array(n).fill(0));
    for (const [r, c] of guards) grid[r][c] = 1;
    for (const [r, c] of walls)  grid[r][c] = 2;

    // row sweeps
    for (let r = 0; r < m; r++) {
        let seen = false;
        for (let c = 0; c < n; c++) {
            if (grid[r][c] === 2) seen = false;
            else if (grid[r][c] === 1) seen = true;
            else if (seen && grid[r][c] === 0) grid[r][c] = 3;
        }
        seen = false;
        for (let c = n - 1; c >= 0; c--) {
            if (grid[r][c] === 2) seen = false;
            else if (grid[r][c] === 1) seen = true;
            else if (seen && grid[r][c] === 0) grid[r][c] = 3;
        }
    }

    // column sweeps
    for (let c = 0; c < n; c++) {
        let seen = false;
        for (let r = 0; r < m; r++) {
            if (grid[r][c] === 2) seen = false;
            else if (grid[r][c] === 1) seen = true;
            else if (seen && grid[r][c] === 0) grid[r][c] = 3;
        }
        seen = false;
        for (let r = m - 1; r >= 0; r--) {
            if (grid[r][c] === 2) seen = false;
            else if (grid[r][c] === 1) seen = true;
            else if (seen && grid[r][c] === 0) grid[r][c] = 3;
        }
    }

    // count free unguarded cells
    let ans = 0;
    for (let r = 0; r < m; r++)
        for (let c = 0; c < n; c++)
            if (grid[r][c] === 0) ans++;
    return ans;
}
```

### ðŸ§® Complexity

- **Time:** `O(mÂ·n)`
- **Space:** `O(mÂ·n)`

### âš ï¸ Drawbacks

- Each cell is visited only four times (constant factor).
- Clean and guaranteed within constraints (`m*n â‰¤ 10âµ`).

---

## ðŸš€ Approach 3 â€“ Optimised Selective Row/Column Sweeps (Best)

### ðŸ’¡ Idea
We only need to sweep rows and columns that actually contain guards or walls.  
Collect those indices first, then run the 4 sweeps only on those rows/columns.

This avoids touching empty rows/cols entirely.

### ðŸ’» Code (typeScript)
```ts
function countUnguarded(m: number, n: number, guards: number[][], walls: number[][]): number {
    const grid = Array.from({ length: m }, () => new Array(n).fill(0));
    const rowSet = new Set<number>(), colSet = new Set<number>();
    for (const [r, c] of walls) { grid[r][c] = 2; rowSet.add(r); colSet.add(c); }
    for (const [r, c] of guards){ grid[r][c] = 1; rowSet.add(r); colSet.add(c); }

    // row sweeps
    for (const r of rowSet) {
        let seen = false;
        for (let c = 0; c < n; c++) {
            if (grid[r][c] === 2) seen = false;
            else if (grid[r][c] === 1) seen = true;
            else if (seen && grid[r][c] === 0) grid[r][c] = 3;
        }
        seen = false;
        for (let c = n - 1; c >= 0; c--) {
            if (grid[r][c] === 2) seen = false;
            else if (grid[r][c] === 1) seen = true;
            else if (seen && grid[r][c] === 0) grid[r][c] = 3;
        }
    }

    // column sweeps
    for (const c of colSet) {
        let seen = false;
        for (let r = 0; r < m; r++) {
            if (grid[r][c] === 2) seen = false;
            else if (grid[r][c] === 1) seen = true;
            else if (seen && grid[r][c] === 0) grid[r][c] = 3;
        }
        seen = false;
        for (let r = m - 1; r >= 0; r--) {
            if (grid[r][c] === 2) seen = false;
            else if (grid[r][c] === 1) seen = true;
            else if (seen && grid[r][c] === 0) grid[r][c] = 3;
        }
    }

    // count unguarded
    let ans = 0;
    for (let r = 0; r < m; r++)
        for (let c = 0; c < n; c++)
            if (grid[r][c] === 0) ans++;
    return ans;
}
```

### ðŸ§® Complexity

- **Time:** `O(affected_rows Ã— n + affected_cols Ã— m) â‰¤ O(mÂ·n)`
- **Space:** `O(mÂ·n)`
- **In practice:** faster for sparse grids.

### âš ï¸ Drawbacks

- Skips empty rows/columns entirely.
- Same correctness, better constants.
- Scalable and elegant.

---

## ðŸŽ¯ Comparison

| Approach | Description | Time | Space | Remarks |
|-----------|-------------|-------|--------|----------|
| 1 | Per-guard scans (outward) | O(G Ã— (m+n)) | O(mÂ·n) | Simple but redundant |
| 2 | Four global sweeps | O(mÂ·n) | O(mÂ·n) | Clear & reliable |
| 3 | Selective sweeps (optimized) | â‰¤ O(mÂ·n) | O(mÂ·n) | Best overall |

---

## ðŸ’¬ Common Mistakes

- Using nested scans per guard and per direction â†’ repeated work.  
- Forgetting to stop guard vision at another guard (should block the line of sight).  
- Accidentally overwriting wall/guard cells when marking guarded.  
- Mis-indexing (swapping row/column) in loops.

âœ… **Key takeaway:**  
The **4-direction sweep** idea turns a simulation problem into simple linear passes.  
For sparse setups, sweeping only affected rows/columns gives further optimization without losing clarity.

---


