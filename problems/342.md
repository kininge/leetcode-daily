# 🧩 Problem #342 – Power of Four

**Difficulty:** Easy  
**Topics:** `Bit Manipulation`, `Math`  
**Link:** [Leetcode](https://leetcode.com/problems/power-of-four/description/)

---

## 📜 Problem Summary
Given an integer `n`, return `true` if it is a power of four, otherwise return `false`.

An integer is a power of four if it can be written as:  
$$n = 4^x$$  
where `x` is a non-negative integer.

---

## 💡 Approach 1 – **Recursive Division**

We can repeatedly divide `n` by 4:
- If we end up at exactly 1, it’s a power of four.
- If we hit a non-integer or a remainder, it’s not.

### Steps:
1. If `n <= 0`, return false.
2. Base case: `n === 1` → true.
3. If `n % 4 !== 0`, return false.
4. Recursively check `n / 4`.

### Complexity:
- **Time:** `O(log₄ n)` – each division reduces `n` by factor of 4.
- **Space:** `O(log₄ n)` recursion stack.

### Code:
```javascript
var isPowerOfFour = function(n) {
    if (n <= 0) return false;
    if (n === 1) return true;
    if (n % 4 !== 0) return false;
    return isPowerOfFour(n / 4);
};
```
---

## 💡 Approach 2 – **Bit Manipulation (Loop)**

Observation:
- Power of four → only **one set bit** in binary.
- That bit must be at an **even position** (0, 2, 4, ...).

### Steps:
1. If `n <= 0` → false.
2. Loop through bits 0–30 (since 32-bit signed int).
3. Count set bits:
   - If more than 1 → false.
   - If set bit at odd index → false.
4. Return true if exactly 1 set bit at even index.

### Complexity:
- **Time:** `O(1)` (fixed 31-bit loop)
- **Space:** `O(1)`

### Code:
```javascript
var isPowerOfFour = function(n) {
    if (n <= 0) return false;
    let count = 0;
    for (let i = 0; i < 31; i++) {
        const isSet = (n & (1 << i)) > 0;
        if (isSet && i % 2 !== 0) return false;
        if (isSet) count++;
        if (count > 1) return false;
    }
    return count === 1;
};
```
---

## 💡 Approach 3 – **O(1) Bit Trick (Follow-up)**

We can avoid loops entirely:
1. **Power of two check:** `(n & (n - 1)) === 0`
2. **Even-position check:** bit must lie in mask `0x55555555` (binary `0101…` → even bit positions).

### Why `0x55555555` works:
- In binary, `0x55555555` is `01010101010101010101010101010101`.
- This means bits at positions `0, 2, 4, ...` are `1`, and bits at odd positions are `0`.
- If a number is a power of two **and** `(n & 0x55555555) !== 0`, then its single set bit must be at an even position → a power of four.

### Code:
```javascript
var isPowerOfFour = function(n) {
    return n > 0 &&
           (n & (n - 1)) === 0 && // power of two
           (n & 0x55555555) !== 0; // even position
};
```

### Complexity:
- **Time:** `O(1)`
- **Space:** `O(1)`

---

## 💡 Approach 4 – **Math.log Method**

We can use logarithms:
- If `log₄(n)` is an integer → `n` is a power of four.
- To avoid floating errors, check with `Number.isInteger()`.

### Code:
```javascript
var isPowerOfFour = function(n) {
    return n > 0 && Number.isInteger(Math.log(n) / Math.log(4));
};
```
⚠ **Note:** This approach can fail for very large `n` due to floating-point precision limits.

---

## 🔍 Comparison of Approaches

| Feature | O(1) Bit Trick | Math.log |
|---------|---------------|----------|
| Readability | Concise, a bit “magic” | Very concise |
| Time | O(1) | O(1) |
| Space | O(1) | O(1) |
| Follow-up Ready | ✅ | ✅ (but precision risk) |

---

## 🏆 Final Notes
- All powers of four are powers of two, but not all powers of two are powers of four.
- The `0x55555555` mask ensures the single set bit is at an even index.
- The math approach is neat but should be used with caution for large inputs.

