# ðŸ§© Problem #3349 â€“ Adjacent Increasing Subarrays Detection I

**Difficulty:** Easy  
**Topics:**  `Array`, `Greedy`, `Prefix`  
**Link:** [Leetcode](https://leetcode.com/problems/adjacent-increasing-subarrays-detection-i)

---

## ðŸŽ¯ Problem Summary

Given an array `nums` and an integer `k`, determine whether there exist two **adjacent** subarrays of length `k` (starting at `a` and `b` with `b = a + k`) such that **both** subarrays are strictly increasing.

Return `true` if such adjacent increasing subarrays exist; otherwise return `false`.

**Constraints**
- `2 <= nums.length <= 100`
- `1 < 2*k <= nums.length`
- `-1000 <= nums[i] <= 1000`

---

## ðŸ§© Example  

**Input:**  
```text
nums = [1,2,3,4,5,6], k = 2
```

Output:

```text
true
```


### Explanation:
Subarrays `[1,2]` and `[3,4]` are adjacent and strictly increasing.

---

## ðŸ§  Approach 1 â€” Brute Force

### ðŸ’¡ Idea

- Iterate possible starting indices for the first subarray.
- For each, check whether both subarrays (`nums[a..a+k-1]` and `nums[a+k..a+2k-1]`) are strictly increasing.
- Skip ahead on failure to reduce redundant checks.

### â±ï¸ Complexity

- **Time**: `O(n Ã— k)`
- **Space**: `O(1)`
- For `n â‰¤ 100`, this is perfectly fine.

### âœ… Implementation

```TypeScript []
function hasIncreasingSubarrays(nums: number[], k: number): boolean {
    // edge case
    if(nums.length < (2*k)) return false;
    // edge case
    if(k === 1) return true;
    
    let index: number = 0;
    // check O(n)
    while((index + 2*k) <= nums.length){
        let pairFound: boolean = true;

        for(let i = (index + 1); i < (index + k); i++){
            // fail condition
            if((nums[i - 1] >= nums[i]) || (nums[i - 1 + k] >= nums[i + k])){
                index = i;
                pairFound = false;
                break;
            }
        }

        if(pairFound) return true;
    }

    return false;
};
```

### ðŸ§© Notes

- The logic checks both subarrays in a single pass over their range.
- When either fails (`nums[i-1] >= nums[i]` or `nums[i-1+k] >= nums[i+k]`), we skip forward to i â€” efficient for small inputs.
- Works correctly for all valid constraints (no infinite loops since successful inner loop returns immediately).

---

## âš¡ Approach 2 â€” Cleaner O(n) Variant (Recommended for clarity)

A simpler and more robust way uses a run-length array:
For each index `i`, store how many consecutive increasing edges start there (`run[i]`), then test r`un[i] >= k-1` && `run[i+k] >= k-1`.
This removes manual skipping logic and stays `O(n)`.

ðŸ‘‰ Example:

```Typescript []
function hasIncreasingSubarrays(nums: number[], k: number): boolean {
    const n: number = nums.length;

    // edge case
    if (n < 2 * k) return false;
    if (k === 1) return true;

    // store will have length of increasing sub array
    const store: number[] = new Array<number>(n).fill(0);


    // O(n) - generate length of increasing subarray
    for(let i=1; i<n; i++){
        if(nums[i] > nums[i-1]) store[i] = store[i-1]+1;
    }

    // ex---> nums = [1, 2, 5, 3, 7, 9, 2]
    // then  store = [0, 1, 2, 0, 1, 2, 0]
    // we want 2 adjacent sub arrays of length k
    // then we check index ---> i and i+k
    // where store[i] >= (k-1) && store[i+k] >= (k-1)

    const need: number = k - 1;
    // O(n)
    for(let i=(k-1); (i+k)<n; i++){
        if((store[i] >= need) && (store[i+k] >= need)) return true;
    }

    return false;
}
```

### ðŸ”¬ Comparison

| Approach |	Time |	Space |	Readability |	Comments |
| -------- | ----- | ------ | ----------- | -------- |
| Brute Force |	O(nÂ·k) |	O(1) |	Medium |	Works well for small n |
| Run-length Variant |	O(n) |	O(n) |	âœ… Clearer |	Recommended for maintainability |

---

## ðŸ Final Thoughts

- Your solution is **functionally correct** and efficient for the given limits.
- A run-length pass can simplify logic and avoid potential skips.
- Both achieve `O(n)` worst-case in practice and meet optimal asymptotic bounds.

> ðŸ’¬ "Clever skipping wins today â€” but clean logic always scales tomorrow." ðŸ˜Ž
