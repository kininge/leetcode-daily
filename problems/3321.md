# üß© Problem #3321 ‚Äì Find X Sum of All K Long Subarrays II

**Difficulty:** Hard  
**Topics:** `Sliding Window`, `Heap`
**Link:** [Leetcode](https://leetcode.com/problems/find-x-sum-of-all-k-long-subarrays-ii)

---

## üß† Problem Intuition

We are asked to find the **X-sum** of every contiguous subarray of length `k`.

The **X-sum** of a subarray is defined as:
1. Count the occurrences (frequency) of all distinct numbers.
2. Keep only the top `x` elements by **frequency (descending)** and, for ties, by **value (descending)**.
3. For each of these top `x` elements, multiply `(frequency √ó value)` and sum the results.

We must repeat this efficiently for all sliding windows.

Constraints:
- `n` up to `1e5`
- `nums[i]` up to `1e9`
- Direct brute-force (building frequency + sorting per window) is too slow.

### ‚öôÔ∏è Example

**Input:**
  nums = [5, 2, 5, 3, 5, 2]
  k = 4
  x = 2

**Step-by-step:**
- *Window 1* ‚Üí [5,2,5,3]  
  Frequencies = {5:2, 2:1, 3:1}  
  Top x=2 ‚Üí (5,2), (3,1)  
  Sum = 5√ó2 + 3√ó1 = 13

- *Window 2* ‚Üí [2,5,3,5]  
  Same result = 13

**Output:**
  [13, 13, 13]

---

## üîç Naive Idea and Its Problems

The simplest brute-force approach:
1. For each window of length `k`, build a frequency map.
2. Sort by `(frequency desc, value desc)`.
3. Take top `x` and sum `(freq * value)`.

This works for small `n` but fails for `n=10^5` because:
- Each window builds a fresh frequency map (`O(k)`).
- Each map sort costs `O(k log k)`.
- Total complexity = `O(n * k log k)` ‚Üí **too slow**.

---

## üßÆ Conceptual Two-Heap Model

We can imagine splitting the elements in the current window into **two groups**:

### Code (TypeScript) 
```ts
// Treap-based solution for Find X-Sum of All K-Long Subarrays II
type Key = { freq: number; val: number };

class TreapNode {
    key: Key;
    pr: number;
    left: TreapNode | null = null;
    right: TreapNode | null = null;
    sz: number = 1;
    sum: bigint;

    constructor(key: Key) {
        this.key = key;
        this.pr = Math.random();
        this.sum = BigInt(key.freq) * BigInt(key.val);
    }
}

function cmpKey(a: Key, b: Key): number {
    if (a.freq !== b.freq) return a.freq - b.freq;
    return a.val - b.val;
}
function updateNode(t: TreapNode | null): void {
    if (!t) return;
    t.sz = 1;
    t.sum = BigInt(t.key.freq) * BigInt(t.key.val);
    if (t.left) {
        t.sz += t.left.sz;
        t.sum += t.left.sum;
    }
    if (t.right) {
        t.sz += t.right.sz;
        t.sum += t.right.sum;
    }
}
function split(t: TreapNode | null, key: Key): [TreapNode | null, TreapNode | null] {
    if (!t) return [null, null];
    if (cmpKey(t.key, key) < 0) {
        const [l2, r2] = split(t.right, key);
        t.right = l2;
        updateNode(t);
        return [t, r2];
    } else {
        const [l2, r2] = split(t.left, key);
        t.left = r2;
        updateNode(t);
        return [l2, t];
    }
}
function merge(a: TreapNode | null, b: TreapNode | null): TreapNode | null {
    if (!a) return b;
    if (!b) return a;
    if (a.pr < b.pr) {
        a.right = merge(a.right, b);
        updateNode(a);
        return a;
    } else {
        b.left = merge(a, b.left);
        updateNode(b);
        return b;
    }
}
function insertNode(t: TreapNode | null, node: TreapNode): TreapNode {
    if (!t) return node;
    if (node.pr < t.pr) {
        const [l, r] = split(t, node.key);
        node.left = l;
        node.right = r;
        updateNode(node);
        return node;
    } else {
        if (cmpKey(node.key, t.key) < 0) t.left = insertNode(t.left, node);
        else t.right = insertNode(t.right, node);
        updateNode(t);
        return t;
    }
}
function eraseKey(t: TreapNode | null, key: Key): TreapNode | null {
    if (!t) return null;
    const c = cmpKey(key, t.key);
    if (c === 0) {
        return merge(t.left, t.right);
    } else if (c < 0) {
        t.left = eraseKey(t.left, key);
        updateNode(t);
        return t;
    } else {
        t.right = eraseKey(t.right, key);
        updateNode(t);
        return t;
    }
}
function sumLargest(t: TreapNode | null, k: number): bigint {
    if (!t || k <= 0) return BigInt(0);
    const rsz = t.right ? t.right.sz : 0;
    if (rsz >= k) {
        return sumLargest(t.right, k);
    } else {
        const rsum = t.right ? t.right.sum : BigInt(0);
        const takeHere = (rsz + 1) <= k ? BigInt(t.key.freq) * BigInt(t.key.val) : BigInt(0);
        const needLeft = k - rsz - 1;
        const lsum = needLeft > 0 ? sumLargest(t.left, needLeft) : BigInt(0);
        return rsum + takeHere + lsum;
    }
}

function findXSum(nums: number[], k: number, x: number): number[] {
    const n = nums.length;
    const ans: number[] = new Array(n - k + 1).fill(0);
    const freq = new Map<number, number>();
    let root: TreapNode | null = null;

    function insertOrUpdate(val: number, newFreq: number) {
        if (newFreq <= 0) return;
        const node = new TreapNode({ freq: newFreq, val });
        root = insertNode(root, node);
    }
    function erasePrevious(val: number, oldFreq: number) {
        if (oldFreq <= 0) return;
        root = eraseKey(root, { freq: oldFreq, val });
    }

    // build first window
    for (let i = 0; i < k; i++) {
        const v = nums[i];
        const old = freq.get(v) ?? 0;
        if (old > 0) erasePrevious(v, old);
        const nw = old + 1;
        freq.set(v, nw);
        insertOrUpdate(v, nw);
    }
    ans[0] = Number(sumLargest(root, x));

    for (let i = k; i < n; i++) {
        const out = nums[i - k];
        const oldOut = freq.get(out) ?? 0;
        if (oldOut > 0) {
            erasePrevious(out, oldOut);
            const newOut = oldOut - 1;
            if (newOut === 0) freq.delete(out);
            else {
                freq.set(out, newOut);
                insertOrUpdate(out, newOut);
            }
        }

        const inc = nums[i];
        const oldInc = freq.get(inc) ?? 0;
        if (oldInc > 0) erasePrevious(inc, oldInc);
        const newInc = oldInc + 1;
        freq.set(inc, newInc);
        insertOrUpdate(inc, newInc);

        ans[i - k + 1] = Number(sumLargest(root, x));
    }

    return ans;
}
```

### ‚ö° Complexity Analysis

| Operation | Time | Space |
|------------|------|--------|
| Insert / Erase (Treap) | O(log D) expected | O(1) |
| sumLargest(x) query | O(log D) expected | O(1) |
| Per window slide | O(log D) | O(k) overall |

**Total:** O(n log k)  
**Space:** O(k)

Where `D` = distinct elements in the current window (‚â§ k).
