# ðŸ§© Problem #120 â€“ Triangle

**Difficulty:** Medium  
**Tags:** Dynamic Programming, Recursion, Greedy, Array  
**Link:** [LeetCode](https://leetcode.com/problems/triangle/)

---

## ðŸ§  Intuition
From any element `triangle[i][j]` you can move to `triangle[i+1][j]` or `triangle[i+1][j+1]`.  
This naturally defines overlapping subproblems: the minimum path sum from `(i,j)` equals `triangle[i][j] + min(minPath(i+1,j), minPath(i+1,j+1))`.  
We can solve this with recursion + memo (top-down) or bottom-up DP. The follow-up asks for `O(n)` extra space (where `n` = number of rows): use a 1D DP array.

---

## ðŸ’¡ Approaches

### Approach A â€” DFS + Memo (Top-down)
- Define `dfs(i, j)` = minimum path sum starting **at** `triangle[i][j]`.
- Recurrence: `dfs(i,j) = triangle[i][j] + min(dfs(i+1,j), dfs(i+1,j+1))`
- Memoize results to avoid recomputation.
- Pros: easy to reason about, mirrors recurrence.  
- Cons: uses `O(rows^2)` memo in worst case; recursion depth = rows (â‰¤ 200 â‡’ safe).

### Approach B â€” 1D DP (Bottom-up, O(rows) extra space) â€” recommended for follow-up
- Start from the last row as `dp = lastRow.slice()`.
- Move upward: for row `i` and index `j` do `dp[j] = triangle[i][j] + min(dp[j], dp[j+1])`.
- After finishing row `0`, `dp[0]` has the answer.
- Pros: `O(n^2)` time, `O(n)` extra space, does not mutate input if you slice the last row.

### Approach C â€” In-place Bottom-up (mutates input)
- Same as 1D idea but write results directly into `triangle` from bottom up.
- Very short and fast, but modifies the input triangle (may be undesirable).

---

## âœ… Code

### A. DFS + Memo (clean JS)
```javascript []
// DFS + memo (clean, numeric memo key)
var minimumTotal = function(triangle) {
  const n = triangle.length;
  const memo = new Map(); // key = i * n + j

  function dfs(i, j) {
    const key = i * n + j;
    if (memo.has(key)) return memo.get(key);

    if (i === n - 1) {
      memo.set(key, triangle[i][j]);
      return triangle[i][j];
    }

    const left = dfs(i + 1, j);
    const right = dfs(i + 1, j + 1);
    const res = triangle[i][j] + Math.min(left, right);
    memo.set(key, res);
    return res;
  }

  return dfs(0, 0);
};
```

### B. 1D DP â€” Bottom-up (JS) â€” O(rows) extra space
```javascript []
// 1D DP, does not mutate original if you slice last row
var minimumTotal = function(triangle) {
  const n = triangle.length;
  // dp initialized to last row
  const dp = triangle[n - 1].slice(); // length = n

  for (let i = n - 2; i >= 0; i--) {
    for (let j = 0; j <= i; j++) {
      dp[j] = triangle[i][j] + Math.min(dp[j], dp[j + 1]);
    }
  }
  return dp[0];
};
```

### C. In-place Bottom-up (mutates triangle)
```javascript []
// in-place (modifies triangle)
var minimumTotal = function(triangle) {
  const N = triangle.length;
  for (let i = N - 2; i >= 0; i--) {
    for (let j = 0; j < triangle[i].length; j++) {
      triangle[i][j] += Math.min(triangle[i+1][j], triangle[i+1][j+1]);
    }
  }
  return triangle[0][0];
};
```

## ðŸ“Š Complexity

- DFS + Memo:
  - **Time**: `O(total elements)` â‰ˆ `O(n^2)` (each cell computed once).
  - **Space**: `O(n^2)` memo worst-case + `O(n)` recursion stack.

- 1D DP:
  - **Time**: `O(n^2)`.
  - **Space**: `O(n)` extra (n = number of rows).

- In-place:
  - **Time**: `O(n^2)`.
  - **Space**: `O(1)` extra (but mutates input).
