# ðŸ§© Problem #3074 â€“ Apple Redistribution into Boxes

**Difficulty:** Easy  
**Topics:** `Greedy`, `Sorting`  
**Link:** https://leetcode.com/problems/apple-redistribution-into-boxes/

---

## ðŸ“ Problem Summary

You are given two arrays:

- `apple[i]` â†’ number of apples in the `i`-th pack
- `capacity[j]` â†’ maximum number of apples the `j`-th box can hold

You need to **redistribute all apples from all packs into boxes**, with these rules:

- Apples from the same pack **can be split across multiple boxes**
- Each box has a fixed capacity
- You may choose **any subset of boxes**

Your task is to return the **minimum number of boxes** required to store **all apples**.

It is guaranteed that a solution always exists.

---

## ðŸ’¡ Intuition

All apples can be freely redistributed across boxes, even splitting apples from the same pack.
So the **only thing that matters** is:

ðŸ‘‰ **Total number of apples**  
ðŸ‘‰ **Total capacity of chosen boxes**

This removes any dependency on *which* apple pack goes into *which* box.

So the problem reduces to:

> Select the **minimum number of boxes** whose **combined capacity â‰¥ total apples**.

To minimize the number of boxes:
- Always pick the **largest capacity boxes first** (greedy choice).

Why greedy works:
- Picking a smaller box instead of a larger one can only increase the number of boxes needed.
- Since all apples are identical in redistribution, thereâ€™s no penalty for choosing big boxes early.

This is a classic:
- **Greedy + Sorting** problem
- Similar to â€œminimum items to reach target sumâ€

So the plan:
1. Compute `totalApples`
2. Sort `capacity` in descending order
3. Keep adding box capacities until totalApples â‰¤ 0
4. Count how many boxes were used

---

## ðŸ›  Approach

This is a **greedy optimization** problem.

### Key observations

- Apples are **indistinguishable** once summed:
  - Packs donâ€™t matter because apples from the same pack can go into different boxes.
- The only thing that matters is: `total apples â‰¤ sum of selected box capacities`
- To minimize the number of boxes:
ðŸ‘‰ Always take the **largest capacity boxes first**.

### Strategy

1. Compute the total number of apples.
2. Sort the `capacity` array in **descending order**.
3. Keep selecting boxes (largest first) until their combined capacity
 covers all apples.
4. Count how many boxes were needed.

This greedy choice is optimal because:
- Any smaller box can never replace a larger box and reduce the count.

---

## ðŸ§¾ Code (Greedy)

```ts
function minimumBoxes(apple: number[], capacity: number[]): number {
    // Total apples to redistribute
    let totalApples = apple.reduce((sum, x) => sum + x, 0);

    // Sort box capacities in descending order
    capacity.sort((a, b) => b - a);

    let boxes = 0;

    // Pick largest boxes first until all apples are placed
    while (totalApples > 0) {
        totalApples -= capacity[boxes];
        boxes++;
    }

    return boxes;
}
```

---

## â± Complexity Analysis

Let:
- `n = apple.length`
- `m = capacity.length`

### Step-by-step costs

1. **Summing total apples**
   ```ts
   apple.reduce(...)
   ```
- **Time:** `O(n)`
- **Space:** `O(1)`

2. Sorting box capacities (descending)
  ```ts
  capacity.sort((a, b) => b - a)
  ```
  - **Time:** `O(m log m)`
  - **Space:** `O(1)` (ignoring JS engine internals)

3. Greedy box selection loop
  ```
  while (totalApples > 0) { ... }
  ```
  - **Time:** `O(m)` in worst case
  - **Space:** `O(1)`

### Overall Complexity
  - **Time:**  `O(n + m log m)`
  - **Space:** `O(1)`


This is optimal because:
  - Sorting the capacities is necessary to make the greedy choice.
  - No extra data structures are used.

---
