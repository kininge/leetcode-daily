# üß© Problem #2787 ‚Äì Ways to Express an Integer as Sum of Powers

**Difficulty:** Medium  
**Topics:** `Dynamic Programming`, `Math` 
**Link:** [Leetcode](https://leetcode.com/problems/ways-to-express-an-integer-as-sum-of-powers/description/)

---

## üìú Problem Summary
Given two integers `n` and `x`, find the **number of distinct ways** to express `n` as the sum of **distinct** positive integers each raised to the power `x`.

We must return the answer modulo `10^9 + 7`.

---

## üí° Approach 1 ‚Äì **Recursive + Memoization (Top-Down)**

We try all numbers starting from `1`, decide **take** or **skip** it, and recurse.  
If we reach `sum == n`, that‚Äôs a valid way.

### Steps:
1. Precompute all `i^x ‚â§ n`.
2. Use recursion:
   - `dfs(index, remaining)` ‚Üí number of ways to form `remaining` using powers from `index` onwards.
   - Choices:
     - **Skip** current power ‚Üí `dfs(index+1, remaining)`
     - **Take** current power (if ‚â§ remaining) ‚Üí `dfs(index+1, remaining - powers[index])`
3. Use memoization to avoid recomputing states.

### Complexity:
- **Time:** `O(k * n)` where `k` = number of powers ‚â§ `n`.
- **Space:** `O(k * n)` for memoization table.

### Code:
```javascript
var numberOfWays = function(n, x) {
    const MOD = 1e9 + 7;

    // Step 1: generate all powers
    const powers = [];
    for (let i = 1; Math.pow(i, x) <= n; i++) {
        powers.push(Math.pow(i, x));
    }

    // Step 2: memoization cache
    const memo = new Map();

    function dfs(i, rem) {
        if (rem === 0) return 1;
        if (i >= powers.length || rem < 0) return 0;

        const key = `${i}-${rem}`;
        if (memo.has(key)) return memo.get(key);

        // Skip + Take
        let ways = dfs(i + 1, rem) % MOD;
        ways = (ways + dfs(i + 1, rem - powers[i])) % MOD;

        memo.set(key, ways);
        return ways;
    }

    return dfs(0, n);
};
```

---

## üí° Approach 2 ‚Äì Iterative 1D DP (Bottom-Up)

This is like 0/1 Knapsack:
- Each power can be used at most once.
- We count combinations that sum to n.

### Steps:
1. Precompute all i^x ‚â§ n.
2. Let dp[w] = number of ways to form sum w.
3. Initialize dp[0] = 1.
4. For each power p:
- - Loop w from n down to p: 
```text
$$dp[w] = (dp[w] + dp[w - p]) % MOD$$
```

### Why backward loop?
Because we don‚Äôt want to reuse the same power multiple times ‚Äî backward ensures each p is counted only once per sum.

### Complexity:
- Time: $$O(k * n)$$
- Space: $$O(n)$$

Code:
```javascript []
var numberOfWays = function(n, x) {
    const MOD = 1e9 + 7;

    // Step 1: Generate all powers <= n
    const powers = [];
    for (let i = 1; Math.pow(i, x) <= n; i++) {
        powers.push(Math.pow(i, x));
    }

    // Step 2: DP array
    const dp = Array(n + 1).fill(0);
    dp[0] = 1;

    for (const p of powers) {
        for (let w = n; w >= p; w--) {
            dp[w] = (dp[w] + dp[w - p]) % MOD;
        }
    }

    return dp[n];
};
```

## üîç Comparison of Both Approaches


| Feature |	Recursive + Memoization |	Iterative 1D DP |
|----------|----------|----------|
| Readability |	Easier to think recursively |	More compact and fast |
| Time |	O(k * n) |	O(k * n) |
| Space |	O(k * n) | recursion + memo	O(n) |
| When to use |	Small/medium constraints, learning recursion |	Large constraints, memory-efficient |

## üèÜ Final Notes

- Both solutions rely on precomputing powers first.
- The iterative approach is faster in practice and uses less memory.
- Recursive + memoization is more intuitive but heavier for large n.
