# ðŸ§© Problem #2654 â€“ Minimum Number of Operations to Make All Array Elements Equal to 1

**Difficulty:** Medium  
**Topics:** `Math`  
**Link:** [Leetcode](https://leetcode.com/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1)

---

## âš™ï¸ Problem Intuition

We can replace an element with the GCD of any adjacent pair (`nums[i]`, `nums[i+1]`).

Our goal is to make **all elements = 1** using the minimum number of operations.

### Key Observation:
- Once we have **at least one `1`** in the array, we can easily make the rest all `1`s â€”  
  each adjacent element can be converted to `1` in **one operation**.
- So, the main difficulty is: **how to create the first `1`**.

---

## ðŸ§© Step 1 â€” If the array already has `1`

If `countOfOnes > 0`:
- Each non-1 element can be turned into `1` in one step.
- Therefore, `answer = n - countOfOnes`.

**Example:**

nums = [1, 2, 3]
=> we already have one 1
=> convert 2 â†’ 1 (1 step), 3 â†’ 1 (1 step)
=> total = 2 steps = n - countOfOnes = 3 - 1 = 2

---

## ðŸ§© Step 2 â€” If no `1` exists

We must **create** a `1` using the allowed operation.

That means finding a **subarray whose GCD = 1**.
The smaller this subarray, the faster we can create a `1`.

### We want:
`minLen = smallest subarray length such that gcd(nums[i..j]) == 1`

If no subarray has GCD = 1, it's **impossible** â†’ return `-1`.

---

## ðŸ§  Step 3 â€” Formula for total operations

Once we find that subarray of length `L` (with gcd=1):

- We need **(L âˆ’ 1)** operations to turn that subarray into a single `1`.  
  (Each operation merges two adjacent elements and shrinks the subarray by 1.)

- After we have one `1`,  
  We need **(n âˆ’ 1)** operations to make all others `1`.

Hence,

```text 
Total operations = (L âˆ’ 1) + (n âˆ’ 1) = L + n âˆ’ 2
```

---

## ðŸ“˜ Proof â€” Why `(L âˆ’ 1)` operations make one `1`

Consider the subarray that has GCD = 1:

```text
nums = [a1, a2, ..., aL] with gcd(a1, a2, ..., aL) = 1
```

Each operation can replace an element with the gcd of it and its neighbour,  
reducing the *effective range* by one.

For example:

```text
[6, 10, 15] â†’ gcd(6,10)=2 â†’ [2,15]
â†’ gcd(2,15)=1 â†’ [1]
```

Here L=3 and it took Lâˆ’1 = 2 operations.

Since each gcd operation reduces the segment size by one,
and we need to shrink a length-L segment into a single 1,
It will always take exactly Lâˆ’1 steps to produce the first `1`.

---

## ðŸ’» Full Solution (TypeScript)

```ts
function GCD(num1: number, num2: number): number {
  while (num2 !== 0) {
    const reminder:number = num1 % num2;
    num1 = num2;
    num2 = reminder;
  }
  return num1;
}

function minOperations(nums: number[]): number {
    const n:number = nums.length;

    // Step 1: Count 1
    let oneCount:number = 0;
    for(const num of nums) if(num===1) oneCount++;
    // if there is already 1 present in the array
    if(oneCount > 0) return n-oneCount;

    // Step 2: Find the smallest subarray that has GCD 1
    let minLen:number = Infinity;
    for(let i=0; i<n; i++){
        let gcd:number = nums[i];

        for(let j=(i+1); j<n; j++){
            gcd = GCD(gcd, nums[j]);

            if(gcd === 1){
                const len:number = j-i+1;

                if(len < minLen) minLen = len;
                break;
            }
        }
    }

    // Step 3: Once you know the 'minLen' now just a simple calculation for the answer
    if(minLen === Infinity) return -1; // impossible
    // L-1 ops to create first 1, then (n-1) to convert all elements to 1
    return (minLen - 1) + (n - 1);
}
```

---

## ðŸ§® Example

Input:  
`nums = [2,6,3,4]`

- No `1`s initially.
- Smallest subarray with gcd=1 â†’ [6,3,4] (length 3)
- Formula â†’ (3 - 1) + (4 - 1) = 2 + 3 = 5

âœ… Output = 5

---

## ðŸ“Š Complexity

| Step | Operation | Complexity |
|------|------------|-------------|
| Counting 1s | O(n) |  |
| Finding subarray with gcd=1 | O(nÂ² logA) | each gcd â‰ˆ logA |
| Overall | O(nÂ² logA) | n â‰¤ 50, fast enough |
| Space | O(1) | constant |

---


